Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOUBLE_QUOTATION_MARK
    ELSE
    FOR
    FROM
    IMPL
    IN
    MATCH
    NOT
    QUOTATION_MARK
    RAND
    SELF
    STR
    STRUCT
    WHILE

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencias
Rule 2     programa -> sentencias programa
Rule 3     asignacion -> LET IDENTIFIER ASIG valor
Rule 4     asignacion -> LET MUT IDENTIFIER ASIG valor
Rule 5     asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor
Rule 6     asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor
Rule 7     comparacion -> valor EQ valor
Rule 8     comparacion -> valor NEQ valor
Rule 9     comparacion -> valor GEQ valor
Rule 10    comparacion -> valor LEQ valor
Rule 11    comparacion -> valor RIGHTARROW valor
Rule 12    comparacion -> valor LEFTARROW valor
Rule 13    valor -> INTEGER
Rule 14    valor -> FLOAT
Rule 15    valor -> IDENTIFIER
Rule 16    valor -> operacion
Rule 17    valor -> indexacion
Rule 18    valor -> arreglos
Rule 19    valor -> STRING
Rule 20    valor -> booleanos
Rule 21    booleanos -> TRUE
Rule 22    booleanos -> FALSE
Rule 23    vacio -> <empty>
Rule 24    sentencias -> asignacion SEMICOLON
Rule 25    sentencias -> impresion SEMICOLON
Rule 26    sentencias -> funcion
Rule 27    sentencias -> ingreso_datos SEMICOLON
Rule 28    sentencias -> arreglos SEMICOLON
Rule 29    sentencias -> control_structure
Rule 30    sentencias -> llamada SEMICOLON
Rule 31    impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN
Rule 32    impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
Rule 33    funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
Rule 34    funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
Rule 35    funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
Rule 36    funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
Rule 37    funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 38    funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 39    retorno -> RETURN valor SEMICOLON
Rule 40    parameters -> IDENTIFIER COLON asig_data_type
Rule 41    parameters -> IDENTIFIER COLON asig_data_type COMMA parameters
Rule 42    parameters -> vacio
Rule 43    ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
Rule 44    asig_data_type -> data_type
Rule 45    asig_data_type -> LPAREN some_data_type RPAREN
Rule 46    asig_data_type -> LCORCH some_data_type RCORCH
Rule 47    data_type -> CHAR
Rule 48    data_type -> signed_integer
Rule 49    data_type -> unsigned_integer
Rule 50    data_type -> float_type
Rule 51    data_type -> BOOL
Rule 52    signed_integer -> I8
Rule 53    signed_integer -> I16
Rule 54    signed_integer -> I32
Rule 55    signed_integer -> I64
Rule 56    signed_integer -> I128
Rule 57    signed_integer -> ISIZE
Rule 58    unsigned_integer -> U8
Rule 59    unsigned_integer -> U16
Rule 60    unsigned_integer -> U32
Rule 61    unsigned_integer -> U64
Rule 62    unsigned_integer -> U128
Rule 63    unsigned_integer -> USIZE
Rule 64    float_type -> F32
Rule 65    float_type -> F64
Rule 66    some_data_type -> data_type
Rule 67    some_data_type -> data_type COMMA some_data_type
Rule 68    control_structure -> condicional
Rule 69    arreglos -> LCORCH valores RCORCH
Rule 70    valores -> valor
Rule 71    valores -> valor COMMA valores
Rule 72    conector -> AND
Rule 73    conector -> OR
Rule 74    proposicion -> comparacion conector proposicion
Rule 75    proposicion -> comparacion
Rule 76    condicional -> IF comparacion LLLAVE programa RLLAVE
Rule 77    condicional -> IF proposicion LLLAVE programa RLLAVE
Rule 78    operacion -> valor PLUS valor
Rule 79    operacion -> valor MINUS valor
Rule 80    operacion -> valor TIMES valor
Rule 81    operacion -> valor DIVIDE valor
Rule 82    operacion -> valor MOD valor
Rule 83    operacion -> valor INTD valor
Rule 84    indexacion -> IDENTIFIER LCORCH INTEGER RCORCH
Rule 85    llamada -> IDENTIFIER LPAREN valores RPAREN

Terminals, with rules where they appear

AND                  : 72
ASIG                 : 3 4 5 6
BOOL                 : 51
CHAR                 : 47
COLON                : 5 6 40 41
COMMA                : 32 41 67 71
DIVIDE               : 81
DOT                  : 43 43
DOUBLE_COLON         : 43 43
DOUBLE_QUOTATION_MARK : 
ELSE                 : 
EQ                   : 7
EXCLAMATION          : 31 32
F32                  : 64
F64                  : 65
FALSE                : 22
FLOAT                : 14
FN                   : 33 34 35 36 37 38
FOR                  : 
FROM                 : 
GEQ                  : 9
I128                 : 56
I16                  : 53
I32                  : 54
I64                  : 55
I8                   : 52
IDENTIFIER           : 3 4 5 6 15 33 36 37 38 40 41 43 84 85
IF                   : 76 77
IMPL                 : 
IN                   : 
INTD                 : 83
INTEGER              : 13 84
IO                   : 43
ISIZE                : 57
LCORCH               : 46 69 84
LEFTARROW            : 12
LEQ                  : 10
LET                  : 3 4 5 6
LLLAVE               : 33 34 35 36 37 38 76 77
LPAREN               : 31 32 33 34 35 36 37 38 43 43 45 85
MAIN                 : 34 35
MATCH                : 
MINUS                : 37 38 79
MOD                  : 82
MUT                  : 4 6 43
NEQ                  : 8
NOT                  : 
OR                   : 73
PLUS                 : 78
PRINTLN              : 31 32
QUOTATION_MARK       : 
RAND                 : 
RCORCH               : 46 69 84
READLINE             : 43
REFERENCE            : 43
RETURN               : 39
RIGHTARROW           : 11 37 38
RLLAVE               : 33 34 35 36 37 38 76 77
RPAREN               : 31 32 33 34 35 36 37 38 43 43 45 85
SELF                 : 
SEMICOLON            : 24 25 27 28 30 39
STD                  : 43
STDIN                : 43
STR                  : 
STRING               : 19
STRUCT               : 
TIMES                : 80
TRUE                 : 21
U128                 : 62
U16                  : 59
U32                  : 60
U64                  : 61
U8                   : 58
USIZE                : 63
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arreglos             : 18 28
asig_data_type       : 5 6 40 41
asignacion           : 24
booleanos            : 20
comparacion          : 74 75 76
condicional          : 68
conector             : 74
control_structure    : 29
data_type            : 37 38 44 66 67
float_type           : 50
funcion              : 26
impresion            : 25
indexacion           : 17
ingreso_datos        : 27
llamada              : 30
operacion            : 16
parameters           : 33 34 37 41
programa             : 2 33 34 35 36 37 38 76 77 0
proposicion          : 74 77
retorno              : 37 38
sentencias           : 1 2
signed_integer       : 48
some_data_type       : 45 46 67
unsigned_integer     : 49
vacio                : 42
valor                : 3 4 5 6 7 7 8 8 9 9 10 10 11 11 12 12 31 32 39 70 71 78 78 79 79 80 80 81 81 82 82 83 83
valores              : 32 69 71 85

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 1
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencias .
    (2) programa -> sentencias . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    $end            reduce using rule 1 (programa -> sentencias .)
    RLLAVE          reduce using rule 1 (programa -> sentencias .)
    RETURN          reduce using rule 1 (programa -> sentencias .)
    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    sentencias                     shift and go to state 2
    programa                       shift and go to state 18
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 3

    (24) sentencias -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 19


state 4

    (25) sentencias -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 20


state 5

    (26) sentencias -> funcion .

    LET             reduce using rule 26 (sentencias -> funcion .)
    PRINTLN         reduce using rule 26 (sentencias -> funcion .)
    FN              reduce using rule 26 (sentencias -> funcion .)
    STD             reduce using rule 26 (sentencias -> funcion .)
    LCORCH          reduce using rule 26 (sentencias -> funcion .)
    IDENTIFIER      reduce using rule 26 (sentencias -> funcion .)
    IF              reduce using rule 26 (sentencias -> funcion .)
    $end            reduce using rule 26 (sentencias -> funcion .)
    RLLAVE          reduce using rule 26 (sentencias -> funcion .)
    RETURN          reduce using rule 26 (sentencias -> funcion .)


state 6

    (27) sentencias -> ingreso_datos . SEMICOLON

    SEMICOLON       shift and go to state 21


state 7

    (28) sentencias -> arreglos . SEMICOLON

    SEMICOLON       shift and go to state 22


state 8

    (29) sentencias -> control_structure .

    LET             reduce using rule 29 (sentencias -> control_structure .)
    PRINTLN         reduce using rule 29 (sentencias -> control_structure .)
    FN              reduce using rule 29 (sentencias -> control_structure .)
    STD             reduce using rule 29 (sentencias -> control_structure .)
    LCORCH          reduce using rule 29 (sentencias -> control_structure .)
    IDENTIFIER      reduce using rule 29 (sentencias -> control_structure .)
    IF              reduce using rule 29 (sentencias -> control_structure .)
    $end            reduce using rule 29 (sentencias -> control_structure .)
    RLLAVE          reduce using rule 29 (sentencias -> control_structure .)
    RETURN          reduce using rule 29 (sentencias -> control_structure .)


state 9

    (30) sentencias -> llamada . SEMICOLON

    SEMICOLON       shift and go to state 23


state 10

    (3) asignacion -> LET . IDENTIFIER ASIG valor
    (4) asignacion -> LET . MUT IDENTIFIER ASIG valor
    (5) asignacion -> LET . IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> LET . MUT IDENTIFIER COLON asig_data_type ASIG valor

    IDENTIFIER      shift and go to state 24
    MUT             shift and go to state 25


state 11

    (85) llamada -> IDENTIFIER . LPAREN valores RPAREN

    LPAREN          shift and go to state 26


state 12

    (31) impresion -> PRINTLN . EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> PRINTLN . EXCLAMATION LPAREN valor COMMA valores RPAREN

    EXCLAMATION     shift and go to state 27


state 13

    (33) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> FN . MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> FN . MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> FN . IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    IDENTIFIER      shift and go to state 28
    MAIN            shift and go to state 29


state 14

    (43) ingreso_datos -> STD . DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 30


state 15

    (69) arreglos -> LCORCH . valores RCORCH
    (70) valores -> . valor
    (71) valores -> . valor COMMA valores
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valores                        shift and go to state 31
    valor                          shift and go to state 32
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 16

    (68) control_structure -> condicional .

    LET             reduce using rule 68 (control_structure -> condicional .)
    PRINTLN         reduce using rule 68 (control_structure -> condicional .)
    FN              reduce using rule 68 (control_structure -> condicional .)
    STD             reduce using rule 68 (control_structure -> condicional .)
    LCORCH          reduce using rule 68 (control_structure -> condicional .)
    IDENTIFIER      reduce using rule 68 (control_structure -> condicional .)
    IF              reduce using rule 68 (control_structure -> condicional .)
    $end            reduce using rule 68 (control_structure -> condicional .)
    RLLAVE          reduce using rule 68 (control_structure -> condicional .)
    RETURN          reduce using rule 68 (control_structure -> condicional .)


state 17

    (76) condicional -> IF . comparacion LLLAVE programa RLLAVE
    (77) condicional -> IF . proposicion LLLAVE programa RLLAVE
    (7) comparacion -> . valor EQ valor
    (8) comparacion -> . valor NEQ valor
    (9) comparacion -> . valor GEQ valor
    (10) comparacion -> . valor LEQ valor
    (11) comparacion -> . valor RIGHTARROW valor
    (12) comparacion -> . valor LEFTARROW valor
    (74) proposicion -> . comparacion conector proposicion
    (75) proposicion -> . comparacion
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    comparacion                    shift and go to state 43
    proposicion                    shift and go to state 44
    valor                          shift and go to state 45
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 18

    (2) programa -> sentencias programa .

    $end            reduce using rule 2 (programa -> sentencias programa .)
    RLLAVE          reduce using rule 2 (programa -> sentencias programa .)
    RETURN          reduce using rule 2 (programa -> sentencias programa .)


state 19

    (24) sentencias -> asignacion SEMICOLON .

    LET             reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    PRINTLN         reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    FN              reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    STD             reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    LCORCH          reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    IDENTIFIER      reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    IF              reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    $end            reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    RLLAVE          reduce using rule 24 (sentencias -> asignacion SEMICOLON .)
    RETURN          reduce using rule 24 (sentencias -> asignacion SEMICOLON .)


state 20

    (25) sentencias -> impresion SEMICOLON .

    LET             reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    FN              reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    STD             reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    LCORCH          reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    IF              reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    $end            reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    RLLAVE          reduce using rule 25 (sentencias -> impresion SEMICOLON .)
    RETURN          reduce using rule 25 (sentencias -> impresion SEMICOLON .)


state 21

    (27) sentencias -> ingreso_datos SEMICOLON .

    LET             reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    PRINTLN         reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    FN              reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    STD             reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    LCORCH          reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    IF              reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    $end            reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    RLLAVE          reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)
    RETURN          reduce using rule 27 (sentencias -> ingreso_datos SEMICOLON .)


state 22

    (28) sentencias -> arreglos SEMICOLON .

    LET             reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    PRINTLN         reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    FN              reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    STD             reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    LCORCH          reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    IF              reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    $end            reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    RLLAVE          reduce using rule 28 (sentencias -> arreglos SEMICOLON .)
    RETURN          reduce using rule 28 (sentencias -> arreglos SEMICOLON .)


state 23

    (30) sentencias -> llamada SEMICOLON .

    LET             reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    PRINTLN         reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    FN              reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    STD             reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    LCORCH          reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    IF              reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    $end            reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    RLLAVE          reduce using rule 30 (sentencias -> llamada SEMICOLON .)
    RETURN          reduce using rule 30 (sentencias -> llamada SEMICOLON .)


state 24

    (3) asignacion -> LET IDENTIFIER . ASIG valor
    (5) asignacion -> LET IDENTIFIER . COLON asig_data_type ASIG valor

    ASIG            shift and go to state 46
    COLON           shift and go to state 47


state 25

    (4) asignacion -> LET MUT . IDENTIFIER ASIG valor
    (6) asignacion -> LET MUT . IDENTIFIER COLON asig_data_type ASIG valor

    IDENTIFIER      shift and go to state 48


state 26

    (85) llamada -> IDENTIFIER LPAREN . valores RPAREN
    (70) valores -> . valor
    (71) valores -> . valor COMMA valores
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valores                        shift and go to state 49
    valor                          shift and go to state 32
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 27

    (31) impresion -> PRINTLN EXCLAMATION . LPAREN valor RPAREN
    (32) impresion -> PRINTLN EXCLAMATION . LPAREN valor COMMA valores RPAREN

    LPAREN          shift and go to state 50


state 28

    (33) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (36) funcion -> FN IDENTIFIER . LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> FN IDENTIFIER . LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LPAREN          shift and go to state 51


state 29

    (34) funcion -> FN MAIN . LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> FN MAIN . LPAREN RPAREN LLLAVE programa RLLAVE

    LPAREN          shift and go to state 52


state 30

    (43) ingreso_datos -> STD DOUBLE_COLON . IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    IO              shift and go to state 53


state 31

    (69) arreglos -> LCORCH valores . RCORCH

    RCORCH          shift and go to state 54


state 32

    (70) valores -> valor .
    (71) valores -> valor . COMMA valores
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    RCORCH          reduce using rule 70 (valores -> valor .)
    RPAREN          reduce using rule 70 (valores -> valor .)
    COMMA           shift and go to state 55
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 33

    (13) valor -> INTEGER .

    COMMA           reduce using rule 13 (valor -> INTEGER .)
    PLUS            reduce using rule 13 (valor -> INTEGER .)
    MINUS           reduce using rule 13 (valor -> INTEGER .)
    TIMES           reduce using rule 13 (valor -> INTEGER .)
    DIVIDE          reduce using rule 13 (valor -> INTEGER .)
    MOD             reduce using rule 13 (valor -> INTEGER .)
    INTD            reduce using rule 13 (valor -> INTEGER .)
    RCORCH          reduce using rule 13 (valor -> INTEGER .)
    EQ              reduce using rule 13 (valor -> INTEGER .)
    NEQ             reduce using rule 13 (valor -> INTEGER .)
    GEQ             reduce using rule 13 (valor -> INTEGER .)
    LEQ             reduce using rule 13 (valor -> INTEGER .)
    RIGHTARROW      reduce using rule 13 (valor -> INTEGER .)
    LEFTARROW       reduce using rule 13 (valor -> INTEGER .)
    RPAREN          reduce using rule 13 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 13 (valor -> INTEGER .)
    LLLAVE          reduce using rule 13 (valor -> INTEGER .)
    AND             reduce using rule 13 (valor -> INTEGER .)
    OR              reduce using rule 13 (valor -> INTEGER .)


state 34

    (14) valor -> FLOAT .

    COMMA           reduce using rule 14 (valor -> FLOAT .)
    PLUS            reduce using rule 14 (valor -> FLOAT .)
    MINUS           reduce using rule 14 (valor -> FLOAT .)
    TIMES           reduce using rule 14 (valor -> FLOAT .)
    DIVIDE          reduce using rule 14 (valor -> FLOAT .)
    MOD             reduce using rule 14 (valor -> FLOAT .)
    INTD            reduce using rule 14 (valor -> FLOAT .)
    RCORCH          reduce using rule 14 (valor -> FLOAT .)
    EQ              reduce using rule 14 (valor -> FLOAT .)
    NEQ             reduce using rule 14 (valor -> FLOAT .)
    GEQ             reduce using rule 14 (valor -> FLOAT .)
    LEQ             reduce using rule 14 (valor -> FLOAT .)
    RIGHTARROW      reduce using rule 14 (valor -> FLOAT .)
    LEFTARROW       reduce using rule 14 (valor -> FLOAT .)
    RPAREN          reduce using rule 14 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 14 (valor -> FLOAT .)
    LLLAVE          reduce using rule 14 (valor -> FLOAT .)
    AND             reduce using rule 14 (valor -> FLOAT .)
    OR              reduce using rule 14 (valor -> FLOAT .)


state 35

    (15) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

    COMMA           reduce using rule 15 (valor -> IDENTIFIER .)
    PLUS            reduce using rule 15 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 15 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 15 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 15 (valor -> IDENTIFIER .)
    MOD             reduce using rule 15 (valor -> IDENTIFIER .)
    INTD            reduce using rule 15 (valor -> IDENTIFIER .)
    RCORCH          reduce using rule 15 (valor -> IDENTIFIER .)
    EQ              reduce using rule 15 (valor -> IDENTIFIER .)
    NEQ             reduce using rule 15 (valor -> IDENTIFIER .)
    GEQ             reduce using rule 15 (valor -> IDENTIFIER .)
    LEQ             reduce using rule 15 (valor -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 15 (valor -> IDENTIFIER .)
    LEFTARROW       reduce using rule 15 (valor -> IDENTIFIER .)
    RPAREN          reduce using rule 15 (valor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 15 (valor -> IDENTIFIER .)
    LLLAVE          reduce using rule 15 (valor -> IDENTIFIER .)
    AND             reduce using rule 15 (valor -> IDENTIFIER .)
    OR              reduce using rule 15 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 62


state 36

    (16) valor -> operacion .

    COMMA           reduce using rule 16 (valor -> operacion .)
    PLUS            reduce using rule 16 (valor -> operacion .)
    MINUS           reduce using rule 16 (valor -> operacion .)
    TIMES           reduce using rule 16 (valor -> operacion .)
    DIVIDE          reduce using rule 16 (valor -> operacion .)
    MOD             reduce using rule 16 (valor -> operacion .)
    INTD            reduce using rule 16 (valor -> operacion .)
    RCORCH          reduce using rule 16 (valor -> operacion .)
    EQ              reduce using rule 16 (valor -> operacion .)
    NEQ             reduce using rule 16 (valor -> operacion .)
    GEQ             reduce using rule 16 (valor -> operacion .)
    LEQ             reduce using rule 16 (valor -> operacion .)
    RIGHTARROW      reduce using rule 16 (valor -> operacion .)
    LEFTARROW       reduce using rule 16 (valor -> operacion .)
    RPAREN          reduce using rule 16 (valor -> operacion .)
    SEMICOLON       reduce using rule 16 (valor -> operacion .)
    LLLAVE          reduce using rule 16 (valor -> operacion .)
    AND             reduce using rule 16 (valor -> operacion .)
    OR              reduce using rule 16 (valor -> operacion .)


state 37

    (17) valor -> indexacion .

    COMMA           reduce using rule 17 (valor -> indexacion .)
    PLUS            reduce using rule 17 (valor -> indexacion .)
    MINUS           reduce using rule 17 (valor -> indexacion .)
    TIMES           reduce using rule 17 (valor -> indexacion .)
    DIVIDE          reduce using rule 17 (valor -> indexacion .)
    MOD             reduce using rule 17 (valor -> indexacion .)
    INTD            reduce using rule 17 (valor -> indexacion .)
    RCORCH          reduce using rule 17 (valor -> indexacion .)
    EQ              reduce using rule 17 (valor -> indexacion .)
    NEQ             reduce using rule 17 (valor -> indexacion .)
    GEQ             reduce using rule 17 (valor -> indexacion .)
    LEQ             reduce using rule 17 (valor -> indexacion .)
    RIGHTARROW      reduce using rule 17 (valor -> indexacion .)
    LEFTARROW       reduce using rule 17 (valor -> indexacion .)
    RPAREN          reduce using rule 17 (valor -> indexacion .)
    SEMICOLON       reduce using rule 17 (valor -> indexacion .)
    LLLAVE          reduce using rule 17 (valor -> indexacion .)
    AND             reduce using rule 17 (valor -> indexacion .)
    OR              reduce using rule 17 (valor -> indexacion .)


state 38

    (18) valor -> arreglos .

    COMMA           reduce using rule 18 (valor -> arreglos .)
    PLUS            reduce using rule 18 (valor -> arreglos .)
    MINUS           reduce using rule 18 (valor -> arreglos .)
    TIMES           reduce using rule 18 (valor -> arreglos .)
    DIVIDE          reduce using rule 18 (valor -> arreglos .)
    MOD             reduce using rule 18 (valor -> arreglos .)
    INTD            reduce using rule 18 (valor -> arreglos .)
    RCORCH          reduce using rule 18 (valor -> arreglos .)
    EQ              reduce using rule 18 (valor -> arreglos .)
    NEQ             reduce using rule 18 (valor -> arreglos .)
    GEQ             reduce using rule 18 (valor -> arreglos .)
    LEQ             reduce using rule 18 (valor -> arreglos .)
    RIGHTARROW      reduce using rule 18 (valor -> arreglos .)
    LEFTARROW       reduce using rule 18 (valor -> arreglos .)
    RPAREN          reduce using rule 18 (valor -> arreglos .)
    SEMICOLON       reduce using rule 18 (valor -> arreglos .)
    LLLAVE          reduce using rule 18 (valor -> arreglos .)
    AND             reduce using rule 18 (valor -> arreglos .)
    OR              reduce using rule 18 (valor -> arreglos .)


state 39

    (19) valor -> STRING .

    COMMA           reduce using rule 19 (valor -> STRING .)
    PLUS            reduce using rule 19 (valor -> STRING .)
    MINUS           reduce using rule 19 (valor -> STRING .)
    TIMES           reduce using rule 19 (valor -> STRING .)
    DIVIDE          reduce using rule 19 (valor -> STRING .)
    MOD             reduce using rule 19 (valor -> STRING .)
    INTD            reduce using rule 19 (valor -> STRING .)
    RCORCH          reduce using rule 19 (valor -> STRING .)
    EQ              reduce using rule 19 (valor -> STRING .)
    NEQ             reduce using rule 19 (valor -> STRING .)
    GEQ             reduce using rule 19 (valor -> STRING .)
    LEQ             reduce using rule 19 (valor -> STRING .)
    RIGHTARROW      reduce using rule 19 (valor -> STRING .)
    LEFTARROW       reduce using rule 19 (valor -> STRING .)
    RPAREN          reduce using rule 19 (valor -> STRING .)
    SEMICOLON       reduce using rule 19 (valor -> STRING .)
    LLLAVE          reduce using rule 19 (valor -> STRING .)
    AND             reduce using rule 19 (valor -> STRING .)
    OR              reduce using rule 19 (valor -> STRING .)


state 40

    (20) valor -> booleanos .

    COMMA           reduce using rule 20 (valor -> booleanos .)
    PLUS            reduce using rule 20 (valor -> booleanos .)
    MINUS           reduce using rule 20 (valor -> booleanos .)
    TIMES           reduce using rule 20 (valor -> booleanos .)
    DIVIDE          reduce using rule 20 (valor -> booleanos .)
    MOD             reduce using rule 20 (valor -> booleanos .)
    INTD            reduce using rule 20 (valor -> booleanos .)
    RCORCH          reduce using rule 20 (valor -> booleanos .)
    EQ              reduce using rule 20 (valor -> booleanos .)
    NEQ             reduce using rule 20 (valor -> booleanos .)
    GEQ             reduce using rule 20 (valor -> booleanos .)
    LEQ             reduce using rule 20 (valor -> booleanos .)
    RIGHTARROW      reduce using rule 20 (valor -> booleanos .)
    LEFTARROW       reduce using rule 20 (valor -> booleanos .)
    RPAREN          reduce using rule 20 (valor -> booleanos .)
    SEMICOLON       reduce using rule 20 (valor -> booleanos .)
    LLLAVE          reduce using rule 20 (valor -> booleanos .)
    AND             reduce using rule 20 (valor -> booleanos .)
    OR              reduce using rule 20 (valor -> booleanos .)


state 41

    (21) booleanos -> TRUE .

    COMMA           reduce using rule 21 (booleanos -> TRUE .)
    PLUS            reduce using rule 21 (booleanos -> TRUE .)
    MINUS           reduce using rule 21 (booleanos -> TRUE .)
    TIMES           reduce using rule 21 (booleanos -> TRUE .)
    DIVIDE          reduce using rule 21 (booleanos -> TRUE .)
    MOD             reduce using rule 21 (booleanos -> TRUE .)
    INTD            reduce using rule 21 (booleanos -> TRUE .)
    RCORCH          reduce using rule 21 (booleanos -> TRUE .)
    EQ              reduce using rule 21 (booleanos -> TRUE .)
    NEQ             reduce using rule 21 (booleanos -> TRUE .)
    GEQ             reduce using rule 21 (booleanos -> TRUE .)
    LEQ             reduce using rule 21 (booleanos -> TRUE .)
    RIGHTARROW      reduce using rule 21 (booleanos -> TRUE .)
    LEFTARROW       reduce using rule 21 (booleanos -> TRUE .)
    RPAREN          reduce using rule 21 (booleanos -> TRUE .)
    SEMICOLON       reduce using rule 21 (booleanos -> TRUE .)
    LLLAVE          reduce using rule 21 (booleanos -> TRUE .)
    AND             reduce using rule 21 (booleanos -> TRUE .)
    OR              reduce using rule 21 (booleanos -> TRUE .)


state 42

    (22) booleanos -> FALSE .

    COMMA           reduce using rule 22 (booleanos -> FALSE .)
    PLUS            reduce using rule 22 (booleanos -> FALSE .)
    MINUS           reduce using rule 22 (booleanos -> FALSE .)
    TIMES           reduce using rule 22 (booleanos -> FALSE .)
    DIVIDE          reduce using rule 22 (booleanos -> FALSE .)
    MOD             reduce using rule 22 (booleanos -> FALSE .)
    INTD            reduce using rule 22 (booleanos -> FALSE .)
    RCORCH          reduce using rule 22 (booleanos -> FALSE .)
    EQ              reduce using rule 22 (booleanos -> FALSE .)
    NEQ             reduce using rule 22 (booleanos -> FALSE .)
    GEQ             reduce using rule 22 (booleanos -> FALSE .)
    LEQ             reduce using rule 22 (booleanos -> FALSE .)
    RIGHTARROW      reduce using rule 22 (booleanos -> FALSE .)
    LEFTARROW       reduce using rule 22 (booleanos -> FALSE .)
    RPAREN          reduce using rule 22 (booleanos -> FALSE .)
    SEMICOLON       reduce using rule 22 (booleanos -> FALSE .)
    LLLAVE          reduce using rule 22 (booleanos -> FALSE .)
    AND             reduce using rule 22 (booleanos -> FALSE .)
    OR              reduce using rule 22 (booleanos -> FALSE .)


state 43

    (76) condicional -> IF comparacion . LLLAVE programa RLLAVE
    (74) proposicion -> comparacion . conector proposicion
    (75) proposicion -> comparacion .
    (72) conector -> . AND
    (73) conector -> . OR

  ! shift/reduce conflict for LLLAVE resolved as shift
    LLLAVE          shift and go to state 63
    AND             shift and go to state 65
    OR              shift and go to state 66

  ! LLLAVE          [ reduce using rule 75 (proposicion -> comparacion .) ]

    conector                       shift and go to state 64

state 44

    (77) condicional -> IF proposicion . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 67


state 45

    (7) comparacion -> valor . EQ valor
    (8) comparacion -> valor . NEQ valor
    (9) comparacion -> valor . GEQ valor
    (10) comparacion -> valor . LEQ valor
    (11) comparacion -> valor . RIGHTARROW valor
    (12) comparacion -> valor . LEFTARROW valor
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    EQ              shift and go to state 68
    NEQ             shift and go to state 69
    GEQ             shift and go to state 70
    LEQ             shift and go to state 71
    RIGHTARROW      shift and go to state 72
    LEFTARROW       shift and go to state 73
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 46

    (3) asignacion -> LET IDENTIFIER ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 74
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 47

    (5) asignacion -> LET IDENTIFIER COLON . asig_data_type ASIG valor
    (44) asig_data_type -> . data_type
    (45) asig_data_type -> . LPAREN some_data_type RPAREN
    (46) asig_data_type -> . LCORCH some_data_type RCORCH
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    LPAREN          shift and go to state 77
    LCORCH          shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    asig_data_type                 shift and go to state 75
    data_type                      shift and go to state 76
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 48

    (4) asignacion -> LET MUT IDENTIFIER . ASIG valor
    (6) asignacion -> LET MUT IDENTIFIER . COLON asig_data_type ASIG valor

    ASIG            shift and go to state 98
    COLON           shift and go to state 99


state 49

    (85) llamada -> IDENTIFIER LPAREN valores . RPAREN

    RPAREN          shift and go to state 100


state 50

    (31) impresion -> PRINTLN EXCLAMATION LPAREN . valor RPAREN
    (32) impresion -> PRINTLN EXCLAMATION LPAREN . valor COMMA valores RPAREN
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 101
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 51

    (33) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN LLLAVE programa RLLAVE
    (36) funcion -> FN IDENTIFIER LPAREN . RPAREN LLLAVE programa RLLAVE
    (37) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> FN IDENTIFIER LPAREN . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (40) parameters -> . IDENTIFIER COLON asig_data_type
    (41) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (42) parameters -> . vacio
    (23) vacio -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 104
    IDENTIFIER      shift and go to state 102

  ! RPAREN          [ reduce using rule 23 (vacio -> .) ]

    parameters                     shift and go to state 103
    vacio                          shift and go to state 105

state 52

    (34) funcion -> FN MAIN LPAREN . parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> FN MAIN LPAREN . RPAREN LLLAVE programa RLLAVE
    (40) parameters -> . IDENTIFIER COLON asig_data_type
    (41) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (42) parameters -> . vacio
    (23) vacio -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 102

  ! RPAREN          [ reduce using rule 23 (vacio -> .) ]

    parameters                     shift and go to state 106
    vacio                          shift and go to state 105

state 53

    (43) ingreso_datos -> STD DOUBLE_COLON IO . DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 108


state 54

    (69) arreglos -> LCORCH valores RCORCH .

    SEMICOLON       reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    COMMA           reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    PLUS            reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    MINUS           reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    TIMES           reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    DIVIDE          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    MOD             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    INTD            reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    RCORCH          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    EQ              reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    NEQ             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    GEQ             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    LEQ             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    RIGHTARROW      reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    LEFTARROW       reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    RPAREN          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    LLLAVE          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    AND             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    OR              reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)


state 55

    (71) valores -> valor COMMA . valores
    (70) valores -> . valor
    (71) valores -> . valor COMMA valores
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 32
    valores                        shift and go to state 109
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 56

    (78) operacion -> valor PLUS . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 110
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 57

    (79) operacion -> valor MINUS . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 111
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 58

    (80) operacion -> valor TIMES . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 112
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 59

    (81) operacion -> valor DIVIDE . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 113
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 60

    (82) operacion -> valor MOD . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 114
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 61

    (83) operacion -> valor INTD . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 115
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 62

    (84) indexacion -> IDENTIFIER LCORCH . INTEGER RCORCH

    INTEGER         shift and go to state 116


state 63

    (76) condicional -> IF comparacion LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 117
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 64

    (74) proposicion -> comparacion conector . proposicion
    (74) proposicion -> . comparacion conector proposicion
    (75) proposicion -> . comparacion
    (7) comparacion -> . valor EQ valor
    (8) comparacion -> . valor NEQ valor
    (9) comparacion -> . valor GEQ valor
    (10) comparacion -> . valor LEQ valor
    (11) comparacion -> . valor RIGHTARROW valor
    (12) comparacion -> . valor LEFTARROW valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    comparacion                    shift and go to state 118
    proposicion                    shift and go to state 119
    valor                          shift and go to state 45
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 65

    (72) conector -> AND .

    INTEGER         reduce using rule 72 (conector -> AND .)
    FLOAT           reduce using rule 72 (conector -> AND .)
    IDENTIFIER      reduce using rule 72 (conector -> AND .)
    STRING          reduce using rule 72 (conector -> AND .)
    LCORCH          reduce using rule 72 (conector -> AND .)
    TRUE            reduce using rule 72 (conector -> AND .)
    FALSE           reduce using rule 72 (conector -> AND .)


state 66

    (73) conector -> OR .

    INTEGER         reduce using rule 73 (conector -> OR .)
    FLOAT           reduce using rule 73 (conector -> OR .)
    IDENTIFIER      reduce using rule 73 (conector -> OR .)
    STRING          reduce using rule 73 (conector -> OR .)
    LCORCH          reduce using rule 73 (conector -> OR .)
    TRUE            reduce using rule 73 (conector -> OR .)
    FALSE           reduce using rule 73 (conector -> OR .)


state 67

    (77) condicional -> IF proposicion LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 120
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 68

    (7) comparacion -> valor EQ . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 121
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 69

    (8) comparacion -> valor NEQ . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 122
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 70

    (9) comparacion -> valor GEQ . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 123
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 71

    (10) comparacion -> valor LEQ . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 124
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 72

    (11) comparacion -> valor RIGHTARROW . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 125
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 73

    (12) comparacion -> valor LEFTARROW . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 126
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 74

    (3) asignacion -> LET IDENTIFIER ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 3 (asignacion -> LET IDENTIFIER ASIG valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 75

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type . ASIG valor

    ASIG            shift and go to state 127


state 76

    (44) asig_data_type -> data_type .

    ASIG            reduce using rule 44 (asig_data_type -> data_type .)
    COMMA           reduce using rule 44 (asig_data_type -> data_type .)
    RPAREN          reduce using rule 44 (asig_data_type -> data_type .)


state 77

    (45) asig_data_type -> LPAREN . some_data_type RPAREN
    (66) some_data_type -> . data_type
    (67) some_data_type -> . data_type COMMA some_data_type
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    some_data_type                 shift and go to state 128
    data_type                      shift and go to state 129
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 78

    (46) asig_data_type -> LCORCH . some_data_type RCORCH
    (66) some_data_type -> . data_type
    (67) some_data_type -> . data_type COMMA some_data_type
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    some_data_type                 shift and go to state 130
    data_type                      shift and go to state 129
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 79

    (47) data_type -> CHAR .

    ASIG            reduce using rule 47 (data_type -> CHAR .)
    COMMA           reduce using rule 47 (data_type -> CHAR .)
    RPAREN          reduce using rule 47 (data_type -> CHAR .)
    RCORCH          reduce using rule 47 (data_type -> CHAR .)
    LLLAVE          reduce using rule 47 (data_type -> CHAR .)


state 80

    (48) data_type -> signed_integer .

    ASIG            reduce using rule 48 (data_type -> signed_integer .)
    COMMA           reduce using rule 48 (data_type -> signed_integer .)
    RPAREN          reduce using rule 48 (data_type -> signed_integer .)
    RCORCH          reduce using rule 48 (data_type -> signed_integer .)
    LLLAVE          reduce using rule 48 (data_type -> signed_integer .)


state 81

    (49) data_type -> unsigned_integer .

    ASIG            reduce using rule 49 (data_type -> unsigned_integer .)
    COMMA           reduce using rule 49 (data_type -> unsigned_integer .)
    RPAREN          reduce using rule 49 (data_type -> unsigned_integer .)
    RCORCH          reduce using rule 49 (data_type -> unsigned_integer .)
    LLLAVE          reduce using rule 49 (data_type -> unsigned_integer .)


state 82

    (50) data_type -> float_type .

    ASIG            reduce using rule 50 (data_type -> float_type .)
    COMMA           reduce using rule 50 (data_type -> float_type .)
    RPAREN          reduce using rule 50 (data_type -> float_type .)
    RCORCH          reduce using rule 50 (data_type -> float_type .)
    LLLAVE          reduce using rule 50 (data_type -> float_type .)


state 83

    (51) data_type -> BOOL .

    ASIG            reduce using rule 51 (data_type -> BOOL .)
    COMMA           reduce using rule 51 (data_type -> BOOL .)
    RPAREN          reduce using rule 51 (data_type -> BOOL .)
    RCORCH          reduce using rule 51 (data_type -> BOOL .)
    LLLAVE          reduce using rule 51 (data_type -> BOOL .)


state 84

    (52) signed_integer -> I8 .

    ASIG            reduce using rule 52 (signed_integer -> I8 .)
    COMMA           reduce using rule 52 (signed_integer -> I8 .)
    RPAREN          reduce using rule 52 (signed_integer -> I8 .)
    RCORCH          reduce using rule 52 (signed_integer -> I8 .)
    LLLAVE          reduce using rule 52 (signed_integer -> I8 .)


state 85

    (53) signed_integer -> I16 .

    ASIG            reduce using rule 53 (signed_integer -> I16 .)
    COMMA           reduce using rule 53 (signed_integer -> I16 .)
    RPAREN          reduce using rule 53 (signed_integer -> I16 .)
    RCORCH          reduce using rule 53 (signed_integer -> I16 .)
    LLLAVE          reduce using rule 53 (signed_integer -> I16 .)


state 86

    (54) signed_integer -> I32 .

    ASIG            reduce using rule 54 (signed_integer -> I32 .)
    COMMA           reduce using rule 54 (signed_integer -> I32 .)
    RPAREN          reduce using rule 54 (signed_integer -> I32 .)
    RCORCH          reduce using rule 54 (signed_integer -> I32 .)
    LLLAVE          reduce using rule 54 (signed_integer -> I32 .)


state 87

    (55) signed_integer -> I64 .

    ASIG            reduce using rule 55 (signed_integer -> I64 .)
    COMMA           reduce using rule 55 (signed_integer -> I64 .)
    RPAREN          reduce using rule 55 (signed_integer -> I64 .)
    RCORCH          reduce using rule 55 (signed_integer -> I64 .)
    LLLAVE          reduce using rule 55 (signed_integer -> I64 .)


state 88

    (56) signed_integer -> I128 .

    ASIG            reduce using rule 56 (signed_integer -> I128 .)
    COMMA           reduce using rule 56 (signed_integer -> I128 .)
    RPAREN          reduce using rule 56 (signed_integer -> I128 .)
    RCORCH          reduce using rule 56 (signed_integer -> I128 .)
    LLLAVE          reduce using rule 56 (signed_integer -> I128 .)


state 89

    (57) signed_integer -> ISIZE .

    ASIG            reduce using rule 57 (signed_integer -> ISIZE .)
    COMMA           reduce using rule 57 (signed_integer -> ISIZE .)
    RPAREN          reduce using rule 57 (signed_integer -> ISIZE .)
    RCORCH          reduce using rule 57 (signed_integer -> ISIZE .)
    LLLAVE          reduce using rule 57 (signed_integer -> ISIZE .)


state 90

    (58) unsigned_integer -> U8 .

    ASIG            reduce using rule 58 (unsigned_integer -> U8 .)
    COMMA           reduce using rule 58 (unsigned_integer -> U8 .)
    RPAREN          reduce using rule 58 (unsigned_integer -> U8 .)
    RCORCH          reduce using rule 58 (unsigned_integer -> U8 .)
    LLLAVE          reduce using rule 58 (unsigned_integer -> U8 .)


state 91

    (59) unsigned_integer -> U16 .

    ASIG            reduce using rule 59 (unsigned_integer -> U16 .)
    COMMA           reduce using rule 59 (unsigned_integer -> U16 .)
    RPAREN          reduce using rule 59 (unsigned_integer -> U16 .)
    RCORCH          reduce using rule 59 (unsigned_integer -> U16 .)
    LLLAVE          reduce using rule 59 (unsigned_integer -> U16 .)


state 92

    (60) unsigned_integer -> U32 .

    ASIG            reduce using rule 60 (unsigned_integer -> U32 .)
    COMMA           reduce using rule 60 (unsigned_integer -> U32 .)
    RPAREN          reduce using rule 60 (unsigned_integer -> U32 .)
    RCORCH          reduce using rule 60 (unsigned_integer -> U32 .)
    LLLAVE          reduce using rule 60 (unsigned_integer -> U32 .)


state 93

    (61) unsigned_integer -> U64 .

    ASIG            reduce using rule 61 (unsigned_integer -> U64 .)
    COMMA           reduce using rule 61 (unsigned_integer -> U64 .)
    RPAREN          reduce using rule 61 (unsigned_integer -> U64 .)
    RCORCH          reduce using rule 61 (unsigned_integer -> U64 .)
    LLLAVE          reduce using rule 61 (unsigned_integer -> U64 .)


state 94

    (62) unsigned_integer -> U128 .

    ASIG            reduce using rule 62 (unsigned_integer -> U128 .)
    COMMA           reduce using rule 62 (unsigned_integer -> U128 .)
    RPAREN          reduce using rule 62 (unsigned_integer -> U128 .)
    RCORCH          reduce using rule 62 (unsigned_integer -> U128 .)
    LLLAVE          reduce using rule 62 (unsigned_integer -> U128 .)


state 95

    (63) unsigned_integer -> USIZE .

    ASIG            reduce using rule 63 (unsigned_integer -> USIZE .)
    COMMA           reduce using rule 63 (unsigned_integer -> USIZE .)
    RPAREN          reduce using rule 63 (unsigned_integer -> USIZE .)
    RCORCH          reduce using rule 63 (unsigned_integer -> USIZE .)
    LLLAVE          reduce using rule 63 (unsigned_integer -> USIZE .)


state 96

    (64) float_type -> F32 .

    ASIG            reduce using rule 64 (float_type -> F32 .)
    COMMA           reduce using rule 64 (float_type -> F32 .)
    RPAREN          reduce using rule 64 (float_type -> F32 .)
    RCORCH          reduce using rule 64 (float_type -> F32 .)
    LLLAVE          reduce using rule 64 (float_type -> F32 .)


state 97

    (65) float_type -> F64 .

    ASIG            reduce using rule 65 (float_type -> F64 .)
    COMMA           reduce using rule 65 (float_type -> F64 .)
    RPAREN          reduce using rule 65 (float_type -> F64 .)
    RCORCH          reduce using rule 65 (float_type -> F64 .)
    LLLAVE          reduce using rule 65 (float_type -> F64 .)


state 98

    (4) asignacion -> LET MUT IDENTIFIER ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 131
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 99

    (6) asignacion -> LET MUT IDENTIFIER COLON . asig_data_type ASIG valor
    (44) asig_data_type -> . data_type
    (45) asig_data_type -> . LPAREN some_data_type RPAREN
    (46) asig_data_type -> . LCORCH some_data_type RCORCH
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    LPAREN          shift and go to state 77
    LCORCH          shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    asig_data_type                 shift and go to state 132
    data_type                      shift and go to state 76
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 100

    (85) llamada -> IDENTIFIER LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 85 (llamada -> IDENTIFIER LPAREN valores RPAREN .)


state 101

    (31) impresion -> PRINTLN EXCLAMATION LPAREN valor . RPAREN
    (32) impresion -> PRINTLN EXCLAMATION LPAREN valor . COMMA valores RPAREN
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    RPAREN          shift and go to state 133
    COMMA           shift and go to state 134
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 102

    (40) parameters -> IDENTIFIER . COLON asig_data_type
    (41) parameters -> IDENTIFIER . COLON asig_data_type COMMA parameters

    COLON           shift and go to state 135


state 103

    (33) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN LLLAVE programa RLLAVE
    (37) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RPAREN          shift and go to state 136


state 104

    (36) funcion -> FN IDENTIFIER LPAREN RPAREN . LLLAVE programa RLLAVE
    (38) funcion -> FN IDENTIFIER LPAREN RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 137
    MINUS           shift and go to state 138


state 105

    (42) parameters -> vacio .

    RPAREN          reduce using rule 42 (parameters -> vacio .)


state 106

    (34) funcion -> FN MAIN LPAREN parameters . RPAREN LLLAVE programa RLLAVE

    RPAREN          shift and go to state 139


state 107

    (35) funcion -> FN MAIN LPAREN RPAREN . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 140


state 108

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON . DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 141


state 109

    (71) valores -> valor COMMA valores .

    RCORCH          reduce using rule 71 (valores -> valor COMMA valores .)
    RPAREN          reduce using rule 71 (valores -> valor COMMA valores .)


state 110

    (78) operacion -> valor PLUS valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 78 (operacion -> valor PLUS valor .)
    RCORCH          reduce using rule 78 (operacion -> valor PLUS valor .)
    EQ              reduce using rule 78 (operacion -> valor PLUS valor .)
    NEQ             reduce using rule 78 (operacion -> valor PLUS valor .)
    GEQ             reduce using rule 78 (operacion -> valor PLUS valor .)
    LEQ             reduce using rule 78 (operacion -> valor PLUS valor .)
    RIGHTARROW      reduce using rule 78 (operacion -> valor PLUS valor .)
    LEFTARROW       reduce using rule 78 (operacion -> valor PLUS valor .)
    RPAREN          reduce using rule 78 (operacion -> valor PLUS valor .)
    SEMICOLON       reduce using rule 78 (operacion -> valor PLUS valor .)
    LLLAVE          reduce using rule 78 (operacion -> valor PLUS valor .)
    AND             reduce using rule 78 (operacion -> valor PLUS valor .)
    OR              reduce using rule 78 (operacion -> valor PLUS valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61

  ! PLUS            [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! MINUS           [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! TIMES           [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! DIVIDE          [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! MOD             [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! INTD            [ reduce using rule 78 (operacion -> valor PLUS valor .) ]


state 111

    (79) operacion -> valor MINUS valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 79 (operacion -> valor MINUS valor .)
    RCORCH          reduce using rule 79 (operacion -> valor MINUS valor .)
    EQ              reduce using rule 79 (operacion -> valor MINUS valor .)
    NEQ             reduce using rule 79 (operacion -> valor MINUS valor .)
    GEQ             reduce using rule 79 (operacion -> valor MINUS valor .)
    LEQ             reduce using rule 79 (operacion -> valor MINUS valor .)
    RIGHTARROW      reduce using rule 79 (operacion -> valor MINUS valor .)
    LEFTARROW       reduce using rule 79 (operacion -> valor MINUS valor .)
    RPAREN          reduce using rule 79 (operacion -> valor MINUS valor .)
    SEMICOLON       reduce using rule 79 (operacion -> valor MINUS valor .)
    LLLAVE          reduce using rule 79 (operacion -> valor MINUS valor .)
    AND             reduce using rule 79 (operacion -> valor MINUS valor .)
    OR              reduce using rule 79 (operacion -> valor MINUS valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61

  ! PLUS            [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! MINUS           [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! TIMES           [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! DIVIDE          [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! MOD             [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! INTD            [ reduce using rule 79 (operacion -> valor MINUS valor .) ]


state 112

    (80) operacion -> valor TIMES valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 80 (operacion -> valor TIMES valor .)
    RCORCH          reduce using rule 80 (operacion -> valor TIMES valor .)
    EQ              reduce using rule 80 (operacion -> valor TIMES valor .)
    NEQ             reduce using rule 80 (operacion -> valor TIMES valor .)
    GEQ             reduce using rule 80 (operacion -> valor TIMES valor .)
    LEQ             reduce using rule 80 (operacion -> valor TIMES valor .)
    RIGHTARROW      reduce using rule 80 (operacion -> valor TIMES valor .)
    LEFTARROW       reduce using rule 80 (operacion -> valor TIMES valor .)
    RPAREN          reduce using rule 80 (operacion -> valor TIMES valor .)
    SEMICOLON       reduce using rule 80 (operacion -> valor TIMES valor .)
    LLLAVE          reduce using rule 80 (operacion -> valor TIMES valor .)
    AND             reduce using rule 80 (operacion -> valor TIMES valor .)
    OR              reduce using rule 80 (operacion -> valor TIMES valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61

  ! PLUS            [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! MINUS           [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! TIMES           [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! DIVIDE          [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! MOD             [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! INTD            [ reduce using rule 80 (operacion -> valor TIMES valor .) ]


state 113

    (81) operacion -> valor DIVIDE valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 81 (operacion -> valor DIVIDE valor .)
    RCORCH          reduce using rule 81 (operacion -> valor DIVIDE valor .)
    EQ              reduce using rule 81 (operacion -> valor DIVIDE valor .)
    NEQ             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    GEQ             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    LEQ             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    RIGHTARROW      reduce using rule 81 (operacion -> valor DIVIDE valor .)
    LEFTARROW       reduce using rule 81 (operacion -> valor DIVIDE valor .)
    RPAREN          reduce using rule 81 (operacion -> valor DIVIDE valor .)
    SEMICOLON       reduce using rule 81 (operacion -> valor DIVIDE valor .)
    LLLAVE          reduce using rule 81 (operacion -> valor DIVIDE valor .)
    AND             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    OR              reduce using rule 81 (operacion -> valor DIVIDE valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61

  ! PLUS            [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! MINUS           [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! TIMES           [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! DIVIDE          [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! MOD             [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! INTD            [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]


state 114

    (82) operacion -> valor MOD valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 82 (operacion -> valor MOD valor .)
    RCORCH          reduce using rule 82 (operacion -> valor MOD valor .)
    EQ              reduce using rule 82 (operacion -> valor MOD valor .)
    NEQ             reduce using rule 82 (operacion -> valor MOD valor .)
    GEQ             reduce using rule 82 (operacion -> valor MOD valor .)
    LEQ             reduce using rule 82 (operacion -> valor MOD valor .)
    RIGHTARROW      reduce using rule 82 (operacion -> valor MOD valor .)
    LEFTARROW       reduce using rule 82 (operacion -> valor MOD valor .)
    RPAREN          reduce using rule 82 (operacion -> valor MOD valor .)
    SEMICOLON       reduce using rule 82 (operacion -> valor MOD valor .)
    LLLAVE          reduce using rule 82 (operacion -> valor MOD valor .)
    AND             reduce using rule 82 (operacion -> valor MOD valor .)
    OR              reduce using rule 82 (operacion -> valor MOD valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61

  ! PLUS            [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! MINUS           [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! TIMES           [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! DIVIDE          [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! MOD             [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! INTD            [ reduce using rule 82 (operacion -> valor MOD valor .) ]


state 115

    (83) operacion -> valor INTD valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 83 (operacion -> valor INTD valor .)
    RCORCH          reduce using rule 83 (operacion -> valor INTD valor .)
    EQ              reduce using rule 83 (operacion -> valor INTD valor .)
    NEQ             reduce using rule 83 (operacion -> valor INTD valor .)
    GEQ             reduce using rule 83 (operacion -> valor INTD valor .)
    LEQ             reduce using rule 83 (operacion -> valor INTD valor .)
    RIGHTARROW      reduce using rule 83 (operacion -> valor INTD valor .)
    LEFTARROW       reduce using rule 83 (operacion -> valor INTD valor .)
    RPAREN          reduce using rule 83 (operacion -> valor INTD valor .)
    SEMICOLON       reduce using rule 83 (operacion -> valor INTD valor .)
    LLLAVE          reduce using rule 83 (operacion -> valor INTD valor .)
    AND             reduce using rule 83 (operacion -> valor INTD valor .)
    OR              reduce using rule 83 (operacion -> valor INTD valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61

  ! PLUS            [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! MINUS           [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! TIMES           [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! DIVIDE          [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! MOD             [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! INTD            [ reduce using rule 83 (operacion -> valor INTD valor .) ]


state 116

    (84) indexacion -> IDENTIFIER LCORCH INTEGER . RCORCH

    RCORCH          shift and go to state 142


state 117

    (76) condicional -> IF comparacion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 143


state 118

    (74) proposicion -> comparacion . conector proposicion
    (75) proposicion -> comparacion .
    (72) conector -> . AND
    (73) conector -> . OR

    LLLAVE          reduce using rule 75 (proposicion -> comparacion .)
    AND             shift and go to state 65
    OR              shift and go to state 66

    conector                       shift and go to state 64

state 119

    (74) proposicion -> comparacion conector proposicion .

    LLLAVE          reduce using rule 74 (proposicion -> comparacion conector proposicion .)


state 120

    (77) condicional -> IF proposicion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 144


state 121

    (7) comparacion -> valor EQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 7 (comparacion -> valor EQ valor .)
    AND             reduce using rule 7 (comparacion -> valor EQ valor .)
    OR              reduce using rule 7 (comparacion -> valor EQ valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 122

    (8) comparacion -> valor NEQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 8 (comparacion -> valor NEQ valor .)
    AND             reduce using rule 8 (comparacion -> valor NEQ valor .)
    OR              reduce using rule 8 (comparacion -> valor NEQ valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 123

    (9) comparacion -> valor GEQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 9 (comparacion -> valor GEQ valor .)
    AND             reduce using rule 9 (comparacion -> valor GEQ valor .)
    OR              reduce using rule 9 (comparacion -> valor GEQ valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 124

    (10) comparacion -> valor LEQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 10 (comparacion -> valor LEQ valor .)
    AND             reduce using rule 10 (comparacion -> valor LEQ valor .)
    OR              reduce using rule 10 (comparacion -> valor LEQ valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 125

    (11) comparacion -> valor RIGHTARROW valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 11 (comparacion -> valor RIGHTARROW valor .)
    AND             reduce using rule 11 (comparacion -> valor RIGHTARROW valor .)
    OR              reduce using rule 11 (comparacion -> valor RIGHTARROW valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 126

    (12) comparacion -> valor LEFTARROW valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 12 (comparacion -> valor LEFTARROW valor .)
    AND             reduce using rule 12 (comparacion -> valor LEFTARROW valor .)
    OR              reduce using rule 12 (comparacion -> valor LEFTARROW valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 127

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 145
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 128

    (45) asig_data_type -> LPAREN some_data_type . RPAREN

    RPAREN          shift and go to state 146


state 129

    (66) some_data_type -> data_type .
    (67) some_data_type -> data_type . COMMA some_data_type

    RPAREN          reduce using rule 66 (some_data_type -> data_type .)
    RCORCH          reduce using rule 66 (some_data_type -> data_type .)
    COMMA           shift and go to state 147


state 130

    (46) asig_data_type -> LCORCH some_data_type . RCORCH

    RCORCH          shift and go to state 148


state 131

    (4) asignacion -> LET MUT IDENTIFIER ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 4 (asignacion -> LET MUT IDENTIFIER ASIG valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 132

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type . ASIG valor

    ASIG            shift and go to state 149


state 133

    (31) impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 31 (impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .)


state 134

    (32) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA . valores RPAREN
    (70) valores -> . valor
    (71) valores -> . valor COMMA valores
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 32
    valores                        shift and go to state 150
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 135

    (40) parameters -> IDENTIFIER COLON . asig_data_type
    (41) parameters -> IDENTIFIER COLON . asig_data_type COMMA parameters
    (44) asig_data_type -> . data_type
    (45) asig_data_type -> . LPAREN some_data_type RPAREN
    (46) asig_data_type -> . LCORCH some_data_type RCORCH
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    LPAREN          shift and go to state 77
    LCORCH          shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    asig_data_type                 shift and go to state 151
    data_type                      shift and go to state 76
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 136

    (33) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . LLLAVE programa RLLAVE
    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 152
    MINUS           shift and go to state 153


state 137

    (36) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 154
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 138

    (38) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 155


state 139

    (34) funcion -> FN MAIN LPAREN parameters RPAREN . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 156


state 140

    (35) funcion -> FN MAIN LPAREN RPAREN LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 157
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 141

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT . STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    STDIN           shift and go to state 158


state 142

    (84) indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .

    COMMA           reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    PLUS            reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    MINUS           reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    TIMES           reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    DIVIDE          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    MOD             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    INTD            reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RCORCH          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    EQ              reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    NEQ             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    GEQ             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEQ             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RIGHTARROW      reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEFTARROW       reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RPAREN          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    SEMICOLON       reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LLLAVE          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    AND             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    OR              reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)


state 143

    (76) condicional -> IF comparacion LLLAVE programa RLLAVE .

    LET             reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    FN              reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    STD             reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IF              reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    $end            reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)


state 144

    (77) condicional -> IF proposicion LLLAVE programa RLLAVE .

    LET             reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    FN              reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    STD             reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IF              reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    $end            reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)


state 145

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 5 (asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 146

    (45) asig_data_type -> LPAREN some_data_type RPAREN .

    ASIG            reduce using rule 45 (asig_data_type -> LPAREN some_data_type RPAREN .)
    COMMA           reduce using rule 45 (asig_data_type -> LPAREN some_data_type RPAREN .)
    RPAREN          reduce using rule 45 (asig_data_type -> LPAREN some_data_type RPAREN .)


state 147

    (67) some_data_type -> data_type COMMA . some_data_type
    (66) some_data_type -> . data_type
    (67) some_data_type -> . data_type COMMA some_data_type
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    data_type                      shift and go to state 129
    some_data_type                 shift and go to state 159
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 148

    (46) asig_data_type -> LCORCH some_data_type RCORCH .

    ASIG            reduce using rule 46 (asig_data_type -> LCORCH some_data_type RCORCH .)
    COMMA           reduce using rule 46 (asig_data_type -> LCORCH some_data_type RCORCH .)
    RPAREN          reduce using rule 46 (asig_data_type -> LCORCH some_data_type RCORCH .)


state 149

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 160
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 150

    (32) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores . RPAREN

    RPAREN          shift and go to state 161


state 151

    (40) parameters -> IDENTIFIER COLON asig_data_type .
    (41) parameters -> IDENTIFIER COLON asig_data_type . COMMA parameters

    RPAREN          reduce using rule 40 (parameters -> IDENTIFIER COLON asig_data_type .)
    COMMA           shift and go to state 162


state 152

    (33) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 163
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 153

    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 164


state 154

    (36) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 165


state 155

    (38) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    data_type                      shift and go to state 166
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 156

    (34) funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 167
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 157

    (35) funcion -> FN MAIN LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 168


state 158

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN . LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 169


state 159

    (67) some_data_type -> data_type COMMA some_data_type .

    RPAREN          reduce using rule 67 (some_data_type -> data_type COMMA some_data_type .)
    RCORCH          reduce using rule 67 (some_data_type -> data_type COMMA some_data_type .)


state 160

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 6 (asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 161

    (32) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .

    SEMICOLON       reduce using rule 32 (impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .)


state 162

    (41) parameters -> IDENTIFIER COLON asig_data_type COMMA . parameters
    (40) parameters -> . IDENTIFIER COLON asig_data_type
    (41) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (42) parameters -> . vacio
    (23) vacio -> .

    IDENTIFIER      shift and go to state 102
    RPAREN          reduce using rule 23 (vacio -> .)

    parameters                     shift and go to state 170
    vacio                          shift and go to state 105

state 163

    (33) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 171


state 164

    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 79
    BOOL            shift and go to state 83
    I8              shift and go to state 84
    I16             shift and go to state 85
    I32             shift and go to state 86
    I64             shift and go to state 87
    I128            shift and go to state 88
    ISIZE           shift and go to state 89
    U8              shift and go to state 90
    U16             shift and go to state 91
    U32             shift and go to state 92
    U64             shift and go to state 93
    U128            shift and go to state 94
    USIZE           shift and go to state 95
    F32             shift and go to state 96
    F64             shift and go to state 97

    data_type                      shift and go to state 172
    signed_integer                 shift and go to state 80
    unsigned_integer               shift and go to state 81
    float_type                     shift and go to state 82

state 165

    (36) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .

    LET             reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    FN              reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    STD             reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    IF              reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 36 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)


state 166

    (38) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 173


state 167

    (34) funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 174


state 168

    (35) funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .

    LET             reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    FN              reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    STD             reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    IF              reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 35 (funcion -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)


state 169

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN . RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    RPAREN          shift and go to state 175


state 170

    (41) parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .

    RPAREN          reduce using rule 41 (parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .)


state 171

    (33) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .

    LET             reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    FN              reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    STD             reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    IF              reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 33 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)


state 172

    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 176


state 173

    (38) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 177
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 174

    (34) funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .

    LET             reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    FN              reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    STD             reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    IF              reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 34 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE .)


state 175

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN . DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 178


state 176

    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (24) sentencias -> . asignacion SEMICOLON
    (25) sentencias -> . impresion SEMICOLON
    (26) sentencias -> . funcion
    (27) sentencias -> . ingreso_datos SEMICOLON
    (28) sentencias -> . arreglos SEMICOLON
    (29) sentencias -> . control_structure
    (30) sentencias -> . llamada SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (31) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (32) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (33) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (34) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (35) funcion -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (36) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (37) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (38) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (85) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 10
    PRINTLN         shift and go to state 12
    FN              shift and go to state 13
    STD             shift and go to state 14
    LCORCH          shift and go to state 15
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 17

    programa                       shift and go to state 179
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    llamada                        shift and go to state 9
    condicional                    shift and go to state 16

state 177

    (38) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (39) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 181

    retorno                        shift and go to state 180

state 178

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT . READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    READLINE        shift and go to state 182


state 179

    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (39) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 181

    retorno                        shift and go to state 183

state 180

    (38) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 184


state 181

    (39) retorno -> RETURN . valor SEMICOLON
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (20) valor -> . booleanos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH
    (21) booleanos -> . TRUE
    (22) booleanos -> . FALSE

    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    IDENTIFIER      shift and go to state 35
    STRING          shift and go to state 39
    LCORCH          shift and go to state 15
    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    valor                          shift and go to state 185
    operacion                      shift and go to state 36
    indexacion                     shift and go to state 37
    arreglos                       shift and go to state 38
    booleanos                      shift and go to state 40

state 182

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE . LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 186


state 183

    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 187


state 184

    (38) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    LET             reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    PRINTLN         reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    FN              reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    STD             reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    LCORCH          reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    IDENTIFIER      reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    IF              reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    RLLAVE          reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    RETURN          reduce using rule 38 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 185

    (39) retorno -> RETURN valor . SEMICOLON
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       shift and go to state 188
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60
    INTD            shift and go to state 61


state 186

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN . REFERENCE MUT IDENTIFIER RPAREN

    REFERENCE       shift and go to state 189


state 187

    (37) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    LET             reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    PRINTLN         reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    FN              reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    STD             reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    LCORCH          reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    IDENTIFIER      reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    IF              reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    RLLAVE          reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    RETURN          reduce using rule 37 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 188

    (39) retorno -> RETURN valor SEMICOLON .

    RLLAVE          reduce using rule 39 (retorno -> RETURN valor SEMICOLON .)


state 189

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE . MUT IDENTIFIER RPAREN

    MUT             shift and go to state 190


state 190

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 191


state 191

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER . RPAREN

    RPAREN          shift and go to state 192


state 192

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .

    SEMICOLON       reduce using rule 43 (ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LLLAVE in state 43 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 51 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 52 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for MOD in state 110 resolved as shift
WARNING: shift/reduce conflict for INTD in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 111 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for MOD in state 111 resolved as shift
WARNING: shift/reduce conflict for INTD in state 111 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for MOD in state 112 resolved as shift
WARNING: shift/reduce conflict for INTD in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for MOD in state 113 resolved as shift
WARNING: shift/reduce conflict for INTD in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for MOD in state 114 resolved as shift
WARNING: shift/reduce conflict for INTD in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for MOD in state 115 resolved as shift
WARNING: shift/reduce conflict for INTD in state 115 resolved as shift
