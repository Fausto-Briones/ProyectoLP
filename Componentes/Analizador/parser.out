Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOUBLE_QUOTATION_MARK
    ELSE
    FALSE
    FOR
    FROM
    IMPL
    IN
    MAIN
    MATCH
    NOT
    QUOTATION_MARK
    RAND
    RETURN
    SELF
    STR
    STRING
    STRUCT
    TRUE
    WHILE

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencias
Rule 2     programa -> sentencias programa
Rule 3     asignacion -> LET IDENTIFIER ASIG valor
Rule 4     asignacion -> LET MUT IDENTIFIER ASIG valor
Rule 5     asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor
Rule 6     asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor
Rule 7     comparacion -> IDENTIFIER LEQ IDENTIFIER
Rule 8     comparacion -> IDENTIFIER GEQ IDENTIFIER
Rule 9     comparacion -> IDENTIFIER EQ IDENTIFIER
Rule 10    comparacion -> IDENTIFIER NEQ IDENTIFIER
Rule 11    comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER
Rule 12    comparacion -> IDENTIFIER LEFTARROW IDENTIFIER
Rule 13    comparacion -> IDENTIFIER EQ valor
Rule 14    comparacion -> IDENTIFIER NEQ valor
Rule 15    comparacion -> IDENTIFIER GEQ valor
Rule 16    comparacion -> IDENTIFIER LEQ valor
Rule 17    comparacion -> IDENTIFIER RIGHTARROW valor
Rule 18    comparacion -> IDENTIFIER LEFTARROW valor
Rule 19    comparacion -> valor EQ IDENTIFIER
Rule 20    comparacion -> valor NEQ IDENTIFIER
Rule 21    comparacion -> valor GEQ IDENTIFIER
Rule 22    comparacion -> valor LEQ IDENTIFIER
Rule 23    comparacion -> valor RIGHTARROW IDENTIFIER
Rule 24    comparacion -> valor LEFTARROW IDENTIFIER
Rule 25    valor -> INTEGER
Rule 26    valor -> FLOAT
Rule 27    valor -> IDENTIFIER
Rule 28    valor -> operacion
Rule 29    valor -> indexacion
Rule 30    valor -> arreglos
Rule 31    vacio -> <empty>
Rule 32    sentencias -> asignacion SEMICOLON
Rule 33    sentencias -> impresion SEMICOLON
Rule 34    sentencias -> funcion SEMICOLON
Rule 35    sentencias -> ingreso_datos SEMICOLON
Rule 36    sentencias -> arreglos SEMICOLON
Rule 37    sentencias -> control_structure SEMICOLON
Rule 38    impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN
Rule 39    funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
Rule 40    parameters -> IDENTIFIER COLON asig_data_type
Rule 41    parameters -> IDENTIFIER COLON asig_data_type COMMA parameters
Rule 42    parameters -> vacio
Rule 43    ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
Rule 44    asig_data_type -> data_type
Rule 45    asig_data_type -> LPAREN some_data_type RPAREN
Rule 46    asig_data_type -> LCORCH some_data_type RCORCH
Rule 47    data_type -> CHAR
Rule 48    data_type -> signed_integer
Rule 49    data_type -> unsigned_integer
Rule 50    data_type -> float_type
Rule 51    data_type -> BOOL
Rule 52    signed_integer -> I8
Rule 53    signed_integer -> I16
Rule 54    signed_integer -> I32
Rule 55    signed_integer -> I64
Rule 56    signed_integer -> I128
Rule 57    signed_integer -> ISIZE
Rule 58    unsigned_integer -> U8
Rule 59    unsigned_integer -> U16
Rule 60    unsigned_integer -> U32
Rule 61    unsigned_integer -> U64
Rule 62    unsigned_integer -> U128
Rule 63    unsigned_integer -> USIZE
Rule 64    float_type -> F32
Rule 65    float_type -> F64
Rule 66    some_data_type -> data_type
Rule 67    some_data_type -> data_type COMMA some_data_type
Rule 68    control_structure -> condicional
Rule 69    arreglos -> LCORCH valores RCORCH
Rule 70    valores -> valor
Rule 71    valores -> valor COMMA valores
Rule 72    conector -> AND
Rule 73    conector -> OR
Rule 74    proposicion -> comparacion conector proposicion
Rule 75    proposicion -> comparacion
Rule 76    condicional -> IF comparacion LLLAVE programa RLLAVE
Rule 77    condicional -> IF proposicion LLLAVE programa RLLAVE
Rule 78    operacion -> valor PLUS valor
Rule 79    operacion -> valor MINUS valor
Rule 80    operacion -> valor TIMES valor
Rule 81    operacion -> valor DIVIDE valor
Rule 82    operacion -> valor MOD valor
Rule 83    operacion -> valor INTD valor
Rule 84    indexacion -> IDENTIFIER LCORCH INTEGER RCORCH

Terminals, with rules where they appear

AND                  : 72
ASIG                 : 3 4 5 6
BOOL                 : 51
CHAR                 : 47
COLON                : 5 6 40 41
COMMA                : 41 67 71
DIVIDE               : 81
DOT                  : 43 43
DOUBLE_COLON         : 43 43
DOUBLE_QUOTATION_MARK : 
ELSE                 : 
EQ                   : 9 13 19
EXCLAMATION          : 38
F32                  : 64
F64                  : 65
FALSE                : 
FLOAT                : 26
FN                   : 39
FOR                  : 
FROM                 : 
GEQ                  : 8 15 21
I128                 : 56
I16                  : 53
I32                  : 54
I64                  : 55
I8                   : 52
IDENTIFIER           : 3 4 5 6 7 7 8 8 9 9 10 10 11 11 12 12 13 14 15 16 17 18 19 20 21 22 23 24 27 39 40 41 43 84
IF                   : 76 77
IMPL                 : 
IN                   : 
INTD                 : 83
INTEGER              : 25 84
IO                   : 43
ISIZE                : 57
LCORCH               : 46 69 84
LEFTARROW            : 12 18 24
LEQ                  : 7 16 22
LET                  : 3 4 5 6
LLLAVE               : 39 76 77
LPAREN               : 38 39 43 43 45
MAIN                 : 
MATCH                : 
MINUS                : 79
MOD                  : 82
MUT                  : 4 6 43
NEQ                  : 10 14 20
NOT                  : 
OR                   : 73
PLUS                 : 78
PRINTLN              : 38
QUOTATION_MARK       : 
RAND                 : 
RCORCH               : 46 69 84
READLINE             : 43
REFERENCE            : 43
RETURN               : 
RIGHTARROW           : 11 17 23
RLLAVE               : 39 76 77
RPAREN               : 38 39 43 43 45
SELF                 : 
SEMICOLON            : 32 33 34 35 36 37
STD                  : 43
STDIN                : 43
STR                  : 
STRING               : 
STRUCT               : 
TIMES                : 80
TRUE                 : 
U128                 : 62
U16                  : 59
U32                  : 60
U64                  : 61
U8                   : 58
USIZE                : 63
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arreglos             : 30 36
asig_data_type       : 5 6 40 41
asignacion           : 32
comparacion          : 74 75 76
condicional          : 68
conector             : 74
control_structure    : 37
data_type            : 44 66 67
float_type           : 50
funcion              : 34
impresion            : 33
indexacion           : 29
ingreso_datos        : 35
operacion            : 28
parameters           : 39 41
programa             : 2 39 76 77 0
proposicion          : 74 77
sentencias           : 1 2
signed_integer       : 48
some_data_type       : 45 46 67
unsigned_integer     : 49
vacio                : 42
valor                : 3 4 5 6 13 14 15 16 17 18 19 20 21 22 23 24 38 70 71 78 78 79 79 80 80 81 81 82 82 83 83
valores              : 69 71

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (32) sentencias -> . asignacion SEMICOLON
    (33) sentencias -> . impresion SEMICOLON
    (34) sentencias -> . funcion SEMICOLON
    (35) sentencias -> . ingreso_datos SEMICOLON
    (36) sentencias -> . arreglos SEMICOLON
    (37) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (38) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (39) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    programa                       shift and go to state 1
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencias .
    (2) programa -> sentencias . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (32) sentencias -> . asignacion SEMICOLON
    (33) sentencias -> . impresion SEMICOLON
    (34) sentencias -> . funcion SEMICOLON
    (35) sentencias -> . ingreso_datos SEMICOLON
    (36) sentencias -> . arreglos SEMICOLON
    (37) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (38) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (39) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    $end            reduce using rule 1 (programa -> sentencias .)
    RLLAVE          reduce using rule 1 (programa -> sentencias .)
    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    sentencias                     shift and go to state 2
    programa                       shift and go to state 16
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 3

    (32) sentencias -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 17


state 4

    (33) sentencias -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 18


state 5

    (34) sentencias -> funcion . SEMICOLON

    SEMICOLON       shift and go to state 19


state 6

    (35) sentencias -> ingreso_datos . SEMICOLON

    SEMICOLON       shift and go to state 20


state 7

    (36) sentencias -> arreglos . SEMICOLON

    SEMICOLON       shift and go to state 21


state 8

    (37) sentencias -> control_structure . SEMICOLON

    SEMICOLON       shift and go to state 22


state 9

    (3) asignacion -> LET . IDENTIFIER ASIG valor
    (4) asignacion -> LET . MUT IDENTIFIER ASIG valor
    (5) asignacion -> LET . IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> LET . MUT IDENTIFIER COLON asig_data_type ASIG valor

    IDENTIFIER      shift and go to state 23
    MUT             shift and go to state 24


state 10

    (38) impresion -> PRINTLN . EXCLAMATION LPAREN valor RPAREN

    EXCLAMATION     shift and go to state 25


state 11

    (39) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE

    IDENTIFIER      shift and go to state 26


state 12

    (43) ingreso_datos -> STD . DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 27


state 13

    (69) arreglos -> LCORCH . valores RCORCH
    (70) valores -> . valor
    (71) valores -> . valor COMMA valores
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valores                        shift and go to state 28
    valor                          shift and go to state 29
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 14

    (68) control_structure -> condicional .

    SEMICOLON       reduce using rule 68 (control_structure -> condicional .)


state 15

    (76) condicional -> IF . comparacion LLLAVE programa RLLAVE
    (77) condicional -> IF . proposicion LLLAVE programa RLLAVE
    (7) comparacion -> . IDENTIFIER LEQ IDENTIFIER
    (8) comparacion -> . IDENTIFIER GEQ IDENTIFIER
    (9) comparacion -> . IDENTIFIER EQ IDENTIFIER
    (10) comparacion -> . IDENTIFIER NEQ IDENTIFIER
    (11) comparacion -> . IDENTIFIER RIGHTARROW IDENTIFIER
    (12) comparacion -> . IDENTIFIER LEFTARROW IDENTIFIER
    (13) comparacion -> . IDENTIFIER EQ valor
    (14) comparacion -> . IDENTIFIER NEQ valor
    (15) comparacion -> . IDENTIFIER GEQ valor
    (16) comparacion -> . IDENTIFIER LEQ valor
    (17) comparacion -> . IDENTIFIER RIGHTARROW valor
    (18) comparacion -> . IDENTIFIER LEFTARROW valor
    (19) comparacion -> . valor EQ IDENTIFIER
    (20) comparacion -> . valor NEQ IDENTIFIER
    (21) comparacion -> . valor GEQ IDENTIFIER
    (22) comparacion -> . valor LEQ IDENTIFIER
    (23) comparacion -> . valor RIGHTARROW IDENTIFIER
    (24) comparacion -> . valor LEFTARROW IDENTIFIER
    (74) proposicion -> . comparacion conector proposicion
    (75) proposicion -> . comparacion
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 38
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    comparacion                    shift and go to state 36
    proposicion                    shift and go to state 37
    valor                          shift and go to state 39
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 16

    (2) programa -> sentencias programa .

    $end            reduce using rule 2 (programa -> sentencias programa .)
    RLLAVE          reduce using rule 2 (programa -> sentencias programa .)


state 17

    (32) sentencias -> asignacion SEMICOLON .

    LET             reduce using rule 32 (sentencias -> asignacion SEMICOLON .)
    PRINTLN         reduce using rule 32 (sentencias -> asignacion SEMICOLON .)
    FN              reduce using rule 32 (sentencias -> asignacion SEMICOLON .)
    STD             reduce using rule 32 (sentencias -> asignacion SEMICOLON .)
    LCORCH          reduce using rule 32 (sentencias -> asignacion SEMICOLON .)
    IF              reduce using rule 32 (sentencias -> asignacion SEMICOLON .)
    $end            reduce using rule 32 (sentencias -> asignacion SEMICOLON .)
    RLLAVE          reduce using rule 32 (sentencias -> asignacion SEMICOLON .)


state 18

    (33) sentencias -> impresion SEMICOLON .

    LET             reduce using rule 33 (sentencias -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 33 (sentencias -> impresion SEMICOLON .)
    FN              reduce using rule 33 (sentencias -> impresion SEMICOLON .)
    STD             reduce using rule 33 (sentencias -> impresion SEMICOLON .)
    LCORCH          reduce using rule 33 (sentencias -> impresion SEMICOLON .)
    IF              reduce using rule 33 (sentencias -> impresion SEMICOLON .)
    $end            reduce using rule 33 (sentencias -> impresion SEMICOLON .)
    RLLAVE          reduce using rule 33 (sentencias -> impresion SEMICOLON .)


state 19

    (34) sentencias -> funcion SEMICOLON .

    LET             reduce using rule 34 (sentencias -> funcion SEMICOLON .)
    PRINTLN         reduce using rule 34 (sentencias -> funcion SEMICOLON .)
    FN              reduce using rule 34 (sentencias -> funcion SEMICOLON .)
    STD             reduce using rule 34 (sentencias -> funcion SEMICOLON .)
    LCORCH          reduce using rule 34 (sentencias -> funcion SEMICOLON .)
    IF              reduce using rule 34 (sentencias -> funcion SEMICOLON .)
    $end            reduce using rule 34 (sentencias -> funcion SEMICOLON .)
    RLLAVE          reduce using rule 34 (sentencias -> funcion SEMICOLON .)


state 20

    (35) sentencias -> ingreso_datos SEMICOLON .

    LET             reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)
    PRINTLN         reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)
    FN              reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)
    STD             reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)
    LCORCH          reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)
    IF              reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)
    $end            reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)
    RLLAVE          reduce using rule 35 (sentencias -> ingreso_datos SEMICOLON .)


state 21

    (36) sentencias -> arreglos SEMICOLON .

    LET             reduce using rule 36 (sentencias -> arreglos SEMICOLON .)
    PRINTLN         reduce using rule 36 (sentencias -> arreglos SEMICOLON .)
    FN              reduce using rule 36 (sentencias -> arreglos SEMICOLON .)
    STD             reduce using rule 36 (sentencias -> arreglos SEMICOLON .)
    LCORCH          reduce using rule 36 (sentencias -> arreglos SEMICOLON .)
    IF              reduce using rule 36 (sentencias -> arreglos SEMICOLON .)
    $end            reduce using rule 36 (sentencias -> arreglos SEMICOLON .)
    RLLAVE          reduce using rule 36 (sentencias -> arreglos SEMICOLON .)


state 22

    (37) sentencias -> control_structure SEMICOLON .

    LET             reduce using rule 37 (sentencias -> control_structure SEMICOLON .)
    PRINTLN         reduce using rule 37 (sentencias -> control_structure SEMICOLON .)
    FN              reduce using rule 37 (sentencias -> control_structure SEMICOLON .)
    STD             reduce using rule 37 (sentencias -> control_structure SEMICOLON .)
    LCORCH          reduce using rule 37 (sentencias -> control_structure SEMICOLON .)
    IF              reduce using rule 37 (sentencias -> control_structure SEMICOLON .)
    $end            reduce using rule 37 (sentencias -> control_structure SEMICOLON .)
    RLLAVE          reduce using rule 37 (sentencias -> control_structure SEMICOLON .)


state 23

    (3) asignacion -> LET IDENTIFIER . ASIG valor
    (5) asignacion -> LET IDENTIFIER . COLON asig_data_type ASIG valor

    ASIG            shift and go to state 40
    COLON           shift and go to state 41


state 24

    (4) asignacion -> LET MUT . IDENTIFIER ASIG valor
    (6) asignacion -> LET MUT . IDENTIFIER COLON asig_data_type ASIG valor

    IDENTIFIER      shift and go to state 42


state 25

    (38) impresion -> PRINTLN EXCLAMATION . LPAREN valor RPAREN

    LPAREN          shift and go to state 43


state 26

    (39) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN LLLAVE programa RLLAVE

    LPAREN          shift and go to state 44


state 27

    (43) ingreso_datos -> STD DOUBLE_COLON . IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    IO              shift and go to state 45


state 28

    (69) arreglos -> LCORCH valores . RCORCH

    RCORCH          shift and go to state 46


state 29

    (70) valores -> valor .
    (71) valores -> valor . COMMA valores
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    RCORCH          reduce using rule 70 (valores -> valor .)
    COMMA           shift and go to state 47
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 30

    (25) valor -> INTEGER .

    COMMA           reduce using rule 25 (valor -> INTEGER .)
    PLUS            reduce using rule 25 (valor -> INTEGER .)
    MINUS           reduce using rule 25 (valor -> INTEGER .)
    TIMES           reduce using rule 25 (valor -> INTEGER .)
    DIVIDE          reduce using rule 25 (valor -> INTEGER .)
    MOD             reduce using rule 25 (valor -> INTEGER .)
    INTD            reduce using rule 25 (valor -> INTEGER .)
    RCORCH          reduce using rule 25 (valor -> INTEGER .)
    EQ              reduce using rule 25 (valor -> INTEGER .)
    NEQ             reduce using rule 25 (valor -> INTEGER .)
    GEQ             reduce using rule 25 (valor -> INTEGER .)
    LEQ             reduce using rule 25 (valor -> INTEGER .)
    RIGHTARROW      reduce using rule 25 (valor -> INTEGER .)
    LEFTARROW       reduce using rule 25 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 25 (valor -> INTEGER .)
    RPAREN          reduce using rule 25 (valor -> INTEGER .)
    LLLAVE          reduce using rule 25 (valor -> INTEGER .)
    AND             reduce using rule 25 (valor -> INTEGER .)
    OR              reduce using rule 25 (valor -> INTEGER .)


state 31

    (26) valor -> FLOAT .

    COMMA           reduce using rule 26 (valor -> FLOAT .)
    PLUS            reduce using rule 26 (valor -> FLOAT .)
    MINUS           reduce using rule 26 (valor -> FLOAT .)
    TIMES           reduce using rule 26 (valor -> FLOAT .)
    DIVIDE          reduce using rule 26 (valor -> FLOAT .)
    MOD             reduce using rule 26 (valor -> FLOAT .)
    INTD            reduce using rule 26 (valor -> FLOAT .)
    RCORCH          reduce using rule 26 (valor -> FLOAT .)
    EQ              reduce using rule 26 (valor -> FLOAT .)
    NEQ             reduce using rule 26 (valor -> FLOAT .)
    GEQ             reduce using rule 26 (valor -> FLOAT .)
    LEQ             reduce using rule 26 (valor -> FLOAT .)
    RIGHTARROW      reduce using rule 26 (valor -> FLOAT .)
    LEFTARROW       reduce using rule 26 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 26 (valor -> FLOAT .)
    RPAREN          reduce using rule 26 (valor -> FLOAT .)
    LLLAVE          reduce using rule 26 (valor -> FLOAT .)
    AND             reduce using rule 26 (valor -> FLOAT .)
    OR              reduce using rule 26 (valor -> FLOAT .)


state 32

    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

    COMMA           reduce using rule 27 (valor -> IDENTIFIER .)
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    RCORCH          reduce using rule 27 (valor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 27 (valor -> IDENTIFIER .)
    RPAREN          reduce using rule 27 (valor -> IDENTIFIER .)
    EQ              reduce using rule 27 (valor -> IDENTIFIER .)
    NEQ             reduce using rule 27 (valor -> IDENTIFIER .)
    GEQ             reduce using rule 27 (valor -> IDENTIFIER .)
    LEQ             reduce using rule 27 (valor -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 27 (valor -> IDENTIFIER .)
    LEFTARROW       reduce using rule 27 (valor -> IDENTIFIER .)
    LLLAVE          reduce using rule 27 (valor -> IDENTIFIER .)
    AND             reduce using rule 27 (valor -> IDENTIFIER .)
    OR              reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54


state 33

    (28) valor -> operacion .

    COMMA           reduce using rule 28 (valor -> operacion .)
    PLUS            reduce using rule 28 (valor -> operacion .)
    MINUS           reduce using rule 28 (valor -> operacion .)
    TIMES           reduce using rule 28 (valor -> operacion .)
    DIVIDE          reduce using rule 28 (valor -> operacion .)
    MOD             reduce using rule 28 (valor -> operacion .)
    INTD            reduce using rule 28 (valor -> operacion .)
    RCORCH          reduce using rule 28 (valor -> operacion .)
    EQ              reduce using rule 28 (valor -> operacion .)
    NEQ             reduce using rule 28 (valor -> operacion .)
    GEQ             reduce using rule 28 (valor -> operacion .)
    LEQ             reduce using rule 28 (valor -> operacion .)
    RIGHTARROW      reduce using rule 28 (valor -> operacion .)
    LEFTARROW       reduce using rule 28 (valor -> operacion .)
    SEMICOLON       reduce using rule 28 (valor -> operacion .)
    RPAREN          reduce using rule 28 (valor -> operacion .)
    LLLAVE          reduce using rule 28 (valor -> operacion .)
    AND             reduce using rule 28 (valor -> operacion .)
    OR              reduce using rule 28 (valor -> operacion .)


state 34

    (29) valor -> indexacion .

    COMMA           reduce using rule 29 (valor -> indexacion .)
    PLUS            reduce using rule 29 (valor -> indexacion .)
    MINUS           reduce using rule 29 (valor -> indexacion .)
    TIMES           reduce using rule 29 (valor -> indexacion .)
    DIVIDE          reduce using rule 29 (valor -> indexacion .)
    MOD             reduce using rule 29 (valor -> indexacion .)
    INTD            reduce using rule 29 (valor -> indexacion .)
    RCORCH          reduce using rule 29 (valor -> indexacion .)
    EQ              reduce using rule 29 (valor -> indexacion .)
    NEQ             reduce using rule 29 (valor -> indexacion .)
    GEQ             reduce using rule 29 (valor -> indexacion .)
    LEQ             reduce using rule 29 (valor -> indexacion .)
    RIGHTARROW      reduce using rule 29 (valor -> indexacion .)
    LEFTARROW       reduce using rule 29 (valor -> indexacion .)
    SEMICOLON       reduce using rule 29 (valor -> indexacion .)
    RPAREN          reduce using rule 29 (valor -> indexacion .)
    LLLAVE          reduce using rule 29 (valor -> indexacion .)
    AND             reduce using rule 29 (valor -> indexacion .)
    OR              reduce using rule 29 (valor -> indexacion .)


state 35

    (30) valor -> arreglos .

    COMMA           reduce using rule 30 (valor -> arreglos .)
    PLUS            reduce using rule 30 (valor -> arreglos .)
    MINUS           reduce using rule 30 (valor -> arreglos .)
    TIMES           reduce using rule 30 (valor -> arreglos .)
    DIVIDE          reduce using rule 30 (valor -> arreglos .)
    MOD             reduce using rule 30 (valor -> arreglos .)
    INTD            reduce using rule 30 (valor -> arreglos .)
    RCORCH          reduce using rule 30 (valor -> arreglos .)
    EQ              reduce using rule 30 (valor -> arreglos .)
    NEQ             reduce using rule 30 (valor -> arreglos .)
    GEQ             reduce using rule 30 (valor -> arreglos .)
    LEQ             reduce using rule 30 (valor -> arreglos .)
    RIGHTARROW      reduce using rule 30 (valor -> arreglos .)
    LEFTARROW       reduce using rule 30 (valor -> arreglos .)
    SEMICOLON       reduce using rule 30 (valor -> arreglos .)
    RPAREN          reduce using rule 30 (valor -> arreglos .)
    LLLAVE          reduce using rule 30 (valor -> arreglos .)
    AND             reduce using rule 30 (valor -> arreglos .)
    OR              reduce using rule 30 (valor -> arreglos .)


state 36

    (76) condicional -> IF comparacion . LLLAVE programa RLLAVE
    (74) proposicion -> comparacion . conector proposicion
    (75) proposicion -> comparacion .
    (72) conector -> . AND
    (73) conector -> . OR

  ! shift/reduce conflict for LLLAVE resolved as shift
    LLLAVE          shift and go to state 55
    AND             shift and go to state 57
    OR              shift and go to state 58

  ! LLLAVE          [ reduce using rule 75 (proposicion -> comparacion .) ]

    conector                       shift and go to state 56

state 37

    (77) condicional -> IF proposicion . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 59


state 38

    (7) comparacion -> IDENTIFIER . LEQ IDENTIFIER
    (8) comparacion -> IDENTIFIER . GEQ IDENTIFIER
    (9) comparacion -> IDENTIFIER . EQ IDENTIFIER
    (10) comparacion -> IDENTIFIER . NEQ IDENTIFIER
    (11) comparacion -> IDENTIFIER . RIGHTARROW IDENTIFIER
    (12) comparacion -> IDENTIFIER . LEFTARROW IDENTIFIER
    (13) comparacion -> IDENTIFIER . EQ valor
    (14) comparacion -> IDENTIFIER . NEQ valor
    (15) comparacion -> IDENTIFIER . GEQ valor
    (16) comparacion -> IDENTIFIER . LEQ valor
    (17) comparacion -> IDENTIFIER . RIGHTARROW valor
    (18) comparacion -> IDENTIFIER . LEFTARROW valor
    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for RIGHTARROW resolved as shift
  ! shift/reduce conflict for LEFTARROW resolved as shift
    LEQ             shift and go to state 60
    GEQ             shift and go to state 61
    EQ              shift and go to state 62
    NEQ             shift and go to state 63
    RIGHTARROW      shift and go to state 64
    LEFTARROW       shift and go to state 65
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54

  ! EQ              [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! NEQ             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! GEQ             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! LEQ             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! RIGHTARROW      [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! LEFTARROW       [ reduce using rule 27 (valor -> IDENTIFIER .) ]


state 39

    (19) comparacion -> valor . EQ IDENTIFIER
    (20) comparacion -> valor . NEQ IDENTIFIER
    (21) comparacion -> valor . GEQ IDENTIFIER
    (22) comparacion -> valor . LEQ IDENTIFIER
    (23) comparacion -> valor . RIGHTARROW IDENTIFIER
    (24) comparacion -> valor . LEFTARROW IDENTIFIER
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    EQ              shift and go to state 66
    NEQ             shift and go to state 67
    GEQ             shift and go to state 68
    LEQ             shift and go to state 69
    RIGHTARROW      shift and go to state 70
    LEFTARROW       shift and go to state 71
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 40

    (3) asignacion -> LET IDENTIFIER ASIG . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 72
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 41

    (5) asignacion -> LET IDENTIFIER COLON . asig_data_type ASIG valor
    (44) asig_data_type -> . data_type
    (45) asig_data_type -> . LPAREN some_data_type RPAREN
    (46) asig_data_type -> . LCORCH some_data_type RCORCH
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    LPAREN          shift and go to state 75
    LCORCH          shift and go to state 76
    CHAR            shift and go to state 77
    BOOL            shift and go to state 81
    I8              shift and go to state 82
    I16             shift and go to state 83
    I32             shift and go to state 84
    I64             shift and go to state 85
    I128            shift and go to state 86
    ISIZE           shift and go to state 87
    U8              shift and go to state 88
    U16             shift and go to state 89
    U32             shift and go to state 90
    U64             shift and go to state 91
    U128            shift and go to state 92
    USIZE           shift and go to state 93
    F32             shift and go to state 94
    F64             shift and go to state 95

    asig_data_type                 shift and go to state 73
    data_type                      shift and go to state 74
    signed_integer                 shift and go to state 78
    unsigned_integer               shift and go to state 79
    float_type                     shift and go to state 80

state 42

    (4) asignacion -> LET MUT IDENTIFIER . ASIG valor
    (6) asignacion -> LET MUT IDENTIFIER . COLON asig_data_type ASIG valor

    ASIG            shift and go to state 96
    COLON           shift and go to state 97


state 43

    (38) impresion -> PRINTLN EXCLAMATION LPAREN . valor RPAREN
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 98
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 44

    (39) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN LLLAVE programa RLLAVE
    (40) parameters -> . IDENTIFIER COLON asig_data_type
    (41) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (42) parameters -> . vacio
    (31) vacio -> .

    IDENTIFIER      shift and go to state 99
    RPAREN          reduce using rule 31 (vacio -> .)

    parameters                     shift and go to state 100
    vacio                          shift and go to state 101

state 45

    (43) ingreso_datos -> STD DOUBLE_COLON IO . DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 102


state 46

    (69) arreglos -> LCORCH valores RCORCH .

    SEMICOLON       reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    COMMA           reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    PLUS            reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    MINUS           reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    TIMES           reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    DIVIDE          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    MOD             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    INTD            reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    RCORCH          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    EQ              reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    NEQ             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    GEQ             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    LEQ             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    RIGHTARROW      reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    LEFTARROW       reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    RPAREN          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    LLLAVE          reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    AND             reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)
    OR              reduce using rule 69 (arreglos -> LCORCH valores RCORCH .)


state 47

    (71) valores -> valor COMMA . valores
    (70) valores -> . valor
    (71) valores -> . valor COMMA valores
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 29
    valores                        shift and go to state 103
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 48

    (78) operacion -> valor PLUS . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 104
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 49

    (79) operacion -> valor MINUS . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 105
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 50

    (80) operacion -> valor TIMES . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 106
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 51

    (81) operacion -> valor DIVIDE . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 107
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 52

    (82) operacion -> valor MOD . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 108
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 53

    (83) operacion -> valor INTD . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 109
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 54

    (84) indexacion -> IDENTIFIER LCORCH . INTEGER RCORCH

    INTEGER         shift and go to state 110


state 55

    (76) condicional -> IF comparacion LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (32) sentencias -> . asignacion SEMICOLON
    (33) sentencias -> . impresion SEMICOLON
    (34) sentencias -> . funcion SEMICOLON
    (35) sentencias -> . ingreso_datos SEMICOLON
    (36) sentencias -> . arreglos SEMICOLON
    (37) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (38) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (39) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    programa                       shift and go to state 111
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 56

    (74) proposicion -> comparacion conector . proposicion
    (74) proposicion -> . comparacion conector proposicion
    (75) proposicion -> . comparacion
    (7) comparacion -> . IDENTIFIER LEQ IDENTIFIER
    (8) comparacion -> . IDENTIFIER GEQ IDENTIFIER
    (9) comparacion -> . IDENTIFIER EQ IDENTIFIER
    (10) comparacion -> . IDENTIFIER NEQ IDENTIFIER
    (11) comparacion -> . IDENTIFIER RIGHTARROW IDENTIFIER
    (12) comparacion -> . IDENTIFIER LEFTARROW IDENTIFIER
    (13) comparacion -> . IDENTIFIER EQ valor
    (14) comparacion -> . IDENTIFIER NEQ valor
    (15) comparacion -> . IDENTIFIER GEQ valor
    (16) comparacion -> . IDENTIFIER LEQ valor
    (17) comparacion -> . IDENTIFIER RIGHTARROW valor
    (18) comparacion -> . IDENTIFIER LEFTARROW valor
    (19) comparacion -> . valor EQ IDENTIFIER
    (20) comparacion -> . valor NEQ IDENTIFIER
    (21) comparacion -> . valor GEQ IDENTIFIER
    (22) comparacion -> . valor LEQ IDENTIFIER
    (23) comparacion -> . valor RIGHTARROW IDENTIFIER
    (24) comparacion -> . valor LEFTARROW IDENTIFIER
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 38
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    comparacion                    shift and go to state 112
    proposicion                    shift and go to state 113
    valor                          shift and go to state 39
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 57

    (72) conector -> AND .

    IDENTIFIER      reduce using rule 72 (conector -> AND .)
    INTEGER         reduce using rule 72 (conector -> AND .)
    FLOAT           reduce using rule 72 (conector -> AND .)
    LCORCH          reduce using rule 72 (conector -> AND .)


state 58

    (73) conector -> OR .

    IDENTIFIER      reduce using rule 73 (conector -> OR .)
    INTEGER         reduce using rule 73 (conector -> OR .)
    FLOAT           reduce using rule 73 (conector -> OR .)
    LCORCH          reduce using rule 73 (conector -> OR .)


state 59

    (77) condicional -> IF proposicion LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (32) sentencias -> . asignacion SEMICOLON
    (33) sentencias -> . impresion SEMICOLON
    (34) sentencias -> . funcion SEMICOLON
    (35) sentencias -> . ingreso_datos SEMICOLON
    (36) sentencias -> . arreglos SEMICOLON
    (37) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (38) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (39) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    programa                       shift and go to state 114
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 60

    (7) comparacion -> IDENTIFIER LEQ . IDENTIFIER
    (16) comparacion -> IDENTIFIER LEQ . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 115
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    valor                          shift and go to state 116
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 61

    (8) comparacion -> IDENTIFIER GEQ . IDENTIFIER
    (15) comparacion -> IDENTIFIER GEQ . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 117
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    valor                          shift and go to state 118
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 62

    (9) comparacion -> IDENTIFIER EQ . IDENTIFIER
    (13) comparacion -> IDENTIFIER EQ . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 119
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    valor                          shift and go to state 120
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 63

    (10) comparacion -> IDENTIFIER NEQ . IDENTIFIER
    (14) comparacion -> IDENTIFIER NEQ . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 121
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    valor                          shift and go to state 122
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 64

    (11) comparacion -> IDENTIFIER RIGHTARROW . IDENTIFIER
    (17) comparacion -> IDENTIFIER RIGHTARROW . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 123
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    valor                          shift and go to state 124
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 65

    (12) comparacion -> IDENTIFIER LEFTARROW . IDENTIFIER
    (18) comparacion -> IDENTIFIER LEFTARROW . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    IDENTIFIER      shift and go to state 125
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    LCORCH          shift and go to state 13

    valor                          shift and go to state 126
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 66

    (19) comparacion -> valor EQ . IDENTIFIER

    IDENTIFIER      shift and go to state 127


state 67

    (20) comparacion -> valor NEQ . IDENTIFIER

    IDENTIFIER      shift and go to state 128


state 68

    (21) comparacion -> valor GEQ . IDENTIFIER

    IDENTIFIER      shift and go to state 129


state 69

    (22) comparacion -> valor LEQ . IDENTIFIER

    IDENTIFIER      shift and go to state 130


state 70

    (23) comparacion -> valor RIGHTARROW . IDENTIFIER

    IDENTIFIER      shift and go to state 131


state 71

    (24) comparacion -> valor LEFTARROW . IDENTIFIER

    IDENTIFIER      shift and go to state 132


state 72

    (3) asignacion -> LET IDENTIFIER ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 3 (asignacion -> LET IDENTIFIER ASIG valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 73

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type . ASIG valor

    ASIG            shift and go to state 133


state 74

    (44) asig_data_type -> data_type .

    ASIG            reduce using rule 44 (asig_data_type -> data_type .)
    COMMA           reduce using rule 44 (asig_data_type -> data_type .)
    RPAREN          reduce using rule 44 (asig_data_type -> data_type .)


state 75

    (45) asig_data_type -> LPAREN . some_data_type RPAREN
    (66) some_data_type -> . data_type
    (67) some_data_type -> . data_type COMMA some_data_type
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 77
    BOOL            shift and go to state 81
    I8              shift and go to state 82
    I16             shift and go to state 83
    I32             shift and go to state 84
    I64             shift and go to state 85
    I128            shift and go to state 86
    ISIZE           shift and go to state 87
    U8              shift and go to state 88
    U16             shift and go to state 89
    U32             shift and go to state 90
    U64             shift and go to state 91
    U128            shift and go to state 92
    USIZE           shift and go to state 93
    F32             shift and go to state 94
    F64             shift and go to state 95

    some_data_type                 shift and go to state 134
    data_type                      shift and go to state 135
    signed_integer                 shift and go to state 78
    unsigned_integer               shift and go to state 79
    float_type                     shift and go to state 80

state 76

    (46) asig_data_type -> LCORCH . some_data_type RCORCH
    (66) some_data_type -> . data_type
    (67) some_data_type -> . data_type COMMA some_data_type
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 77
    BOOL            shift and go to state 81
    I8              shift and go to state 82
    I16             shift and go to state 83
    I32             shift and go to state 84
    I64             shift and go to state 85
    I128            shift and go to state 86
    ISIZE           shift and go to state 87
    U8              shift and go to state 88
    U16             shift and go to state 89
    U32             shift and go to state 90
    U64             shift and go to state 91
    U128            shift and go to state 92
    USIZE           shift and go to state 93
    F32             shift and go to state 94
    F64             shift and go to state 95

    some_data_type                 shift and go to state 136
    data_type                      shift and go to state 135
    signed_integer                 shift and go to state 78
    unsigned_integer               shift and go to state 79
    float_type                     shift and go to state 80

state 77

    (47) data_type -> CHAR .

    ASIG            reduce using rule 47 (data_type -> CHAR .)
    COMMA           reduce using rule 47 (data_type -> CHAR .)
    RPAREN          reduce using rule 47 (data_type -> CHAR .)
    RCORCH          reduce using rule 47 (data_type -> CHAR .)


state 78

    (48) data_type -> signed_integer .

    ASIG            reduce using rule 48 (data_type -> signed_integer .)
    COMMA           reduce using rule 48 (data_type -> signed_integer .)
    RPAREN          reduce using rule 48 (data_type -> signed_integer .)
    RCORCH          reduce using rule 48 (data_type -> signed_integer .)


state 79

    (49) data_type -> unsigned_integer .

    ASIG            reduce using rule 49 (data_type -> unsigned_integer .)
    COMMA           reduce using rule 49 (data_type -> unsigned_integer .)
    RPAREN          reduce using rule 49 (data_type -> unsigned_integer .)
    RCORCH          reduce using rule 49 (data_type -> unsigned_integer .)


state 80

    (50) data_type -> float_type .

    ASIG            reduce using rule 50 (data_type -> float_type .)
    COMMA           reduce using rule 50 (data_type -> float_type .)
    RPAREN          reduce using rule 50 (data_type -> float_type .)
    RCORCH          reduce using rule 50 (data_type -> float_type .)


state 81

    (51) data_type -> BOOL .

    ASIG            reduce using rule 51 (data_type -> BOOL .)
    COMMA           reduce using rule 51 (data_type -> BOOL .)
    RPAREN          reduce using rule 51 (data_type -> BOOL .)
    RCORCH          reduce using rule 51 (data_type -> BOOL .)


state 82

    (52) signed_integer -> I8 .

    ASIG            reduce using rule 52 (signed_integer -> I8 .)
    COMMA           reduce using rule 52 (signed_integer -> I8 .)
    RPAREN          reduce using rule 52 (signed_integer -> I8 .)
    RCORCH          reduce using rule 52 (signed_integer -> I8 .)


state 83

    (53) signed_integer -> I16 .

    ASIG            reduce using rule 53 (signed_integer -> I16 .)
    COMMA           reduce using rule 53 (signed_integer -> I16 .)
    RPAREN          reduce using rule 53 (signed_integer -> I16 .)
    RCORCH          reduce using rule 53 (signed_integer -> I16 .)


state 84

    (54) signed_integer -> I32 .

    ASIG            reduce using rule 54 (signed_integer -> I32 .)
    COMMA           reduce using rule 54 (signed_integer -> I32 .)
    RPAREN          reduce using rule 54 (signed_integer -> I32 .)
    RCORCH          reduce using rule 54 (signed_integer -> I32 .)


state 85

    (55) signed_integer -> I64 .

    ASIG            reduce using rule 55 (signed_integer -> I64 .)
    COMMA           reduce using rule 55 (signed_integer -> I64 .)
    RPAREN          reduce using rule 55 (signed_integer -> I64 .)
    RCORCH          reduce using rule 55 (signed_integer -> I64 .)


state 86

    (56) signed_integer -> I128 .

    ASIG            reduce using rule 56 (signed_integer -> I128 .)
    COMMA           reduce using rule 56 (signed_integer -> I128 .)
    RPAREN          reduce using rule 56 (signed_integer -> I128 .)
    RCORCH          reduce using rule 56 (signed_integer -> I128 .)


state 87

    (57) signed_integer -> ISIZE .

    ASIG            reduce using rule 57 (signed_integer -> ISIZE .)
    COMMA           reduce using rule 57 (signed_integer -> ISIZE .)
    RPAREN          reduce using rule 57 (signed_integer -> ISIZE .)
    RCORCH          reduce using rule 57 (signed_integer -> ISIZE .)


state 88

    (58) unsigned_integer -> U8 .

    ASIG            reduce using rule 58 (unsigned_integer -> U8 .)
    COMMA           reduce using rule 58 (unsigned_integer -> U8 .)
    RPAREN          reduce using rule 58 (unsigned_integer -> U8 .)
    RCORCH          reduce using rule 58 (unsigned_integer -> U8 .)


state 89

    (59) unsigned_integer -> U16 .

    ASIG            reduce using rule 59 (unsigned_integer -> U16 .)
    COMMA           reduce using rule 59 (unsigned_integer -> U16 .)
    RPAREN          reduce using rule 59 (unsigned_integer -> U16 .)
    RCORCH          reduce using rule 59 (unsigned_integer -> U16 .)


state 90

    (60) unsigned_integer -> U32 .

    ASIG            reduce using rule 60 (unsigned_integer -> U32 .)
    COMMA           reduce using rule 60 (unsigned_integer -> U32 .)
    RPAREN          reduce using rule 60 (unsigned_integer -> U32 .)
    RCORCH          reduce using rule 60 (unsigned_integer -> U32 .)


state 91

    (61) unsigned_integer -> U64 .

    ASIG            reduce using rule 61 (unsigned_integer -> U64 .)
    COMMA           reduce using rule 61 (unsigned_integer -> U64 .)
    RPAREN          reduce using rule 61 (unsigned_integer -> U64 .)
    RCORCH          reduce using rule 61 (unsigned_integer -> U64 .)


state 92

    (62) unsigned_integer -> U128 .

    ASIG            reduce using rule 62 (unsigned_integer -> U128 .)
    COMMA           reduce using rule 62 (unsigned_integer -> U128 .)
    RPAREN          reduce using rule 62 (unsigned_integer -> U128 .)
    RCORCH          reduce using rule 62 (unsigned_integer -> U128 .)


state 93

    (63) unsigned_integer -> USIZE .

    ASIG            reduce using rule 63 (unsigned_integer -> USIZE .)
    COMMA           reduce using rule 63 (unsigned_integer -> USIZE .)
    RPAREN          reduce using rule 63 (unsigned_integer -> USIZE .)
    RCORCH          reduce using rule 63 (unsigned_integer -> USIZE .)


state 94

    (64) float_type -> F32 .

    ASIG            reduce using rule 64 (float_type -> F32 .)
    COMMA           reduce using rule 64 (float_type -> F32 .)
    RPAREN          reduce using rule 64 (float_type -> F32 .)
    RCORCH          reduce using rule 64 (float_type -> F32 .)


state 95

    (65) float_type -> F64 .

    ASIG            reduce using rule 65 (float_type -> F64 .)
    COMMA           reduce using rule 65 (float_type -> F64 .)
    RPAREN          reduce using rule 65 (float_type -> F64 .)
    RCORCH          reduce using rule 65 (float_type -> F64 .)


state 96

    (4) asignacion -> LET MUT IDENTIFIER ASIG . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 137
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 97

    (6) asignacion -> LET MUT IDENTIFIER COLON . asig_data_type ASIG valor
    (44) asig_data_type -> . data_type
    (45) asig_data_type -> . LPAREN some_data_type RPAREN
    (46) asig_data_type -> . LCORCH some_data_type RCORCH
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    LPAREN          shift and go to state 75
    LCORCH          shift and go to state 76
    CHAR            shift and go to state 77
    BOOL            shift and go to state 81
    I8              shift and go to state 82
    I16             shift and go to state 83
    I32             shift and go to state 84
    I64             shift and go to state 85
    I128            shift and go to state 86
    ISIZE           shift and go to state 87
    U8              shift and go to state 88
    U16             shift and go to state 89
    U32             shift and go to state 90
    U64             shift and go to state 91
    U128            shift and go to state 92
    USIZE           shift and go to state 93
    F32             shift and go to state 94
    F64             shift and go to state 95

    asig_data_type                 shift and go to state 138
    data_type                      shift and go to state 74
    signed_integer                 shift and go to state 78
    unsigned_integer               shift and go to state 79
    float_type                     shift and go to state 80

state 98

    (38) impresion -> PRINTLN EXCLAMATION LPAREN valor . RPAREN
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    RPAREN          shift and go to state 139
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 99

    (40) parameters -> IDENTIFIER . COLON asig_data_type
    (41) parameters -> IDENTIFIER . COLON asig_data_type COMMA parameters

    COLON           shift and go to state 140


state 100

    (39) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN LLLAVE programa RLLAVE

    RPAREN          shift and go to state 141


state 101

    (42) parameters -> vacio .

    RPAREN          reduce using rule 42 (parameters -> vacio .)


state 102

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON . DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 142


state 103

    (71) valores -> valor COMMA valores .

    RCORCH          reduce using rule 71 (valores -> valor COMMA valores .)


state 104

    (78) operacion -> valor PLUS valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 78 (operacion -> valor PLUS valor .)
    RCORCH          reduce using rule 78 (operacion -> valor PLUS valor .)
    EQ              reduce using rule 78 (operacion -> valor PLUS valor .)
    NEQ             reduce using rule 78 (operacion -> valor PLUS valor .)
    GEQ             reduce using rule 78 (operacion -> valor PLUS valor .)
    LEQ             reduce using rule 78 (operacion -> valor PLUS valor .)
    RIGHTARROW      reduce using rule 78 (operacion -> valor PLUS valor .)
    LEFTARROW       reduce using rule 78 (operacion -> valor PLUS valor .)
    SEMICOLON       reduce using rule 78 (operacion -> valor PLUS valor .)
    RPAREN          reduce using rule 78 (operacion -> valor PLUS valor .)
    LLLAVE          reduce using rule 78 (operacion -> valor PLUS valor .)
    AND             reduce using rule 78 (operacion -> valor PLUS valor .)
    OR              reduce using rule 78 (operacion -> valor PLUS valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53

  ! PLUS            [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! MINUS           [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! TIMES           [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! DIVIDE          [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! MOD             [ reduce using rule 78 (operacion -> valor PLUS valor .) ]
  ! INTD            [ reduce using rule 78 (operacion -> valor PLUS valor .) ]


state 105

    (79) operacion -> valor MINUS valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 79 (operacion -> valor MINUS valor .)
    RCORCH          reduce using rule 79 (operacion -> valor MINUS valor .)
    EQ              reduce using rule 79 (operacion -> valor MINUS valor .)
    NEQ             reduce using rule 79 (operacion -> valor MINUS valor .)
    GEQ             reduce using rule 79 (operacion -> valor MINUS valor .)
    LEQ             reduce using rule 79 (operacion -> valor MINUS valor .)
    RIGHTARROW      reduce using rule 79 (operacion -> valor MINUS valor .)
    LEFTARROW       reduce using rule 79 (operacion -> valor MINUS valor .)
    SEMICOLON       reduce using rule 79 (operacion -> valor MINUS valor .)
    RPAREN          reduce using rule 79 (operacion -> valor MINUS valor .)
    LLLAVE          reduce using rule 79 (operacion -> valor MINUS valor .)
    AND             reduce using rule 79 (operacion -> valor MINUS valor .)
    OR              reduce using rule 79 (operacion -> valor MINUS valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53

  ! PLUS            [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! MINUS           [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! TIMES           [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! DIVIDE          [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! MOD             [ reduce using rule 79 (operacion -> valor MINUS valor .) ]
  ! INTD            [ reduce using rule 79 (operacion -> valor MINUS valor .) ]


state 106

    (80) operacion -> valor TIMES valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 80 (operacion -> valor TIMES valor .)
    RCORCH          reduce using rule 80 (operacion -> valor TIMES valor .)
    EQ              reduce using rule 80 (operacion -> valor TIMES valor .)
    NEQ             reduce using rule 80 (operacion -> valor TIMES valor .)
    GEQ             reduce using rule 80 (operacion -> valor TIMES valor .)
    LEQ             reduce using rule 80 (operacion -> valor TIMES valor .)
    RIGHTARROW      reduce using rule 80 (operacion -> valor TIMES valor .)
    LEFTARROW       reduce using rule 80 (operacion -> valor TIMES valor .)
    SEMICOLON       reduce using rule 80 (operacion -> valor TIMES valor .)
    RPAREN          reduce using rule 80 (operacion -> valor TIMES valor .)
    LLLAVE          reduce using rule 80 (operacion -> valor TIMES valor .)
    AND             reduce using rule 80 (operacion -> valor TIMES valor .)
    OR              reduce using rule 80 (operacion -> valor TIMES valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53

  ! PLUS            [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! MINUS           [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! TIMES           [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! DIVIDE          [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! MOD             [ reduce using rule 80 (operacion -> valor TIMES valor .) ]
  ! INTD            [ reduce using rule 80 (operacion -> valor TIMES valor .) ]


state 107

    (81) operacion -> valor DIVIDE valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 81 (operacion -> valor DIVIDE valor .)
    RCORCH          reduce using rule 81 (operacion -> valor DIVIDE valor .)
    EQ              reduce using rule 81 (operacion -> valor DIVIDE valor .)
    NEQ             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    GEQ             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    LEQ             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    RIGHTARROW      reduce using rule 81 (operacion -> valor DIVIDE valor .)
    LEFTARROW       reduce using rule 81 (operacion -> valor DIVIDE valor .)
    SEMICOLON       reduce using rule 81 (operacion -> valor DIVIDE valor .)
    RPAREN          reduce using rule 81 (operacion -> valor DIVIDE valor .)
    LLLAVE          reduce using rule 81 (operacion -> valor DIVIDE valor .)
    AND             reduce using rule 81 (operacion -> valor DIVIDE valor .)
    OR              reduce using rule 81 (operacion -> valor DIVIDE valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53

  ! PLUS            [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! MINUS           [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! TIMES           [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! DIVIDE          [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! MOD             [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]
  ! INTD            [ reduce using rule 81 (operacion -> valor DIVIDE valor .) ]


state 108

    (82) operacion -> valor MOD valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 82 (operacion -> valor MOD valor .)
    RCORCH          reduce using rule 82 (operacion -> valor MOD valor .)
    EQ              reduce using rule 82 (operacion -> valor MOD valor .)
    NEQ             reduce using rule 82 (operacion -> valor MOD valor .)
    GEQ             reduce using rule 82 (operacion -> valor MOD valor .)
    LEQ             reduce using rule 82 (operacion -> valor MOD valor .)
    RIGHTARROW      reduce using rule 82 (operacion -> valor MOD valor .)
    LEFTARROW       reduce using rule 82 (operacion -> valor MOD valor .)
    SEMICOLON       reduce using rule 82 (operacion -> valor MOD valor .)
    RPAREN          reduce using rule 82 (operacion -> valor MOD valor .)
    LLLAVE          reduce using rule 82 (operacion -> valor MOD valor .)
    AND             reduce using rule 82 (operacion -> valor MOD valor .)
    OR              reduce using rule 82 (operacion -> valor MOD valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53

  ! PLUS            [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! MINUS           [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! TIMES           [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! DIVIDE          [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! MOD             [ reduce using rule 82 (operacion -> valor MOD valor .) ]
  ! INTD            [ reduce using rule 82 (operacion -> valor MOD valor .) ]


state 109

    (83) operacion -> valor INTD valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 83 (operacion -> valor INTD valor .)
    RCORCH          reduce using rule 83 (operacion -> valor INTD valor .)
    EQ              reduce using rule 83 (operacion -> valor INTD valor .)
    NEQ             reduce using rule 83 (operacion -> valor INTD valor .)
    GEQ             reduce using rule 83 (operacion -> valor INTD valor .)
    LEQ             reduce using rule 83 (operacion -> valor INTD valor .)
    RIGHTARROW      reduce using rule 83 (operacion -> valor INTD valor .)
    LEFTARROW       reduce using rule 83 (operacion -> valor INTD valor .)
    SEMICOLON       reduce using rule 83 (operacion -> valor INTD valor .)
    RPAREN          reduce using rule 83 (operacion -> valor INTD valor .)
    LLLAVE          reduce using rule 83 (operacion -> valor INTD valor .)
    AND             reduce using rule 83 (operacion -> valor INTD valor .)
    OR              reduce using rule 83 (operacion -> valor INTD valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53

  ! PLUS            [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! MINUS           [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! TIMES           [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! DIVIDE          [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! MOD             [ reduce using rule 83 (operacion -> valor INTD valor .) ]
  ! INTD            [ reduce using rule 83 (operacion -> valor INTD valor .) ]


state 110

    (84) indexacion -> IDENTIFIER LCORCH INTEGER . RCORCH

    RCORCH          shift and go to state 143


state 111

    (76) condicional -> IF comparacion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 144


state 112

    (74) proposicion -> comparacion . conector proposicion
    (75) proposicion -> comparacion .
    (72) conector -> . AND
    (73) conector -> . OR

    LLLAVE          reduce using rule 75 (proposicion -> comparacion .)
    AND             shift and go to state 57
    OR              shift and go to state 58

    conector                       shift and go to state 56

state 113

    (74) proposicion -> comparacion conector proposicion .

    LLLAVE          reduce using rule 74 (proposicion -> comparacion conector proposicion .)


state 114

    (77) condicional -> IF proposicion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 145


state 115

    (7) comparacion -> IDENTIFIER LEQ IDENTIFIER .
    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

  ! reduce/reduce conflict for LLLAVE resolved using rule 7 (comparacion -> IDENTIFIER LEQ IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 7 (comparacion -> IDENTIFIER LEQ IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 7 (comparacion -> IDENTIFIER LEQ IDENTIFIER .)
    LLLAVE          reduce using rule 7 (comparacion -> IDENTIFIER LEQ IDENTIFIER .)
    AND             reduce using rule 7 (comparacion -> IDENTIFIER LEQ IDENTIFIER .)
    OR              reduce using rule 7 (comparacion -> IDENTIFIER LEQ IDENTIFIER .)
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54

  ! LLLAVE          [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 27 (valor -> IDENTIFIER .) ]


state 116

    (16) comparacion -> IDENTIFIER LEQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 16 (comparacion -> IDENTIFIER LEQ valor .)
    AND             reduce using rule 16 (comparacion -> IDENTIFIER LEQ valor .)
    OR              reduce using rule 16 (comparacion -> IDENTIFIER LEQ valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 117

    (8) comparacion -> IDENTIFIER GEQ IDENTIFIER .
    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

  ! reduce/reduce conflict for LLLAVE resolved using rule 8 (comparacion -> IDENTIFIER GEQ IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 8 (comparacion -> IDENTIFIER GEQ IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 8 (comparacion -> IDENTIFIER GEQ IDENTIFIER .)
    LLLAVE          reduce using rule 8 (comparacion -> IDENTIFIER GEQ IDENTIFIER .)
    AND             reduce using rule 8 (comparacion -> IDENTIFIER GEQ IDENTIFIER .)
    OR              reduce using rule 8 (comparacion -> IDENTIFIER GEQ IDENTIFIER .)
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54

  ! LLLAVE          [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 27 (valor -> IDENTIFIER .) ]


state 118

    (15) comparacion -> IDENTIFIER GEQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 15 (comparacion -> IDENTIFIER GEQ valor .)
    AND             reduce using rule 15 (comparacion -> IDENTIFIER GEQ valor .)
    OR              reduce using rule 15 (comparacion -> IDENTIFIER GEQ valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 119

    (9) comparacion -> IDENTIFIER EQ IDENTIFIER .
    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

  ! reduce/reduce conflict for LLLAVE resolved using rule 9 (comparacion -> IDENTIFIER EQ IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 9 (comparacion -> IDENTIFIER EQ IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 9 (comparacion -> IDENTIFIER EQ IDENTIFIER .)
    LLLAVE          reduce using rule 9 (comparacion -> IDENTIFIER EQ IDENTIFIER .)
    AND             reduce using rule 9 (comparacion -> IDENTIFIER EQ IDENTIFIER .)
    OR              reduce using rule 9 (comparacion -> IDENTIFIER EQ IDENTIFIER .)
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54

  ! LLLAVE          [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 27 (valor -> IDENTIFIER .) ]


state 120

    (13) comparacion -> IDENTIFIER EQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 13 (comparacion -> IDENTIFIER EQ valor .)
    AND             reduce using rule 13 (comparacion -> IDENTIFIER EQ valor .)
    OR              reduce using rule 13 (comparacion -> IDENTIFIER EQ valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 121

    (10) comparacion -> IDENTIFIER NEQ IDENTIFIER .
    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

  ! reduce/reduce conflict for LLLAVE resolved using rule 10 (comparacion -> IDENTIFIER NEQ IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 10 (comparacion -> IDENTIFIER NEQ IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 10 (comparacion -> IDENTIFIER NEQ IDENTIFIER .)
    LLLAVE          reduce using rule 10 (comparacion -> IDENTIFIER NEQ IDENTIFIER .)
    AND             reduce using rule 10 (comparacion -> IDENTIFIER NEQ IDENTIFIER .)
    OR              reduce using rule 10 (comparacion -> IDENTIFIER NEQ IDENTIFIER .)
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54

  ! LLLAVE          [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 27 (valor -> IDENTIFIER .) ]


state 122

    (14) comparacion -> IDENTIFIER NEQ valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 14 (comparacion -> IDENTIFIER NEQ valor .)
    AND             reduce using rule 14 (comparacion -> IDENTIFIER NEQ valor .)
    OR              reduce using rule 14 (comparacion -> IDENTIFIER NEQ valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 123

    (11) comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER .
    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

  ! reduce/reduce conflict for LLLAVE resolved using rule 11 (comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 11 (comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 11 (comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER .)
    LLLAVE          reduce using rule 11 (comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER .)
    AND             reduce using rule 11 (comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER .)
    OR              reduce using rule 11 (comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER .)
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54

  ! LLLAVE          [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 27 (valor -> IDENTIFIER .) ]


state 124

    (17) comparacion -> IDENTIFIER RIGHTARROW valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 17 (comparacion -> IDENTIFIER RIGHTARROW valor .)
    AND             reduce using rule 17 (comparacion -> IDENTIFIER RIGHTARROW valor .)
    OR              reduce using rule 17 (comparacion -> IDENTIFIER RIGHTARROW valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 125

    (12) comparacion -> IDENTIFIER LEFTARROW IDENTIFIER .
    (27) valor -> IDENTIFIER .
    (84) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

  ! reduce/reduce conflict for LLLAVE resolved using rule 12 (comparacion -> IDENTIFIER LEFTARROW IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 12 (comparacion -> IDENTIFIER LEFTARROW IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 12 (comparacion -> IDENTIFIER LEFTARROW IDENTIFIER .)
    LLLAVE          reduce using rule 12 (comparacion -> IDENTIFIER LEFTARROW IDENTIFIER .)
    AND             reduce using rule 12 (comparacion -> IDENTIFIER LEFTARROW IDENTIFIER .)
    OR              reduce using rule 12 (comparacion -> IDENTIFIER LEFTARROW IDENTIFIER .)
    PLUS            reduce using rule 27 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 27 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 27 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (valor -> IDENTIFIER .)
    MOD             reduce using rule 27 (valor -> IDENTIFIER .)
    INTD            reduce using rule 27 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 54

  ! LLLAVE          [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (valor -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 27 (valor -> IDENTIFIER .) ]


state 126

    (18) comparacion -> IDENTIFIER LEFTARROW valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    LLLAVE          reduce using rule 18 (comparacion -> IDENTIFIER LEFTARROW valor .)
    AND             reduce using rule 18 (comparacion -> IDENTIFIER LEFTARROW valor .)
    OR              reduce using rule 18 (comparacion -> IDENTIFIER LEFTARROW valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 127

    (19) comparacion -> valor EQ IDENTIFIER .

    LLLAVE          reduce using rule 19 (comparacion -> valor EQ IDENTIFIER .)
    AND             reduce using rule 19 (comparacion -> valor EQ IDENTIFIER .)
    OR              reduce using rule 19 (comparacion -> valor EQ IDENTIFIER .)


state 128

    (20) comparacion -> valor NEQ IDENTIFIER .

    LLLAVE          reduce using rule 20 (comparacion -> valor NEQ IDENTIFIER .)
    AND             reduce using rule 20 (comparacion -> valor NEQ IDENTIFIER .)
    OR              reduce using rule 20 (comparacion -> valor NEQ IDENTIFIER .)


state 129

    (21) comparacion -> valor GEQ IDENTIFIER .

    LLLAVE          reduce using rule 21 (comparacion -> valor GEQ IDENTIFIER .)
    AND             reduce using rule 21 (comparacion -> valor GEQ IDENTIFIER .)
    OR              reduce using rule 21 (comparacion -> valor GEQ IDENTIFIER .)


state 130

    (22) comparacion -> valor LEQ IDENTIFIER .

    LLLAVE          reduce using rule 22 (comparacion -> valor LEQ IDENTIFIER .)
    AND             reduce using rule 22 (comparacion -> valor LEQ IDENTIFIER .)
    OR              reduce using rule 22 (comparacion -> valor LEQ IDENTIFIER .)


state 131

    (23) comparacion -> valor RIGHTARROW IDENTIFIER .

    LLLAVE          reduce using rule 23 (comparacion -> valor RIGHTARROW IDENTIFIER .)
    AND             reduce using rule 23 (comparacion -> valor RIGHTARROW IDENTIFIER .)
    OR              reduce using rule 23 (comparacion -> valor RIGHTARROW IDENTIFIER .)


state 132

    (24) comparacion -> valor LEFTARROW IDENTIFIER .

    LLLAVE          reduce using rule 24 (comparacion -> valor LEFTARROW IDENTIFIER .)
    AND             reduce using rule 24 (comparacion -> valor LEFTARROW IDENTIFIER .)
    OR              reduce using rule 24 (comparacion -> valor LEFTARROW IDENTIFIER .)


state 133

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type ASIG . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 146
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 134

    (45) asig_data_type -> LPAREN some_data_type . RPAREN

    RPAREN          shift and go to state 147


state 135

    (66) some_data_type -> data_type .
    (67) some_data_type -> data_type . COMMA some_data_type

    RPAREN          reduce using rule 66 (some_data_type -> data_type .)
    RCORCH          reduce using rule 66 (some_data_type -> data_type .)
    COMMA           shift and go to state 148


state 136

    (46) asig_data_type -> LCORCH some_data_type . RCORCH

    RCORCH          shift and go to state 149


state 137

    (4) asignacion -> LET MUT IDENTIFIER ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 4 (asignacion -> LET MUT IDENTIFIER ASIG valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 138

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type . ASIG valor

    ASIG            shift and go to state 150


state 139

    (38) impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 38 (impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .)


state 140

    (40) parameters -> IDENTIFIER COLON . asig_data_type
    (41) parameters -> IDENTIFIER COLON . asig_data_type COMMA parameters
    (44) asig_data_type -> . data_type
    (45) asig_data_type -> . LPAREN some_data_type RPAREN
    (46) asig_data_type -> . LCORCH some_data_type RCORCH
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    LPAREN          shift and go to state 75
    LCORCH          shift and go to state 76
    CHAR            shift and go to state 77
    BOOL            shift and go to state 81
    I8              shift and go to state 82
    I16             shift and go to state 83
    I32             shift and go to state 84
    I64             shift and go to state 85
    I128            shift and go to state 86
    ISIZE           shift and go to state 87
    U8              shift and go to state 88
    U16             shift and go to state 89
    U32             shift and go to state 90
    U64             shift and go to state 91
    U128            shift and go to state 92
    USIZE           shift and go to state 93
    F32             shift and go to state 94
    F64             shift and go to state 95

    asig_data_type                 shift and go to state 151
    data_type                      shift and go to state 74
    signed_integer                 shift and go to state 78
    unsigned_integer               shift and go to state 79
    float_type                     shift and go to state 80

state 141

    (39) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 152


state 142

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT . STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    STDIN           shift and go to state 153


state 143

    (84) indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .

    COMMA           reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    PLUS            reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    MINUS           reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    TIMES           reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    DIVIDE          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    MOD             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    INTD            reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RCORCH          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    EQ              reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    NEQ             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    GEQ             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEQ             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RIGHTARROW      reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEFTARROW       reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    SEMICOLON       reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RPAREN          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LLLAVE          reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    AND             reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    OR              reduce using rule 84 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)


state 144

    (76) condicional -> IF comparacion LLLAVE programa RLLAVE .

    SEMICOLON       reduce using rule 76 (condicional -> IF comparacion LLLAVE programa RLLAVE .)


state 145

    (77) condicional -> IF proposicion LLLAVE programa RLLAVE .

    SEMICOLON       reduce using rule 77 (condicional -> IF proposicion LLLAVE programa RLLAVE .)


state 146

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 5 (asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 147

    (45) asig_data_type -> LPAREN some_data_type RPAREN .

    ASIG            reduce using rule 45 (asig_data_type -> LPAREN some_data_type RPAREN .)
    COMMA           reduce using rule 45 (asig_data_type -> LPAREN some_data_type RPAREN .)
    RPAREN          reduce using rule 45 (asig_data_type -> LPAREN some_data_type RPAREN .)


state 148

    (67) some_data_type -> data_type COMMA . some_data_type
    (66) some_data_type -> . data_type
    (67) some_data_type -> . data_type COMMA some_data_type
    (47) data_type -> . CHAR
    (48) data_type -> . signed_integer
    (49) data_type -> . unsigned_integer
    (50) data_type -> . float_type
    (51) data_type -> . BOOL
    (52) signed_integer -> . I8
    (53) signed_integer -> . I16
    (54) signed_integer -> . I32
    (55) signed_integer -> . I64
    (56) signed_integer -> . I128
    (57) signed_integer -> . ISIZE
    (58) unsigned_integer -> . U8
    (59) unsigned_integer -> . U16
    (60) unsigned_integer -> . U32
    (61) unsigned_integer -> . U64
    (62) unsigned_integer -> . U128
    (63) unsigned_integer -> . USIZE
    (64) float_type -> . F32
    (65) float_type -> . F64

    CHAR            shift and go to state 77
    BOOL            shift and go to state 81
    I8              shift and go to state 82
    I16             shift and go to state 83
    I32             shift and go to state 84
    I64             shift and go to state 85
    I128            shift and go to state 86
    ISIZE           shift and go to state 87
    U8              shift and go to state 88
    U16             shift and go to state 89
    U32             shift and go to state 90
    U64             shift and go to state 91
    U128            shift and go to state 92
    USIZE           shift and go to state 93
    F32             shift and go to state 94
    F64             shift and go to state 95

    data_type                      shift and go to state 135
    some_data_type                 shift and go to state 154
    signed_integer                 shift and go to state 78
    unsigned_integer               shift and go to state 79
    float_type                     shift and go to state 80

state 149

    (46) asig_data_type -> LCORCH some_data_type RCORCH .

    ASIG            reduce using rule 46 (asig_data_type -> LCORCH some_data_type RCORCH .)
    COMMA           reduce using rule 46 (asig_data_type -> LCORCH some_data_type RCORCH .)
    RPAREN          reduce using rule 46 (asig_data_type -> LCORCH some_data_type RCORCH .)


state 150

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG . valor
    (25) valor -> . INTEGER
    (26) valor -> . FLOAT
    (27) valor -> . IDENTIFIER
    (28) valor -> . operacion
    (29) valor -> . indexacion
    (30) valor -> . arreglos
    (78) operacion -> . valor PLUS valor
    (79) operacion -> . valor MINUS valor
    (80) operacion -> . valor TIMES valor
    (81) operacion -> . valor DIVIDE valor
    (82) operacion -> . valor MOD valor
    (83) operacion -> . valor INTD valor
    (84) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (69) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    LCORCH          shift and go to state 13

    valor                          shift and go to state 155
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 151

    (40) parameters -> IDENTIFIER COLON asig_data_type .
    (41) parameters -> IDENTIFIER COLON asig_data_type . COMMA parameters

    RPAREN          reduce using rule 40 (parameters -> IDENTIFIER COLON asig_data_type .)
    COMMA           shift and go to state 156


state 152

    (39) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (32) sentencias -> . asignacion SEMICOLON
    (33) sentencias -> . impresion SEMICOLON
    (34) sentencias -> . funcion SEMICOLON
    (35) sentencias -> . ingreso_datos SEMICOLON
    (36) sentencias -> . arreglos SEMICOLON
    (37) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (38) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (39) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (43) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (69) arreglos -> . LCORCH valores RCORCH
    (68) control_structure -> . condicional
    (76) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (77) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    programa                       shift and go to state 157
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 153

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN . LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 158


state 154

    (67) some_data_type -> data_type COMMA some_data_type .

    RPAREN          reduce using rule 67 (some_data_type -> data_type COMMA some_data_type .)
    RCORCH          reduce using rule 67 (some_data_type -> data_type COMMA some_data_type .)


state 155

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor .
    (78) operacion -> valor . PLUS valor
    (79) operacion -> valor . MINUS valor
    (80) operacion -> valor . TIMES valor
    (81) operacion -> valor . DIVIDE valor
    (82) operacion -> valor . MOD valor
    (83) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 6 (asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MOD             shift and go to state 52
    INTD            shift and go to state 53


state 156

    (41) parameters -> IDENTIFIER COLON asig_data_type COMMA . parameters
    (40) parameters -> . IDENTIFIER COLON asig_data_type
    (41) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (42) parameters -> . vacio
    (31) vacio -> .

    IDENTIFIER      shift and go to state 99
    RPAREN          reduce using rule 31 (vacio -> .)

    parameters                     shift and go to state 159
    vacio                          shift and go to state 101

state 157

    (39) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 160


state 158

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN . RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    RPAREN          shift and go to state 161


state 159

    (41) parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .

    RPAREN          reduce using rule 41 (parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .)


state 160

    (39) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .

    SEMICOLON       reduce using rule 39 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)


state 161

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN . DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 162


state 162

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT . READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    READLINE        shift and go to state 163


state 163

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE . LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 164


state 164

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN . REFERENCE MUT IDENTIFIER RPAREN

    REFERENCE       shift and go to state 165


state 165

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE . MUT IDENTIFIER RPAREN

    MUT             shift and go to state 166


state 166

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 167


state 167

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER . RPAREN

    RPAREN          shift and go to state 168


state 168

    (43) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .

    SEMICOLON       reduce using rule 43 (ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LLLAVE in state 36 resolved as shift
WARNING: shift/reduce conflict for EQ in state 38 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 38 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 38 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 38 resolved as shift
WARNING: shift/reduce conflict for RIGHTARROW in state 38 resolved as shift
WARNING: shift/reduce conflict for LEFTARROW in state 38 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for MOD in state 104 resolved as shift
WARNING: shift/reduce conflict for INTD in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MOD in state 105 resolved as shift
WARNING: shift/reduce conflict for INTD in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for MOD in state 106 resolved as shift
WARNING: shift/reduce conflict for INTD in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for MOD in state 107 resolved as shift
WARNING: shift/reduce conflict for INTD in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for MOD in state 108 resolved as shift
WARNING: shift/reduce conflict for INTD in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MOD in state 109 resolved as shift
WARNING: shift/reduce conflict for INTD in state 109 resolved as shift
WARNING: reduce/reduce conflict in state 115 resolved using rule (comparacion -> IDENTIFIER LEQ IDENTIFIER)
WARNING: rejected rule (valor -> IDENTIFIER) in state 115
WARNING: reduce/reduce conflict in state 117 resolved using rule (comparacion -> IDENTIFIER GEQ IDENTIFIER)
WARNING: rejected rule (valor -> IDENTIFIER) in state 117
WARNING: reduce/reduce conflict in state 119 resolved using rule (comparacion -> IDENTIFIER EQ IDENTIFIER)
WARNING: rejected rule (valor -> IDENTIFIER) in state 119
WARNING: reduce/reduce conflict in state 121 resolved using rule (comparacion -> IDENTIFIER NEQ IDENTIFIER)
WARNING: rejected rule (valor -> IDENTIFIER) in state 121
WARNING: reduce/reduce conflict in state 123 resolved using rule (comparacion -> IDENTIFIER RIGHTARROW IDENTIFIER)
WARNING: rejected rule (valor -> IDENTIFIER) in state 123
WARNING: reduce/reduce conflict in state 125 resolved using rule (comparacion -> IDENTIFIER LEFTARROW IDENTIFIER)
WARNING: rejected rule (valor -> IDENTIFIER) in state 125
