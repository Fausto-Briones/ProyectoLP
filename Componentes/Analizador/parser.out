Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHARACTER
    DOUBLE_QUOTATION_MARK
    ELSE
    FOR
    FROM
    IMPL
    IN
    MATCH
    NOT
    QUOTATION_MARK
    RAND
    SELF
    STRUCT
    WHILE

Grammar

Rule 0     S' -> codigoRust
Rule 1     codigoRust -> functions fnmain functions
Rule 2     codigoRust -> functions fnmain
Rule 3     codigoRust -> fnmain functions
Rule 4     codigoRust -> fnmain
Rule 5     functions -> funcion
Rule 6     functions -> funcion functions
Rule 7     programa -> sentencias
Rule 8     programa -> sentencias programa
Rule 9     asignacion_variable -> LET IDENTIFIER ASIG valor
Rule 10    asignacion_variable -> LET MUT IDENTIFIER ASIG valor
Rule 11    asignacion_variable -> LET IDENTIFIER COLON asignacion
Rule 12    asignacion_variable -> LET MUT IDENTIFIER COLON asignacion
Rule 13    declaracion_variable -> LET IDENTIFIER
Rule 14    declaracion_variable -> LET MUT IDENTIFIER
Rule 15    declaracion_variable -> LET IDENTIFIER COLON asig_data_type
Rule 16    declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type
Rule 17    asignacion -> string_asignacion
Rule 18    asignacion -> numero_asignacion
Rule 19    asignacion -> boolean_asignacion
Rule 20    asignacion -> lista_asignacion
Rule 21    asignacion -> tupla_asignacion
Rule 22    string_asignacion -> REFERENCE STR ASIG STRING
Rule 23    numero_asignacion -> signed_integer ASIG INTEGER
Rule 24    numero_asignacion -> signed_integer ASIG MINUS INTEGER
Rule 25    numero_asignacion -> unsigned_integer ASIG INTEGER
Rule 26    numero_asignacion -> float_type ASIG FLOAT
Rule 27    numero_asignacion -> float_type ASIG MINUS FLOAT
Rule 28    boolean_asignacion -> BOOL ASIG TRUE
Rule 29    boolean_asignacion -> BOOL ASIG FALSE
Rule 30    lista_asignacion -> list_type ASIG arreglos
Rule 31    tupla_asignacion -> tuple_type ASIG tuplas
Rule 32    comparacion -> valor EQ valor
Rule 33    comparacion -> valor NEQ valor
Rule 34    comparacion -> valor GEQ valor
Rule 35    comparacion -> valor LEQ valor
Rule 36    comparacion -> valor RIGHTARROW valor
Rule 37    comparacion -> valor LEFTARROW valor
Rule 38    valor -> INTEGER
Rule 39    valor -> MINUS INTEGER
Rule 40    valor -> FLOAT
Rule 41    valor -> MINUS FLOAT
Rule 42    valor -> IDENTIFIER
Rule 43    valor -> operacion
Rule 44    valor -> indexacion
Rule 45    valor -> arreglos
Rule 46    valor -> STRING
Rule 47    valor -> booleanos
Rule 48    booleanos -> TRUE
Rule 49    booleanos -> FALSE
Rule 50    vacio -> <empty>
Rule 51    sentencias -> asignacion_variable SEMICOLON
Rule 52    sentencias -> declaracion_variable SEMICOLON
Rule 53    sentencias -> impresion SEMICOLON
Rule 54    sentencias -> ingreso_datos SEMICOLON
Rule 55    sentencias -> arreglos SEMICOLON
Rule 56    sentencias -> control_structure
Rule 57    sentencias -> llamada SEMICOLON
Rule 58    impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN
Rule 59    impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
Rule 60    funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
Rule 61    funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
Rule 62    funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 63    funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 64    retorno -> RETURN valor SEMICOLON
Rule 65    parameters -> IDENTIFIER COLON asig_data_type
Rule 66    parameters -> IDENTIFIER COLON asig_data_type COMMA parameters
Rule 67    parameters -> vacio
Rule 68    ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
Rule 69    asig_data_type -> data_type
Rule 70    asig_data_type -> list_type
Rule 71    asig_data_type -> tuple_type
Rule 72    list_type -> LCORCH some_data_type RCORCH
Rule 73    tuple_type -> LPAREN some_data_type RPAREN
Rule 74    data_type -> CHAR
Rule 75    data_type -> REFERENCE STR
Rule 76    data_type -> signed_integer
Rule 77    data_type -> unsigned_integer
Rule 78    data_type -> float_type
Rule 79    data_type -> BOOL
Rule 80    signed_integer -> I8
Rule 81    signed_integer -> I16
Rule 82    signed_integer -> I32
Rule 83    signed_integer -> I64
Rule 84    signed_integer -> I128
Rule 85    signed_integer -> ISIZE
Rule 86    unsigned_integer -> U8
Rule 87    unsigned_integer -> U16
Rule 88    unsigned_integer -> U32
Rule 89    unsigned_integer -> U64
Rule 90    unsigned_integer -> U128
Rule 91    unsigned_integer -> USIZE
Rule 92    float_type -> F32
Rule 93    float_type -> F64
Rule 94    some_data_type -> data_type
Rule 95    some_data_type -> data_type COMMA some_data_type
Rule 96    control_structure -> condicional
Rule 97    arreglos -> LCORCH valores RCORCH
Rule 98    tuplas -> LPAREN valores RPAREN
Rule 99    valores -> valor
Rule 100   valores -> valor COMMA valores
Rule 101   conector -> AND
Rule 102   conector -> OR
Rule 103   proposicion -> comparacion conector proposicion
Rule 104   proposicion -> comparacion
Rule 105   condicional -> IF comparacion LLLAVE programa RLLAVE
Rule 106   condicional -> IF proposicion LLLAVE programa RLLAVE
Rule 107   numeric -> INTEGER
Rule 108   numeric -> FLOAT
Rule 109   numeric -> IDENTIFIER
Rule 110   cadena -> STRING
Rule 111   cadena -> IDENTIFIER
Rule 112   operacion -> numeric PLUS numeric
Rule 113   operacion -> numeric MINUS numeric
Rule 114   operacion -> numeric TIMES numeric
Rule 115   operacion -> numeric DIVIDE numeric
Rule 116   operacion -> numeric MOD numeric
Rule 117   operacion -> numeric INTD numeric
Rule 118   operacion -> cadena PLUS cadena
Rule 119   indexacion -> IDENTIFIER LCORCH INTEGER RCORCH
Rule 120   llamada -> IDENTIFIER LPAREN valores RPAREN
Rule 121   llamada -> IDENTIFIER LPAREN RPAREN
Rule 122   sentencias -> error
Rule 123   fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE

Terminals, with rules where they appear

AND                  : 101
ASIG                 : 9 10 22 23 24 25 26 27 28 29 30 31
BOOL                 : 28 29 79
CHAR                 : 74
CHARACTER            : 
COLON                : 11 12 15 16 65 66
COMMA                : 59 66 95 100
DIVIDE               : 115
DOT                  : 68 68
DOUBLE_COLON         : 68 68
DOUBLE_QUOTATION_MARK : 
ELSE                 : 
EQ                   : 32
EXCLAMATION          : 58 59
F32                  : 92
F64                  : 93
FALSE                : 29 49
FLOAT                : 26 27 40 41 108
FN                   : 60 61 62 63 123
FOR                  : 
FROM                 : 
GEQ                  : 34
I128                 : 84
I16                  : 81
I32                  : 82
I64                  : 83
I8                   : 80
IDENTIFIER           : 9 10 11 12 13 14 15 16 42 60 61 62 63 65 66 68 109 111 119 120 121
IF                   : 105 106
IMPL                 : 
IN                   : 
INTD                 : 117
INTEGER              : 23 24 25 38 39 107 119
IO                   : 68
ISIZE                : 85
LCORCH               : 72 97 119
LEFTARROW            : 37
LEQ                  : 35
LET                  : 9 10 11 12 13 14 15 16
LLLAVE               : 60 61 62 63 105 106 123
LPAREN               : 58 59 60 61 62 63 68 68 73 98 120 121 123
MAIN                 : 123
MATCH                : 
MINUS                : 24 27 39 41 62 63 113
MOD                  : 116
MUT                  : 10 12 14 16 68
NEQ                  : 33
NOT                  : 
OR                   : 102
PLUS                 : 112 118
PRINTLN              : 58 59
QUOTATION_MARK       : 
RAND                 : 
RCORCH               : 72 97 119
READLINE             : 68
REFERENCE            : 22 68 75
RETURN               : 64
RIGHTARROW           : 36 62 63
RLLAVE               : 60 61 62 63 105 106 123
RPAREN               : 58 59 60 61 62 63 68 68 73 98 120 121 123
SELF                 : 
SEMICOLON            : 51 52 53 54 55 57 64
STD                  : 68
STDIN                : 68
STR                  : 22 75
STRING               : 22 46 110
STRUCT               : 
TIMES                : 114
TRUE                 : 28 48
U128                 : 90
U16                  : 87
U32                  : 88
U64                  : 89
U8                   : 86
USIZE                : 91
WHILE                : 
error                : 122

Nonterminals, with rules where they appear

arreglos             : 30 45 55
asig_data_type       : 15 16 65 66
asignacion           : 11 12
asignacion_variable  : 51
boolean_asignacion   : 19
booleanos            : 47
cadena               : 118 118
codigoRust           : 0
comparacion          : 103 104 105
condicional          : 96
conector             : 103
control_structure    : 56
data_type            : 62 63 69 94 95
declaracion_variable : 52
float_type           : 26 27 78
fnmain               : 1 2 3 4
funcion              : 5 6
functions            : 1 1 2 3 6
impresion            : 53
indexacion           : 44
ingreso_datos        : 54
list_type            : 30 70
lista_asignacion     : 20
llamada              : 57
numeric              : 112 112 113 113 114 114 115 115 116 116 117 117
numero_asignacion    : 18
operacion            : 43
parameters           : 60 62 66
programa             : 8 60 61 62 63 105 106 123
proposicion          : 103 106
retorno              : 62 63
sentencias           : 7 8
signed_integer       : 23 24 76
some_data_type       : 72 73 95
string_asignacion    : 17
tupla_asignacion     : 21
tuplas               : 31
tuple_type           : 31 71
unsigned_integer     : 25 77
vacio                : 67
valor                : 9 10 32 32 33 33 34 34 35 35 36 36 37 37 58 59 64 99 100
valores              : 59 97 98 100 120

Parsing method: LALR

state 0

    (0) S' -> . codigoRust
    (1) codigoRust -> . functions fnmain functions
    (2) codigoRust -> . functions fnmain
    (3) codigoRust -> . fnmain functions
    (4) codigoRust -> . fnmain
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (123) fnmain -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    FN              shift and go to state 5

    codigoRust                     shift and go to state 1
    functions                      shift and go to state 2
    fnmain                         shift and go to state 3
    funcion                        shift and go to state 4

state 1

    (0) S' -> codigoRust .



state 2

    (1) codigoRust -> functions . fnmain functions
    (2) codigoRust -> functions . fnmain
    (123) fnmain -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE

    FN              shift and go to state 7

    fnmain                         shift and go to state 6

state 3

    (3) codigoRust -> fnmain . functions
    (4) codigoRust -> fnmain .
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    $end            reduce using rule 4 (codigoRust -> fnmain .)
    FN              shift and go to state 9

    functions                      shift and go to state 8
    funcion                        shift and go to state 4

state 4

    (5) functions -> funcion .
    (6) functions -> funcion . functions
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

  ! shift/reduce conflict for FN resolved as shift
    $end            reduce using rule 5 (functions -> funcion .)
    FN              shift and go to state 9

  ! FN              [ reduce using rule 5 (functions -> funcion .) ]

    funcion                        shift and go to state 4
    functions                      shift and go to state 10

state 5

    (123) fnmain -> FN . MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN . IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    MAIN            shift and go to state 11
    IDENTIFIER      shift and go to state 12


state 6

    (1) codigoRust -> functions fnmain . functions
    (2) codigoRust -> functions fnmain .
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    $end            reduce using rule 2 (codigoRust -> functions fnmain .)
    FN              shift and go to state 9

    functions                      shift and go to state 13
    funcion                        shift and go to state 4

state 7

    (123) fnmain -> FN . MAIN LPAREN RPAREN LLLAVE programa RLLAVE

    MAIN            shift and go to state 11


state 8

    (3) codigoRust -> fnmain functions .

    $end            reduce using rule 3 (codigoRust -> fnmain functions .)


state 9

    (60) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN . IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    IDENTIFIER      shift and go to state 12


state 10

    (6) functions -> funcion functions .

    FN              reduce using rule 6 (functions -> funcion functions .)
    $end            reduce using rule 6 (functions -> funcion functions .)


state 11

    (123) fnmain -> FN MAIN . LPAREN RPAREN LLLAVE programa RLLAVE

    LPAREN          shift and go to state 14


state 12

    (60) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN IDENTIFIER . LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN IDENTIFIER . LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LPAREN          shift and go to state 15


state 13

    (1) codigoRust -> functions fnmain functions .

    $end            reduce using rule 1 (codigoRust -> functions fnmain functions .)


state 14

    (123) fnmain -> FN MAIN LPAREN . RPAREN LLLAVE programa RLLAVE

    RPAREN          shift and go to state 16


state 15

    (60) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN IDENTIFIER LPAREN . RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN IDENTIFIER LPAREN . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (65) parameters -> . IDENTIFIER COLON asig_data_type
    (66) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (67) parameters -> . vacio
    (50) vacio -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 17

  ! RPAREN          [ reduce using rule 50 (vacio -> .) ]

    parameters                     shift and go to state 18
    vacio                          shift and go to state 20

state 16

    (123) fnmain -> FN MAIN LPAREN RPAREN . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 21


state 17

    (65) parameters -> IDENTIFIER . COLON asig_data_type
    (66) parameters -> IDENTIFIER . COLON asig_data_type COMMA parameters

    COLON           shift and go to state 22


state 18

    (60) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RPAREN          shift and go to state 23


state 19

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN . LLLAVE programa RLLAVE
    (63) funcion -> FN IDENTIFIER LPAREN RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 24
    MINUS           shift and go to state 25


state 20

    (67) parameters -> vacio .

    RPAREN          reduce using rule 67 (parameters -> vacio .)


state 21

    (123) fnmain -> FN MAIN LPAREN RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    programa                       shift and go to state 26
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 22

    (65) parameters -> IDENTIFIER COLON . asig_data_type
    (66) parameters -> IDENTIFIER COLON . asig_data_type COMMA parameters
    (69) asig_data_type -> . data_type
    (70) asig_data_type -> . list_type
    (71) asig_data_type -> . tuple_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (72) list_type -> . LCORCH some_data_type RCORCH
    (73) tuple_type -> . LPAREN some_data_type RPAREN
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 47
    REFERENCE       shift and go to state 48
    BOOL            shift and go to state 52
    LCORCH          shift and go to state 53
    LPAREN          shift and go to state 54
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    asig_data_type                 shift and go to state 43
    data_type                      shift and go to state 44
    list_type                      shift and go to state 45
    tuple_type                     shift and go to state 46
    signed_integer                 shift and go to state 49
    unsigned_integer               shift and go to state 50
    float_type                     shift and go to state 51

state 23

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 69
    MINUS           shift and go to state 70


state 24

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    programa                       shift and go to state 71
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 25

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 72


state 26

    (123) fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 73


state 27

    (7) programa -> sentencias .
    (8) programa -> sentencias . programa
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    RLLAVE          reduce using rule 7 (programa -> sentencias .)
    RETURN          reduce using rule 7 (programa -> sentencias .)
    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    sentencias                     shift and go to state 27
    programa                       shift and go to state 74
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 28

    (51) sentencias -> asignacion_variable . SEMICOLON

    SEMICOLON       shift and go to state 75


state 29

    (52) sentencias -> declaracion_variable . SEMICOLON

    SEMICOLON       shift and go to state 76


state 30

    (53) sentencias -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 77


state 31

    (54) sentencias -> ingreso_datos . SEMICOLON

    SEMICOLON       shift and go to state 78


state 32

    (55) sentencias -> arreglos . SEMICOLON

    SEMICOLON       shift and go to state 79


state 33

    (56) sentencias -> control_structure .

    error           reduce using rule 56 (sentencias -> control_structure .)
    LET             reduce using rule 56 (sentencias -> control_structure .)
    PRINTLN         reduce using rule 56 (sentencias -> control_structure .)
    STD             reduce using rule 56 (sentencias -> control_structure .)
    LCORCH          reduce using rule 56 (sentencias -> control_structure .)
    IDENTIFIER      reduce using rule 56 (sentencias -> control_structure .)
    IF              reduce using rule 56 (sentencias -> control_structure .)
    RLLAVE          reduce using rule 56 (sentencias -> control_structure .)
    RETURN          reduce using rule 56 (sentencias -> control_structure .)


state 34

    (57) sentencias -> llamada . SEMICOLON

    SEMICOLON       shift and go to state 80


state 35

    (122) sentencias -> error .

    error           reduce using rule 122 (sentencias -> error .)
    LET             reduce using rule 122 (sentencias -> error .)
    PRINTLN         reduce using rule 122 (sentencias -> error .)
    STD             reduce using rule 122 (sentencias -> error .)
    LCORCH          reduce using rule 122 (sentencias -> error .)
    IDENTIFIER      reduce using rule 122 (sentencias -> error .)
    IF              reduce using rule 122 (sentencias -> error .)
    RLLAVE          reduce using rule 122 (sentencias -> error .)
    RETURN          reduce using rule 122 (sentencias -> error .)


state 36

    (9) asignacion_variable -> LET . IDENTIFIER ASIG valor
    (10) asignacion_variable -> LET . MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> LET . IDENTIFIER COLON asignacion
    (12) asignacion_variable -> LET . MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> LET . IDENTIFIER
    (14) declaracion_variable -> LET . MUT IDENTIFIER
    (15) declaracion_variable -> LET . IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> LET . MUT IDENTIFIER COLON asig_data_type

    IDENTIFIER      shift and go to state 81
    MUT             shift and go to state 82


state 37

    (120) llamada -> IDENTIFIER . LPAREN valores RPAREN
    (121) llamada -> IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 83


state 38

    (58) impresion -> PRINTLN . EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> PRINTLN . EXCLAMATION LPAREN valor COMMA valores RPAREN

    EXCLAMATION     shift and go to state 84


state 39

    (68) ingreso_datos -> STD . DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 85


state 40

    (97) arreglos -> LCORCH . valores RCORCH
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valores                        shift and go to state 86
    valor                          shift and go to state 87
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 41

    (96) control_structure -> condicional .

    error           reduce using rule 96 (control_structure -> condicional .)
    LET             reduce using rule 96 (control_structure -> condicional .)
    PRINTLN         reduce using rule 96 (control_structure -> condicional .)
    STD             reduce using rule 96 (control_structure -> condicional .)
    LCORCH          reduce using rule 96 (control_structure -> condicional .)
    IDENTIFIER      reduce using rule 96 (control_structure -> condicional .)
    IF              reduce using rule 96 (control_structure -> condicional .)
    RLLAVE          reduce using rule 96 (control_structure -> condicional .)
    RETURN          reduce using rule 96 (control_structure -> condicional .)


state 42

    (105) condicional -> IF . comparacion LLLAVE programa RLLAVE
    (106) condicional -> IF . proposicion LLLAVE programa RLLAVE
    (32) comparacion -> . valor EQ valor
    (33) comparacion -> . valor NEQ valor
    (34) comparacion -> . valor GEQ valor
    (35) comparacion -> . valor LEQ valor
    (36) comparacion -> . valor RIGHTARROW valor
    (37) comparacion -> . valor LEFTARROW valor
    (103) proposicion -> . comparacion conector proposicion
    (104) proposicion -> . comparacion
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    comparacion                    shift and go to state 101
    proposicion                    shift and go to state 102
    valor                          shift and go to state 103
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 43

    (65) parameters -> IDENTIFIER COLON asig_data_type .
    (66) parameters -> IDENTIFIER COLON asig_data_type . COMMA parameters

    RPAREN          reduce using rule 65 (parameters -> IDENTIFIER COLON asig_data_type .)
    COMMA           shift and go to state 104


state 44

    (69) asig_data_type -> data_type .

    COMMA           reduce using rule 69 (asig_data_type -> data_type .)
    RPAREN          reduce using rule 69 (asig_data_type -> data_type .)
    SEMICOLON       reduce using rule 69 (asig_data_type -> data_type .)


state 45

    (70) asig_data_type -> list_type .

    COMMA           reduce using rule 70 (asig_data_type -> list_type .)
    RPAREN          reduce using rule 70 (asig_data_type -> list_type .)


state 46

    (71) asig_data_type -> tuple_type .

    COMMA           reduce using rule 71 (asig_data_type -> tuple_type .)
    RPAREN          reduce using rule 71 (asig_data_type -> tuple_type .)


state 47

    (74) data_type -> CHAR .

    COMMA           reduce using rule 74 (data_type -> CHAR .)
    RPAREN          reduce using rule 74 (data_type -> CHAR .)
    RCORCH          reduce using rule 74 (data_type -> CHAR .)
    LLLAVE          reduce using rule 74 (data_type -> CHAR .)
    SEMICOLON       reduce using rule 74 (data_type -> CHAR .)


state 48

    (75) data_type -> REFERENCE . STR

    STR             shift and go to state 105


state 49

    (76) data_type -> signed_integer .

    COMMA           reduce using rule 76 (data_type -> signed_integer .)
    RPAREN          reduce using rule 76 (data_type -> signed_integer .)
    RCORCH          reduce using rule 76 (data_type -> signed_integer .)
    LLLAVE          reduce using rule 76 (data_type -> signed_integer .)


state 50

    (77) data_type -> unsigned_integer .

    COMMA           reduce using rule 77 (data_type -> unsigned_integer .)
    RPAREN          reduce using rule 77 (data_type -> unsigned_integer .)
    RCORCH          reduce using rule 77 (data_type -> unsigned_integer .)
    LLLAVE          reduce using rule 77 (data_type -> unsigned_integer .)


state 51

    (78) data_type -> float_type .

    COMMA           reduce using rule 78 (data_type -> float_type .)
    RPAREN          reduce using rule 78 (data_type -> float_type .)
    RCORCH          reduce using rule 78 (data_type -> float_type .)
    LLLAVE          reduce using rule 78 (data_type -> float_type .)


state 52

    (79) data_type -> BOOL .

    COMMA           reduce using rule 79 (data_type -> BOOL .)
    RPAREN          reduce using rule 79 (data_type -> BOOL .)
    RCORCH          reduce using rule 79 (data_type -> BOOL .)
    LLLAVE          reduce using rule 79 (data_type -> BOOL .)


state 53

    (72) list_type -> LCORCH . some_data_type RCORCH
    (94) some_data_type -> . data_type
    (95) some_data_type -> . data_type COMMA some_data_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 47
    REFERENCE       shift and go to state 48
    BOOL            shift and go to state 52
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    some_data_type                 shift and go to state 106
    data_type                      shift and go to state 107
    signed_integer                 shift and go to state 49
    unsigned_integer               shift and go to state 50
    float_type                     shift and go to state 51

state 54

    (73) tuple_type -> LPAREN . some_data_type RPAREN
    (94) some_data_type -> . data_type
    (95) some_data_type -> . data_type COMMA some_data_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 47
    REFERENCE       shift and go to state 48
    BOOL            shift and go to state 52
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    some_data_type                 shift and go to state 108
    data_type                      shift and go to state 107
    signed_integer                 shift and go to state 49
    unsigned_integer               shift and go to state 50
    float_type                     shift and go to state 51

state 55

    (80) signed_integer -> I8 .

    COMMA           reduce using rule 80 (signed_integer -> I8 .)
    RPAREN          reduce using rule 80 (signed_integer -> I8 .)
    RCORCH          reduce using rule 80 (signed_integer -> I8 .)
    LLLAVE          reduce using rule 80 (signed_integer -> I8 .)
    ASIG            reduce using rule 80 (signed_integer -> I8 .)
    SEMICOLON       reduce using rule 80 (signed_integer -> I8 .)


state 56

    (81) signed_integer -> I16 .

    COMMA           reduce using rule 81 (signed_integer -> I16 .)
    RPAREN          reduce using rule 81 (signed_integer -> I16 .)
    RCORCH          reduce using rule 81 (signed_integer -> I16 .)
    LLLAVE          reduce using rule 81 (signed_integer -> I16 .)
    ASIG            reduce using rule 81 (signed_integer -> I16 .)
    SEMICOLON       reduce using rule 81 (signed_integer -> I16 .)


state 57

    (82) signed_integer -> I32 .

    COMMA           reduce using rule 82 (signed_integer -> I32 .)
    RPAREN          reduce using rule 82 (signed_integer -> I32 .)
    RCORCH          reduce using rule 82 (signed_integer -> I32 .)
    LLLAVE          reduce using rule 82 (signed_integer -> I32 .)
    ASIG            reduce using rule 82 (signed_integer -> I32 .)
    SEMICOLON       reduce using rule 82 (signed_integer -> I32 .)


state 58

    (83) signed_integer -> I64 .

    COMMA           reduce using rule 83 (signed_integer -> I64 .)
    RPAREN          reduce using rule 83 (signed_integer -> I64 .)
    RCORCH          reduce using rule 83 (signed_integer -> I64 .)
    LLLAVE          reduce using rule 83 (signed_integer -> I64 .)
    ASIG            reduce using rule 83 (signed_integer -> I64 .)
    SEMICOLON       reduce using rule 83 (signed_integer -> I64 .)


state 59

    (84) signed_integer -> I128 .

    COMMA           reduce using rule 84 (signed_integer -> I128 .)
    RPAREN          reduce using rule 84 (signed_integer -> I128 .)
    RCORCH          reduce using rule 84 (signed_integer -> I128 .)
    LLLAVE          reduce using rule 84 (signed_integer -> I128 .)
    ASIG            reduce using rule 84 (signed_integer -> I128 .)
    SEMICOLON       reduce using rule 84 (signed_integer -> I128 .)


state 60

    (85) signed_integer -> ISIZE .

    COMMA           reduce using rule 85 (signed_integer -> ISIZE .)
    RPAREN          reduce using rule 85 (signed_integer -> ISIZE .)
    RCORCH          reduce using rule 85 (signed_integer -> ISIZE .)
    LLLAVE          reduce using rule 85 (signed_integer -> ISIZE .)
    ASIG            reduce using rule 85 (signed_integer -> ISIZE .)
    SEMICOLON       reduce using rule 85 (signed_integer -> ISIZE .)


state 61

    (86) unsigned_integer -> U8 .

    COMMA           reduce using rule 86 (unsigned_integer -> U8 .)
    RPAREN          reduce using rule 86 (unsigned_integer -> U8 .)
    RCORCH          reduce using rule 86 (unsigned_integer -> U8 .)
    LLLAVE          reduce using rule 86 (unsigned_integer -> U8 .)
    ASIG            reduce using rule 86 (unsigned_integer -> U8 .)
    SEMICOLON       reduce using rule 86 (unsigned_integer -> U8 .)


state 62

    (87) unsigned_integer -> U16 .

    COMMA           reduce using rule 87 (unsigned_integer -> U16 .)
    RPAREN          reduce using rule 87 (unsigned_integer -> U16 .)
    RCORCH          reduce using rule 87 (unsigned_integer -> U16 .)
    LLLAVE          reduce using rule 87 (unsigned_integer -> U16 .)
    ASIG            reduce using rule 87 (unsigned_integer -> U16 .)
    SEMICOLON       reduce using rule 87 (unsigned_integer -> U16 .)


state 63

    (88) unsigned_integer -> U32 .

    COMMA           reduce using rule 88 (unsigned_integer -> U32 .)
    RPAREN          reduce using rule 88 (unsigned_integer -> U32 .)
    RCORCH          reduce using rule 88 (unsigned_integer -> U32 .)
    LLLAVE          reduce using rule 88 (unsigned_integer -> U32 .)
    ASIG            reduce using rule 88 (unsigned_integer -> U32 .)
    SEMICOLON       reduce using rule 88 (unsigned_integer -> U32 .)


state 64

    (89) unsigned_integer -> U64 .

    COMMA           reduce using rule 89 (unsigned_integer -> U64 .)
    RPAREN          reduce using rule 89 (unsigned_integer -> U64 .)
    RCORCH          reduce using rule 89 (unsigned_integer -> U64 .)
    LLLAVE          reduce using rule 89 (unsigned_integer -> U64 .)
    ASIG            reduce using rule 89 (unsigned_integer -> U64 .)
    SEMICOLON       reduce using rule 89 (unsigned_integer -> U64 .)


state 65

    (90) unsigned_integer -> U128 .

    COMMA           reduce using rule 90 (unsigned_integer -> U128 .)
    RPAREN          reduce using rule 90 (unsigned_integer -> U128 .)
    RCORCH          reduce using rule 90 (unsigned_integer -> U128 .)
    LLLAVE          reduce using rule 90 (unsigned_integer -> U128 .)
    ASIG            reduce using rule 90 (unsigned_integer -> U128 .)
    SEMICOLON       reduce using rule 90 (unsigned_integer -> U128 .)


state 66

    (91) unsigned_integer -> USIZE .

    COMMA           reduce using rule 91 (unsigned_integer -> USIZE .)
    RPAREN          reduce using rule 91 (unsigned_integer -> USIZE .)
    RCORCH          reduce using rule 91 (unsigned_integer -> USIZE .)
    LLLAVE          reduce using rule 91 (unsigned_integer -> USIZE .)
    ASIG            reduce using rule 91 (unsigned_integer -> USIZE .)
    SEMICOLON       reduce using rule 91 (unsigned_integer -> USIZE .)


state 67

    (92) float_type -> F32 .

    COMMA           reduce using rule 92 (float_type -> F32 .)
    RPAREN          reduce using rule 92 (float_type -> F32 .)
    RCORCH          reduce using rule 92 (float_type -> F32 .)
    LLLAVE          reduce using rule 92 (float_type -> F32 .)
    ASIG            reduce using rule 92 (float_type -> F32 .)
    SEMICOLON       reduce using rule 92 (float_type -> F32 .)


state 68

    (93) float_type -> F64 .

    COMMA           reduce using rule 93 (float_type -> F64 .)
    RPAREN          reduce using rule 93 (float_type -> F64 .)
    RCORCH          reduce using rule 93 (float_type -> F64 .)
    LLLAVE          reduce using rule 93 (float_type -> F64 .)
    ASIG            reduce using rule 93 (float_type -> F64 .)
    SEMICOLON       reduce using rule 93 (float_type -> F64 .)


state 69

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    programa                       shift and go to state 109
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 70

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 110


state 71

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 111


state 72

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 47
    REFERENCE       shift and go to state 48
    BOOL            shift and go to state 52
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    data_type                      shift and go to state 112
    signed_integer                 shift and go to state 49
    unsigned_integer               shift and go to state 50
    float_type                     shift and go to state 51

state 73

    (123) fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 123 (fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 123 (fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)


state 74

    (8) programa -> sentencias programa .

    RLLAVE          reduce using rule 8 (programa -> sentencias programa .)
    RETURN          reduce using rule 8 (programa -> sentencias programa .)


state 75

    (51) sentencias -> asignacion_variable SEMICOLON .

    error           reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    LET             reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    PRINTLN         reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    STD             reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    LCORCH          reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    IF              reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    RLLAVE          reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    RETURN          reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)


state 76

    (52) sentencias -> declaracion_variable SEMICOLON .

    error           reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    LET             reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    PRINTLN         reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    STD             reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    LCORCH          reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    IDENTIFIER      reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    IF              reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    RLLAVE          reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    RETURN          reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)


state 77

    (53) sentencias -> impresion SEMICOLON .

    error           reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    LET             reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    STD             reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    LCORCH          reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    IF              reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    RLLAVE          reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    RETURN          reduce using rule 53 (sentencias -> impresion SEMICOLON .)


state 78

    (54) sentencias -> ingreso_datos SEMICOLON .

    error           reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    LET             reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    PRINTLN         reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    STD             reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    LCORCH          reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    IDENTIFIER      reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    IF              reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    RLLAVE          reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    RETURN          reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)


state 79

    (55) sentencias -> arreglos SEMICOLON .

    error           reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    LET             reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    PRINTLN         reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    STD             reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    LCORCH          reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    IF              reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    RLLAVE          reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    RETURN          reduce using rule 55 (sentencias -> arreglos SEMICOLON .)


state 80

    (57) sentencias -> llamada SEMICOLON .

    error           reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    LET             reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    PRINTLN         reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    STD             reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    LCORCH          reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    IF              reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    RLLAVE          reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    RETURN          reduce using rule 57 (sentencias -> llamada SEMICOLON .)


state 81

    (9) asignacion_variable -> LET IDENTIFIER . ASIG valor
    (11) asignacion_variable -> LET IDENTIFIER . COLON asignacion
    (13) declaracion_variable -> LET IDENTIFIER .
    (15) declaracion_variable -> LET IDENTIFIER . COLON asig_data_type

    ASIG            shift and go to state 113
    COLON           shift and go to state 114
    SEMICOLON       reduce using rule 13 (declaracion_variable -> LET IDENTIFIER .)


state 82

    (10) asignacion_variable -> LET MUT . IDENTIFIER ASIG valor
    (12) asignacion_variable -> LET MUT . IDENTIFIER COLON asignacion
    (14) declaracion_variable -> LET MUT . IDENTIFIER
    (16) declaracion_variable -> LET MUT . IDENTIFIER COLON asig_data_type

    IDENTIFIER      shift and go to state 115


state 83

    (120) llamada -> IDENTIFIER LPAREN . valores RPAREN
    (121) llamada -> IDENTIFIER LPAREN . RPAREN
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    RPAREN          shift and go to state 117
    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valores                        shift and go to state 116
    valor                          shift and go to state 87
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 84

    (58) impresion -> PRINTLN EXCLAMATION . LPAREN valor RPAREN
    (59) impresion -> PRINTLN EXCLAMATION . LPAREN valor COMMA valores RPAREN

    LPAREN          shift and go to state 118


state 85

    (68) ingreso_datos -> STD DOUBLE_COLON . IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    IO              shift and go to state 119


state 86

    (97) arreglos -> LCORCH valores . RCORCH

    RCORCH          shift and go to state 120


state 87

    (99) valores -> valor .
    (100) valores -> valor . COMMA valores

    RCORCH          reduce using rule 99 (valores -> valor .)
    RPAREN          reduce using rule 99 (valores -> valor .)
    COMMA           shift and go to state 121


state 88

    (38) valor -> INTEGER .
    (107) numeric -> INTEGER .

    COMMA           reduce using rule 38 (valor -> INTEGER .)
    RCORCH          reduce using rule 38 (valor -> INTEGER .)
    EQ              reduce using rule 38 (valor -> INTEGER .)
    NEQ             reduce using rule 38 (valor -> INTEGER .)
    GEQ             reduce using rule 38 (valor -> INTEGER .)
    LEQ             reduce using rule 38 (valor -> INTEGER .)
    RIGHTARROW      reduce using rule 38 (valor -> INTEGER .)
    LEFTARROW       reduce using rule 38 (valor -> INTEGER .)
    RPAREN          reduce using rule 38 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 38 (valor -> INTEGER .)
    LLLAVE          reduce using rule 38 (valor -> INTEGER .)
    AND             reduce using rule 38 (valor -> INTEGER .)
    OR              reduce using rule 38 (valor -> INTEGER .)
    PLUS            reduce using rule 107 (numeric -> INTEGER .)
    MINUS           reduce using rule 107 (numeric -> INTEGER .)
    TIMES           reduce using rule 107 (numeric -> INTEGER .)
    DIVIDE          reduce using rule 107 (numeric -> INTEGER .)
    MOD             reduce using rule 107 (numeric -> INTEGER .)
    INTD            reduce using rule 107 (numeric -> INTEGER .)


state 89

    (39) valor -> MINUS . INTEGER
    (41) valor -> MINUS . FLOAT

    INTEGER         shift and go to state 122
    FLOAT           shift and go to state 123


state 90

    (40) valor -> FLOAT .
    (108) numeric -> FLOAT .

    COMMA           reduce using rule 40 (valor -> FLOAT .)
    RCORCH          reduce using rule 40 (valor -> FLOAT .)
    EQ              reduce using rule 40 (valor -> FLOAT .)
    NEQ             reduce using rule 40 (valor -> FLOAT .)
    GEQ             reduce using rule 40 (valor -> FLOAT .)
    LEQ             reduce using rule 40 (valor -> FLOAT .)
    RIGHTARROW      reduce using rule 40 (valor -> FLOAT .)
    LEFTARROW       reduce using rule 40 (valor -> FLOAT .)
    RPAREN          reduce using rule 40 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 40 (valor -> FLOAT .)
    LLLAVE          reduce using rule 40 (valor -> FLOAT .)
    AND             reduce using rule 40 (valor -> FLOAT .)
    OR              reduce using rule 40 (valor -> FLOAT .)
    PLUS            reduce using rule 108 (numeric -> FLOAT .)
    MINUS           reduce using rule 108 (numeric -> FLOAT .)
    TIMES           reduce using rule 108 (numeric -> FLOAT .)
    DIVIDE          reduce using rule 108 (numeric -> FLOAT .)
    MOD             reduce using rule 108 (numeric -> FLOAT .)
    INTD            reduce using rule 108 (numeric -> FLOAT .)


state 91

    (42) valor -> IDENTIFIER .
    (119) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH
    (109) numeric -> IDENTIFIER .
    (111) cadena -> IDENTIFIER .

  ! reduce/reduce conflict for PLUS resolved using rule 109 (numeric -> IDENTIFIER .)
    COMMA           reduce using rule 42 (valor -> IDENTIFIER .)
    RCORCH          reduce using rule 42 (valor -> IDENTIFIER .)
    EQ              reduce using rule 42 (valor -> IDENTIFIER .)
    NEQ             reduce using rule 42 (valor -> IDENTIFIER .)
    GEQ             reduce using rule 42 (valor -> IDENTIFIER .)
    LEQ             reduce using rule 42 (valor -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 42 (valor -> IDENTIFIER .)
    LEFTARROW       reduce using rule 42 (valor -> IDENTIFIER .)
    RPAREN          reduce using rule 42 (valor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 42 (valor -> IDENTIFIER .)
    LLLAVE          reduce using rule 42 (valor -> IDENTIFIER .)
    AND             reduce using rule 42 (valor -> IDENTIFIER .)
    OR              reduce using rule 42 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 124
    PLUS            reduce using rule 109 (numeric -> IDENTIFIER .)
    MINUS           reduce using rule 109 (numeric -> IDENTIFIER .)
    TIMES           reduce using rule 109 (numeric -> IDENTIFIER .)
    DIVIDE          reduce using rule 109 (numeric -> IDENTIFIER .)
    MOD             reduce using rule 109 (numeric -> IDENTIFIER .)
    INTD            reduce using rule 109 (numeric -> IDENTIFIER .)

  ! PLUS            [ reduce using rule 111 (cadena -> IDENTIFIER .) ]


state 92

    (43) valor -> operacion .

    COMMA           reduce using rule 43 (valor -> operacion .)
    RCORCH          reduce using rule 43 (valor -> operacion .)
    EQ              reduce using rule 43 (valor -> operacion .)
    NEQ             reduce using rule 43 (valor -> operacion .)
    GEQ             reduce using rule 43 (valor -> operacion .)
    LEQ             reduce using rule 43 (valor -> operacion .)
    RIGHTARROW      reduce using rule 43 (valor -> operacion .)
    LEFTARROW       reduce using rule 43 (valor -> operacion .)
    RPAREN          reduce using rule 43 (valor -> operacion .)
    SEMICOLON       reduce using rule 43 (valor -> operacion .)
    LLLAVE          reduce using rule 43 (valor -> operacion .)
    AND             reduce using rule 43 (valor -> operacion .)
    OR              reduce using rule 43 (valor -> operacion .)


state 93

    (44) valor -> indexacion .

    COMMA           reduce using rule 44 (valor -> indexacion .)
    RCORCH          reduce using rule 44 (valor -> indexacion .)
    EQ              reduce using rule 44 (valor -> indexacion .)
    NEQ             reduce using rule 44 (valor -> indexacion .)
    GEQ             reduce using rule 44 (valor -> indexacion .)
    LEQ             reduce using rule 44 (valor -> indexacion .)
    RIGHTARROW      reduce using rule 44 (valor -> indexacion .)
    LEFTARROW       reduce using rule 44 (valor -> indexacion .)
    RPAREN          reduce using rule 44 (valor -> indexacion .)
    SEMICOLON       reduce using rule 44 (valor -> indexacion .)
    LLLAVE          reduce using rule 44 (valor -> indexacion .)
    AND             reduce using rule 44 (valor -> indexacion .)
    OR              reduce using rule 44 (valor -> indexacion .)


state 94

    (45) valor -> arreglos .

    COMMA           reduce using rule 45 (valor -> arreglos .)
    RCORCH          reduce using rule 45 (valor -> arreglos .)
    EQ              reduce using rule 45 (valor -> arreglos .)
    NEQ             reduce using rule 45 (valor -> arreglos .)
    GEQ             reduce using rule 45 (valor -> arreglos .)
    LEQ             reduce using rule 45 (valor -> arreglos .)
    RIGHTARROW      reduce using rule 45 (valor -> arreglos .)
    LEFTARROW       reduce using rule 45 (valor -> arreglos .)
    RPAREN          reduce using rule 45 (valor -> arreglos .)
    SEMICOLON       reduce using rule 45 (valor -> arreglos .)
    LLLAVE          reduce using rule 45 (valor -> arreglos .)
    AND             reduce using rule 45 (valor -> arreglos .)
    OR              reduce using rule 45 (valor -> arreglos .)


state 95

    (46) valor -> STRING .
    (110) cadena -> STRING .

    COMMA           reduce using rule 46 (valor -> STRING .)
    RCORCH          reduce using rule 46 (valor -> STRING .)
    EQ              reduce using rule 46 (valor -> STRING .)
    NEQ             reduce using rule 46 (valor -> STRING .)
    GEQ             reduce using rule 46 (valor -> STRING .)
    LEQ             reduce using rule 46 (valor -> STRING .)
    RIGHTARROW      reduce using rule 46 (valor -> STRING .)
    LEFTARROW       reduce using rule 46 (valor -> STRING .)
    RPAREN          reduce using rule 46 (valor -> STRING .)
    SEMICOLON       reduce using rule 46 (valor -> STRING .)
    LLLAVE          reduce using rule 46 (valor -> STRING .)
    AND             reduce using rule 46 (valor -> STRING .)
    OR              reduce using rule 46 (valor -> STRING .)
    PLUS            reduce using rule 110 (cadena -> STRING .)


state 96

    (47) valor -> booleanos .

    COMMA           reduce using rule 47 (valor -> booleanos .)
    RCORCH          reduce using rule 47 (valor -> booleanos .)
    EQ              reduce using rule 47 (valor -> booleanos .)
    NEQ             reduce using rule 47 (valor -> booleanos .)
    GEQ             reduce using rule 47 (valor -> booleanos .)
    LEQ             reduce using rule 47 (valor -> booleanos .)
    RIGHTARROW      reduce using rule 47 (valor -> booleanos .)
    LEFTARROW       reduce using rule 47 (valor -> booleanos .)
    RPAREN          reduce using rule 47 (valor -> booleanos .)
    SEMICOLON       reduce using rule 47 (valor -> booleanos .)
    LLLAVE          reduce using rule 47 (valor -> booleanos .)
    AND             reduce using rule 47 (valor -> booleanos .)
    OR              reduce using rule 47 (valor -> booleanos .)


state 97

    (112) operacion -> numeric . PLUS numeric
    (113) operacion -> numeric . MINUS numeric
    (114) operacion -> numeric . TIMES numeric
    (115) operacion -> numeric . DIVIDE numeric
    (116) operacion -> numeric . MOD numeric
    (117) operacion -> numeric . INTD numeric

    PLUS            shift and go to state 125
    MINUS           shift and go to state 126
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 128
    MOD             shift and go to state 129
    INTD            shift and go to state 130


state 98

    (118) operacion -> cadena . PLUS cadena

    PLUS            shift and go to state 131


state 99

    (48) booleanos -> TRUE .

    COMMA           reduce using rule 48 (booleanos -> TRUE .)
    RCORCH          reduce using rule 48 (booleanos -> TRUE .)
    EQ              reduce using rule 48 (booleanos -> TRUE .)
    NEQ             reduce using rule 48 (booleanos -> TRUE .)
    GEQ             reduce using rule 48 (booleanos -> TRUE .)
    LEQ             reduce using rule 48 (booleanos -> TRUE .)
    RIGHTARROW      reduce using rule 48 (booleanos -> TRUE .)
    LEFTARROW       reduce using rule 48 (booleanos -> TRUE .)
    RPAREN          reduce using rule 48 (booleanos -> TRUE .)
    SEMICOLON       reduce using rule 48 (booleanos -> TRUE .)
    LLLAVE          reduce using rule 48 (booleanos -> TRUE .)
    AND             reduce using rule 48 (booleanos -> TRUE .)
    OR              reduce using rule 48 (booleanos -> TRUE .)


state 100

    (49) booleanos -> FALSE .

    COMMA           reduce using rule 49 (booleanos -> FALSE .)
    RCORCH          reduce using rule 49 (booleanos -> FALSE .)
    EQ              reduce using rule 49 (booleanos -> FALSE .)
    NEQ             reduce using rule 49 (booleanos -> FALSE .)
    GEQ             reduce using rule 49 (booleanos -> FALSE .)
    LEQ             reduce using rule 49 (booleanos -> FALSE .)
    RIGHTARROW      reduce using rule 49 (booleanos -> FALSE .)
    LEFTARROW       reduce using rule 49 (booleanos -> FALSE .)
    RPAREN          reduce using rule 49 (booleanos -> FALSE .)
    SEMICOLON       reduce using rule 49 (booleanos -> FALSE .)
    LLLAVE          reduce using rule 49 (booleanos -> FALSE .)
    AND             reduce using rule 49 (booleanos -> FALSE .)
    OR              reduce using rule 49 (booleanos -> FALSE .)


state 101

    (105) condicional -> IF comparacion . LLLAVE programa RLLAVE
    (103) proposicion -> comparacion . conector proposicion
    (104) proposicion -> comparacion .
    (101) conector -> . AND
    (102) conector -> . OR

  ! shift/reduce conflict for LLLAVE resolved as shift
    LLLAVE          shift and go to state 132
    AND             shift and go to state 134
    OR              shift and go to state 135

  ! LLLAVE          [ reduce using rule 104 (proposicion -> comparacion .) ]

    conector                       shift and go to state 133

state 102

    (106) condicional -> IF proposicion . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 136


state 103

    (32) comparacion -> valor . EQ valor
    (33) comparacion -> valor . NEQ valor
    (34) comparacion -> valor . GEQ valor
    (35) comparacion -> valor . LEQ valor
    (36) comparacion -> valor . RIGHTARROW valor
    (37) comparacion -> valor . LEFTARROW valor

    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    GEQ             shift and go to state 139
    LEQ             shift and go to state 140
    RIGHTARROW      shift and go to state 141
    LEFTARROW       shift and go to state 142


state 104

    (66) parameters -> IDENTIFIER COLON asig_data_type COMMA . parameters
    (65) parameters -> . IDENTIFIER COLON asig_data_type
    (66) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (67) parameters -> . vacio
    (50) vacio -> .

    IDENTIFIER      shift and go to state 17
    RPAREN          reduce using rule 50 (vacio -> .)

    parameters                     shift and go to state 143
    vacio                          shift and go to state 20

state 105

    (75) data_type -> REFERENCE STR .

    COMMA           reduce using rule 75 (data_type -> REFERENCE STR .)
    RPAREN          reduce using rule 75 (data_type -> REFERENCE STR .)
    RCORCH          reduce using rule 75 (data_type -> REFERENCE STR .)
    LLLAVE          reduce using rule 75 (data_type -> REFERENCE STR .)


state 106

    (72) list_type -> LCORCH some_data_type . RCORCH

    RCORCH          shift and go to state 144


state 107

    (94) some_data_type -> data_type .
    (95) some_data_type -> data_type . COMMA some_data_type

    RCORCH          reduce using rule 94 (some_data_type -> data_type .)
    RPAREN          reduce using rule 94 (some_data_type -> data_type .)
    COMMA           shift and go to state 145


state 108

    (73) tuple_type -> LPAREN some_data_type . RPAREN

    RPAREN          shift and go to state 146


state 109

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 147


state 110

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 47
    REFERENCE       shift and go to state 48
    BOOL            shift and go to state 52
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    data_type                      shift and go to state 148
    signed_integer                 shift and go to state 49
    unsigned_integer               shift and go to state 50
    float_type                     shift and go to state 51

state 111

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 61 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 61 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)


state 112

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 149


state 113

    (9) asignacion_variable -> LET IDENTIFIER ASIG . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 150
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 114

    (11) asignacion_variable -> LET IDENTIFIER COLON . asignacion
    (15) declaracion_variable -> LET IDENTIFIER COLON . asig_data_type
    (17) asignacion -> . string_asignacion
    (18) asignacion -> . numero_asignacion
    (19) asignacion -> . boolean_asignacion
    (20) asignacion -> . lista_asignacion
    (21) asignacion -> . tupla_asignacion
    (69) asig_data_type -> . data_type
    (70) asig_data_type -> . list_type
    (71) asig_data_type -> . tuple_type
    (22) string_asignacion -> . REFERENCE STR ASIG STRING
    (23) numero_asignacion -> . signed_integer ASIG INTEGER
    (24) numero_asignacion -> . signed_integer ASIG MINUS INTEGER
    (25) numero_asignacion -> . unsigned_integer ASIG INTEGER
    (26) numero_asignacion -> . float_type ASIG FLOAT
    (27) numero_asignacion -> . float_type ASIG MINUS FLOAT
    (28) boolean_asignacion -> . BOOL ASIG TRUE
    (29) boolean_asignacion -> . BOOL ASIG FALSE
    (30) lista_asignacion -> . list_type ASIG arreglos
    (31) tupla_asignacion -> . tuple_type ASIG tuplas
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (72) list_type -> . LCORCH some_data_type RCORCH
    (73) tuple_type -> . LPAREN some_data_type RPAREN
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    REFERENCE       shift and go to state 160
    BOOL            shift and go to state 164
    CHAR            shift and go to state 47
    LCORCH          shift and go to state 53
    LPAREN          shift and go to state 54
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    asignacion                     shift and go to state 151
    asig_data_type                 shift and go to state 152
    string_asignacion              shift and go to state 153
    numero_asignacion              shift and go to state 154
    boolean_asignacion             shift and go to state 155
    lista_asignacion               shift and go to state 156
    tupla_asignacion               shift and go to state 157
    data_type                      shift and go to state 44
    list_type                      shift and go to state 158
    tuple_type                     shift and go to state 159
    signed_integer                 shift and go to state 161
    unsigned_integer               shift and go to state 162
    float_type                     shift and go to state 163

state 115

    (10) asignacion_variable -> LET MUT IDENTIFIER . ASIG valor
    (12) asignacion_variable -> LET MUT IDENTIFIER . COLON asignacion
    (14) declaracion_variable -> LET MUT IDENTIFIER .
    (16) declaracion_variable -> LET MUT IDENTIFIER . COLON asig_data_type

    ASIG            shift and go to state 165
    COLON           shift and go to state 166
    SEMICOLON       reduce using rule 14 (declaracion_variable -> LET MUT IDENTIFIER .)


state 116

    (120) llamada -> IDENTIFIER LPAREN valores . RPAREN

    RPAREN          shift and go to state 167


state 117

    (121) llamada -> IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 121 (llamada -> IDENTIFIER LPAREN RPAREN .)


state 118

    (58) impresion -> PRINTLN EXCLAMATION LPAREN . valor RPAREN
    (59) impresion -> PRINTLN EXCLAMATION LPAREN . valor COMMA valores RPAREN
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 168
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 119

    (68) ingreso_datos -> STD DOUBLE_COLON IO . DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 169


state 120

    (97) arreglos -> LCORCH valores RCORCH .

    SEMICOLON       reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    COMMA           reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    RCORCH          reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    EQ              reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    NEQ             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    GEQ             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    LEQ             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    RIGHTARROW      reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    LEFTARROW       reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    RPAREN          reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    LLLAVE          reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    AND             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    OR              reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)


state 121

    (100) valores -> valor COMMA . valores
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 87
    valores                        shift and go to state 170
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 122

    (39) valor -> MINUS INTEGER .

    COMMA           reduce using rule 39 (valor -> MINUS INTEGER .)
    RCORCH          reduce using rule 39 (valor -> MINUS INTEGER .)
    EQ              reduce using rule 39 (valor -> MINUS INTEGER .)
    NEQ             reduce using rule 39 (valor -> MINUS INTEGER .)
    GEQ             reduce using rule 39 (valor -> MINUS INTEGER .)
    LEQ             reduce using rule 39 (valor -> MINUS INTEGER .)
    RIGHTARROW      reduce using rule 39 (valor -> MINUS INTEGER .)
    LEFTARROW       reduce using rule 39 (valor -> MINUS INTEGER .)
    RPAREN          reduce using rule 39 (valor -> MINUS INTEGER .)
    SEMICOLON       reduce using rule 39 (valor -> MINUS INTEGER .)
    LLLAVE          reduce using rule 39 (valor -> MINUS INTEGER .)
    AND             reduce using rule 39 (valor -> MINUS INTEGER .)
    OR              reduce using rule 39 (valor -> MINUS INTEGER .)


state 123

    (41) valor -> MINUS FLOAT .

    COMMA           reduce using rule 41 (valor -> MINUS FLOAT .)
    RCORCH          reduce using rule 41 (valor -> MINUS FLOAT .)
    EQ              reduce using rule 41 (valor -> MINUS FLOAT .)
    NEQ             reduce using rule 41 (valor -> MINUS FLOAT .)
    GEQ             reduce using rule 41 (valor -> MINUS FLOAT .)
    LEQ             reduce using rule 41 (valor -> MINUS FLOAT .)
    RIGHTARROW      reduce using rule 41 (valor -> MINUS FLOAT .)
    LEFTARROW       reduce using rule 41 (valor -> MINUS FLOAT .)
    RPAREN          reduce using rule 41 (valor -> MINUS FLOAT .)
    SEMICOLON       reduce using rule 41 (valor -> MINUS FLOAT .)
    LLLAVE          reduce using rule 41 (valor -> MINUS FLOAT .)
    AND             reduce using rule 41 (valor -> MINUS FLOAT .)
    OR              reduce using rule 41 (valor -> MINUS FLOAT .)


state 124

    (119) indexacion -> IDENTIFIER LCORCH . INTEGER RCORCH

    INTEGER         shift and go to state 171


state 125

    (112) operacion -> numeric PLUS . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 173
    FLOAT           shift and go to state 174
    IDENTIFIER      shift and go to state 175

    numeric                        shift and go to state 172

state 126

    (113) operacion -> numeric MINUS . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 173
    FLOAT           shift and go to state 174
    IDENTIFIER      shift and go to state 175

    numeric                        shift and go to state 176

state 127

    (114) operacion -> numeric TIMES . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 173
    FLOAT           shift and go to state 174
    IDENTIFIER      shift and go to state 175

    numeric                        shift and go to state 177

state 128

    (115) operacion -> numeric DIVIDE . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 173
    FLOAT           shift and go to state 174
    IDENTIFIER      shift and go to state 175

    numeric                        shift and go to state 178

state 129

    (116) operacion -> numeric MOD . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 173
    FLOAT           shift and go to state 174
    IDENTIFIER      shift and go to state 175

    numeric                        shift and go to state 179

state 130

    (117) operacion -> numeric INTD . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 173
    FLOAT           shift and go to state 174
    IDENTIFIER      shift and go to state 175

    numeric                        shift and go to state 180

state 131

    (118) operacion -> cadena PLUS . cadena
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    STRING          shift and go to state 182
    IDENTIFIER      shift and go to state 183

    cadena                         shift and go to state 181

state 132

    (105) condicional -> IF comparacion LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    programa                       shift and go to state 184
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 133

    (103) proposicion -> comparacion conector . proposicion
    (103) proposicion -> . comparacion conector proposicion
    (104) proposicion -> . comparacion
    (32) comparacion -> . valor EQ valor
    (33) comparacion -> . valor NEQ valor
    (34) comparacion -> . valor GEQ valor
    (35) comparacion -> . valor LEQ valor
    (36) comparacion -> . valor RIGHTARROW valor
    (37) comparacion -> . valor LEFTARROW valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    comparacion                    shift and go to state 185
    proposicion                    shift and go to state 186
    valor                          shift and go to state 103
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 134

    (101) conector -> AND .

    INTEGER         reduce using rule 101 (conector -> AND .)
    MINUS           reduce using rule 101 (conector -> AND .)
    FLOAT           reduce using rule 101 (conector -> AND .)
    IDENTIFIER      reduce using rule 101 (conector -> AND .)
    STRING          reduce using rule 101 (conector -> AND .)
    LCORCH          reduce using rule 101 (conector -> AND .)
    TRUE            reduce using rule 101 (conector -> AND .)
    FALSE           reduce using rule 101 (conector -> AND .)


state 135

    (102) conector -> OR .

    INTEGER         reduce using rule 102 (conector -> OR .)
    MINUS           reduce using rule 102 (conector -> OR .)
    FLOAT           reduce using rule 102 (conector -> OR .)
    IDENTIFIER      reduce using rule 102 (conector -> OR .)
    STRING          reduce using rule 102 (conector -> OR .)
    LCORCH          reduce using rule 102 (conector -> OR .)
    TRUE            reduce using rule 102 (conector -> OR .)
    FALSE           reduce using rule 102 (conector -> OR .)


state 136

    (106) condicional -> IF proposicion LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    programa                       shift and go to state 187
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 137

    (32) comparacion -> valor EQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 188
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 138

    (33) comparacion -> valor NEQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 189
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 139

    (34) comparacion -> valor GEQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 190
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 140

    (35) comparacion -> valor LEQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 191
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 141

    (36) comparacion -> valor RIGHTARROW . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 192
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 142

    (37) comparacion -> valor LEFTARROW . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 193
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 143

    (66) parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .

    RPAREN          reduce using rule 66 (parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .)


state 144

    (72) list_type -> LCORCH some_data_type RCORCH .

    COMMA           reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)
    RPAREN          reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)
    ASIG            reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)
    SEMICOLON       reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)


state 145

    (95) some_data_type -> data_type COMMA . some_data_type
    (94) some_data_type -> . data_type
    (95) some_data_type -> . data_type COMMA some_data_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 47
    REFERENCE       shift and go to state 48
    BOOL            shift and go to state 52
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    data_type                      shift and go to state 107
    some_data_type                 shift and go to state 194
    signed_integer                 shift and go to state 49
    unsigned_integer               shift and go to state 50
    float_type                     shift and go to state 51

state 146

    (73) tuple_type -> LPAREN some_data_type RPAREN .

    COMMA           reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)
    RPAREN          reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)
    ASIG            reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)
    SEMICOLON       reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)


state 147

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 60 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 60 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)


state 148

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 195


state 149

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    programa                       shift and go to state 196
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 150

    (9) asignacion_variable -> LET IDENTIFIER ASIG valor .

    SEMICOLON       reduce using rule 9 (asignacion_variable -> LET IDENTIFIER ASIG valor .)


state 151

    (11) asignacion_variable -> LET IDENTIFIER COLON asignacion .

    SEMICOLON       reduce using rule 11 (asignacion_variable -> LET IDENTIFIER COLON asignacion .)


state 152

    (15) declaracion_variable -> LET IDENTIFIER COLON asig_data_type .

    SEMICOLON       reduce using rule 15 (declaracion_variable -> LET IDENTIFIER COLON asig_data_type .)


state 153

    (17) asignacion -> string_asignacion .

    SEMICOLON       reduce using rule 17 (asignacion -> string_asignacion .)


state 154

    (18) asignacion -> numero_asignacion .

    SEMICOLON       reduce using rule 18 (asignacion -> numero_asignacion .)


state 155

    (19) asignacion -> boolean_asignacion .

    SEMICOLON       reduce using rule 19 (asignacion -> boolean_asignacion .)


state 156

    (20) asignacion -> lista_asignacion .

    SEMICOLON       reduce using rule 20 (asignacion -> lista_asignacion .)


state 157

    (21) asignacion -> tupla_asignacion .

    SEMICOLON       reduce using rule 21 (asignacion -> tupla_asignacion .)


state 158

    (70) asig_data_type -> list_type .
    (30) lista_asignacion -> list_type . ASIG arreglos

    SEMICOLON       reduce using rule 70 (asig_data_type -> list_type .)
    ASIG            shift and go to state 197


state 159

    (71) asig_data_type -> tuple_type .
    (31) tupla_asignacion -> tuple_type . ASIG tuplas

    SEMICOLON       reduce using rule 71 (asig_data_type -> tuple_type .)
    ASIG            shift and go to state 198


state 160

    (22) string_asignacion -> REFERENCE . STR ASIG STRING
    (75) data_type -> REFERENCE . STR

    STR             shift and go to state 199


state 161

    (23) numero_asignacion -> signed_integer . ASIG INTEGER
    (24) numero_asignacion -> signed_integer . ASIG MINUS INTEGER
    (76) data_type -> signed_integer .

    ASIG            shift and go to state 200
    SEMICOLON       reduce using rule 76 (data_type -> signed_integer .)


state 162

    (25) numero_asignacion -> unsigned_integer . ASIG INTEGER
    (77) data_type -> unsigned_integer .

    ASIG            shift and go to state 201
    SEMICOLON       reduce using rule 77 (data_type -> unsigned_integer .)


state 163

    (26) numero_asignacion -> float_type . ASIG FLOAT
    (27) numero_asignacion -> float_type . ASIG MINUS FLOAT
    (78) data_type -> float_type .

    ASIG            shift and go to state 202
    SEMICOLON       reduce using rule 78 (data_type -> float_type .)


state 164

    (28) boolean_asignacion -> BOOL . ASIG TRUE
    (29) boolean_asignacion -> BOOL . ASIG FALSE
    (79) data_type -> BOOL .

    ASIG            shift and go to state 203
    SEMICOLON       reduce using rule 79 (data_type -> BOOL .)


state 165

    (10) asignacion_variable -> LET MUT IDENTIFIER ASIG . valor
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 204
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 166

    (12) asignacion_variable -> LET MUT IDENTIFIER COLON . asignacion
    (16) declaracion_variable -> LET MUT IDENTIFIER COLON . asig_data_type
    (17) asignacion -> . string_asignacion
    (18) asignacion -> . numero_asignacion
    (19) asignacion -> . boolean_asignacion
    (20) asignacion -> . lista_asignacion
    (21) asignacion -> . tupla_asignacion
    (69) asig_data_type -> . data_type
    (70) asig_data_type -> . list_type
    (71) asig_data_type -> . tuple_type
    (22) string_asignacion -> . REFERENCE STR ASIG STRING
    (23) numero_asignacion -> . signed_integer ASIG INTEGER
    (24) numero_asignacion -> . signed_integer ASIG MINUS INTEGER
    (25) numero_asignacion -> . unsigned_integer ASIG INTEGER
    (26) numero_asignacion -> . float_type ASIG FLOAT
    (27) numero_asignacion -> . float_type ASIG MINUS FLOAT
    (28) boolean_asignacion -> . BOOL ASIG TRUE
    (29) boolean_asignacion -> . BOOL ASIG FALSE
    (30) lista_asignacion -> . list_type ASIG arreglos
    (31) tupla_asignacion -> . tuple_type ASIG tuplas
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (72) list_type -> . LCORCH some_data_type RCORCH
    (73) tuple_type -> . LPAREN some_data_type RPAREN
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    REFERENCE       shift and go to state 160
    BOOL            shift and go to state 164
    CHAR            shift and go to state 47
    LCORCH          shift and go to state 53
    LPAREN          shift and go to state 54
    I8              shift and go to state 55
    I16             shift and go to state 56
    I32             shift and go to state 57
    I64             shift and go to state 58
    I128            shift and go to state 59
    ISIZE           shift and go to state 60
    U8              shift and go to state 61
    U16             shift and go to state 62
    U32             shift and go to state 63
    U64             shift and go to state 64
    U128            shift and go to state 65
    USIZE           shift and go to state 66
    F32             shift and go to state 67
    F64             shift and go to state 68

    asignacion                     shift and go to state 205
    asig_data_type                 shift and go to state 206
    string_asignacion              shift and go to state 153
    numero_asignacion              shift and go to state 154
    boolean_asignacion             shift and go to state 155
    lista_asignacion               shift and go to state 156
    tupla_asignacion               shift and go to state 157
    data_type                      shift and go to state 44
    list_type                      shift and go to state 158
    tuple_type                     shift and go to state 159
    signed_integer                 shift and go to state 161
    unsigned_integer               shift and go to state 162
    float_type                     shift and go to state 163

state 167

    (120) llamada -> IDENTIFIER LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 120 (llamada -> IDENTIFIER LPAREN valores RPAREN .)


state 168

    (58) impresion -> PRINTLN EXCLAMATION LPAREN valor . RPAREN
    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor . COMMA valores RPAREN

    RPAREN          shift and go to state 207
    COMMA           shift and go to state 208


state 169

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON . DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 209


state 170

    (100) valores -> valor COMMA valores .

    RCORCH          reduce using rule 100 (valores -> valor COMMA valores .)
    RPAREN          reduce using rule 100 (valores -> valor COMMA valores .)


state 171

    (119) indexacion -> IDENTIFIER LCORCH INTEGER . RCORCH

    RCORCH          shift and go to state 210


state 172

    (112) operacion -> numeric PLUS numeric .

    COMMA           reduce using rule 112 (operacion -> numeric PLUS numeric .)
    RCORCH          reduce using rule 112 (operacion -> numeric PLUS numeric .)
    EQ              reduce using rule 112 (operacion -> numeric PLUS numeric .)
    NEQ             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    GEQ             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    LEQ             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    RIGHTARROW      reduce using rule 112 (operacion -> numeric PLUS numeric .)
    LEFTARROW       reduce using rule 112 (operacion -> numeric PLUS numeric .)
    RPAREN          reduce using rule 112 (operacion -> numeric PLUS numeric .)
    SEMICOLON       reduce using rule 112 (operacion -> numeric PLUS numeric .)
    LLLAVE          reduce using rule 112 (operacion -> numeric PLUS numeric .)
    AND             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    OR              reduce using rule 112 (operacion -> numeric PLUS numeric .)


state 173

    (107) numeric -> INTEGER .

    COMMA           reduce using rule 107 (numeric -> INTEGER .)
    RCORCH          reduce using rule 107 (numeric -> INTEGER .)
    EQ              reduce using rule 107 (numeric -> INTEGER .)
    NEQ             reduce using rule 107 (numeric -> INTEGER .)
    GEQ             reduce using rule 107 (numeric -> INTEGER .)
    LEQ             reduce using rule 107 (numeric -> INTEGER .)
    RIGHTARROW      reduce using rule 107 (numeric -> INTEGER .)
    LEFTARROW       reduce using rule 107 (numeric -> INTEGER .)
    RPAREN          reduce using rule 107 (numeric -> INTEGER .)
    SEMICOLON       reduce using rule 107 (numeric -> INTEGER .)
    LLLAVE          reduce using rule 107 (numeric -> INTEGER .)
    AND             reduce using rule 107 (numeric -> INTEGER .)
    OR              reduce using rule 107 (numeric -> INTEGER .)


state 174

    (108) numeric -> FLOAT .

    COMMA           reduce using rule 108 (numeric -> FLOAT .)
    RCORCH          reduce using rule 108 (numeric -> FLOAT .)
    EQ              reduce using rule 108 (numeric -> FLOAT .)
    NEQ             reduce using rule 108 (numeric -> FLOAT .)
    GEQ             reduce using rule 108 (numeric -> FLOAT .)
    LEQ             reduce using rule 108 (numeric -> FLOAT .)
    RIGHTARROW      reduce using rule 108 (numeric -> FLOAT .)
    LEFTARROW       reduce using rule 108 (numeric -> FLOAT .)
    RPAREN          reduce using rule 108 (numeric -> FLOAT .)
    SEMICOLON       reduce using rule 108 (numeric -> FLOAT .)
    LLLAVE          reduce using rule 108 (numeric -> FLOAT .)
    AND             reduce using rule 108 (numeric -> FLOAT .)
    OR              reduce using rule 108 (numeric -> FLOAT .)


state 175

    (109) numeric -> IDENTIFIER .

    COMMA           reduce using rule 109 (numeric -> IDENTIFIER .)
    RCORCH          reduce using rule 109 (numeric -> IDENTIFIER .)
    EQ              reduce using rule 109 (numeric -> IDENTIFIER .)
    NEQ             reduce using rule 109 (numeric -> IDENTIFIER .)
    GEQ             reduce using rule 109 (numeric -> IDENTIFIER .)
    LEQ             reduce using rule 109 (numeric -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 109 (numeric -> IDENTIFIER .)
    LEFTARROW       reduce using rule 109 (numeric -> IDENTIFIER .)
    RPAREN          reduce using rule 109 (numeric -> IDENTIFIER .)
    SEMICOLON       reduce using rule 109 (numeric -> IDENTIFIER .)
    LLLAVE          reduce using rule 109 (numeric -> IDENTIFIER .)
    AND             reduce using rule 109 (numeric -> IDENTIFIER .)
    OR              reduce using rule 109 (numeric -> IDENTIFIER .)


state 176

    (113) operacion -> numeric MINUS numeric .

    COMMA           reduce using rule 113 (operacion -> numeric MINUS numeric .)
    RCORCH          reduce using rule 113 (operacion -> numeric MINUS numeric .)
    EQ              reduce using rule 113 (operacion -> numeric MINUS numeric .)
    NEQ             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    GEQ             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    LEQ             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    RIGHTARROW      reduce using rule 113 (operacion -> numeric MINUS numeric .)
    LEFTARROW       reduce using rule 113 (operacion -> numeric MINUS numeric .)
    RPAREN          reduce using rule 113 (operacion -> numeric MINUS numeric .)
    SEMICOLON       reduce using rule 113 (operacion -> numeric MINUS numeric .)
    LLLAVE          reduce using rule 113 (operacion -> numeric MINUS numeric .)
    AND             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    OR              reduce using rule 113 (operacion -> numeric MINUS numeric .)


state 177

    (114) operacion -> numeric TIMES numeric .

    COMMA           reduce using rule 114 (operacion -> numeric TIMES numeric .)
    RCORCH          reduce using rule 114 (operacion -> numeric TIMES numeric .)
    EQ              reduce using rule 114 (operacion -> numeric TIMES numeric .)
    NEQ             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    GEQ             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    LEQ             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    RIGHTARROW      reduce using rule 114 (operacion -> numeric TIMES numeric .)
    LEFTARROW       reduce using rule 114 (operacion -> numeric TIMES numeric .)
    RPAREN          reduce using rule 114 (operacion -> numeric TIMES numeric .)
    SEMICOLON       reduce using rule 114 (operacion -> numeric TIMES numeric .)
    LLLAVE          reduce using rule 114 (operacion -> numeric TIMES numeric .)
    AND             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    OR              reduce using rule 114 (operacion -> numeric TIMES numeric .)


state 178

    (115) operacion -> numeric DIVIDE numeric .

    COMMA           reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    RCORCH          reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    EQ              reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    NEQ             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    GEQ             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    LEQ             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    RIGHTARROW      reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    LEFTARROW       reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    RPAREN          reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    SEMICOLON       reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    LLLAVE          reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    AND             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    OR              reduce using rule 115 (operacion -> numeric DIVIDE numeric .)


state 179

    (116) operacion -> numeric MOD numeric .

    COMMA           reduce using rule 116 (operacion -> numeric MOD numeric .)
    RCORCH          reduce using rule 116 (operacion -> numeric MOD numeric .)
    EQ              reduce using rule 116 (operacion -> numeric MOD numeric .)
    NEQ             reduce using rule 116 (operacion -> numeric MOD numeric .)
    GEQ             reduce using rule 116 (operacion -> numeric MOD numeric .)
    LEQ             reduce using rule 116 (operacion -> numeric MOD numeric .)
    RIGHTARROW      reduce using rule 116 (operacion -> numeric MOD numeric .)
    LEFTARROW       reduce using rule 116 (operacion -> numeric MOD numeric .)
    RPAREN          reduce using rule 116 (operacion -> numeric MOD numeric .)
    SEMICOLON       reduce using rule 116 (operacion -> numeric MOD numeric .)
    LLLAVE          reduce using rule 116 (operacion -> numeric MOD numeric .)
    AND             reduce using rule 116 (operacion -> numeric MOD numeric .)
    OR              reduce using rule 116 (operacion -> numeric MOD numeric .)


state 180

    (117) operacion -> numeric INTD numeric .

    COMMA           reduce using rule 117 (operacion -> numeric INTD numeric .)
    RCORCH          reduce using rule 117 (operacion -> numeric INTD numeric .)
    EQ              reduce using rule 117 (operacion -> numeric INTD numeric .)
    NEQ             reduce using rule 117 (operacion -> numeric INTD numeric .)
    GEQ             reduce using rule 117 (operacion -> numeric INTD numeric .)
    LEQ             reduce using rule 117 (operacion -> numeric INTD numeric .)
    RIGHTARROW      reduce using rule 117 (operacion -> numeric INTD numeric .)
    LEFTARROW       reduce using rule 117 (operacion -> numeric INTD numeric .)
    RPAREN          reduce using rule 117 (operacion -> numeric INTD numeric .)
    SEMICOLON       reduce using rule 117 (operacion -> numeric INTD numeric .)
    LLLAVE          reduce using rule 117 (operacion -> numeric INTD numeric .)
    AND             reduce using rule 117 (operacion -> numeric INTD numeric .)
    OR              reduce using rule 117 (operacion -> numeric INTD numeric .)


state 181

    (118) operacion -> cadena PLUS cadena .

    COMMA           reduce using rule 118 (operacion -> cadena PLUS cadena .)
    RCORCH          reduce using rule 118 (operacion -> cadena PLUS cadena .)
    EQ              reduce using rule 118 (operacion -> cadena PLUS cadena .)
    NEQ             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    GEQ             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    LEQ             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    RIGHTARROW      reduce using rule 118 (operacion -> cadena PLUS cadena .)
    LEFTARROW       reduce using rule 118 (operacion -> cadena PLUS cadena .)
    RPAREN          reduce using rule 118 (operacion -> cadena PLUS cadena .)
    SEMICOLON       reduce using rule 118 (operacion -> cadena PLUS cadena .)
    LLLAVE          reduce using rule 118 (operacion -> cadena PLUS cadena .)
    AND             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    OR              reduce using rule 118 (operacion -> cadena PLUS cadena .)


state 182

    (110) cadena -> STRING .

    COMMA           reduce using rule 110 (cadena -> STRING .)
    RCORCH          reduce using rule 110 (cadena -> STRING .)
    EQ              reduce using rule 110 (cadena -> STRING .)
    NEQ             reduce using rule 110 (cadena -> STRING .)
    GEQ             reduce using rule 110 (cadena -> STRING .)
    LEQ             reduce using rule 110 (cadena -> STRING .)
    RIGHTARROW      reduce using rule 110 (cadena -> STRING .)
    LEFTARROW       reduce using rule 110 (cadena -> STRING .)
    RPAREN          reduce using rule 110 (cadena -> STRING .)
    SEMICOLON       reduce using rule 110 (cadena -> STRING .)
    LLLAVE          reduce using rule 110 (cadena -> STRING .)
    AND             reduce using rule 110 (cadena -> STRING .)
    OR              reduce using rule 110 (cadena -> STRING .)


state 183

    (111) cadena -> IDENTIFIER .

    COMMA           reduce using rule 111 (cadena -> IDENTIFIER .)
    RCORCH          reduce using rule 111 (cadena -> IDENTIFIER .)
    EQ              reduce using rule 111 (cadena -> IDENTIFIER .)
    NEQ             reduce using rule 111 (cadena -> IDENTIFIER .)
    GEQ             reduce using rule 111 (cadena -> IDENTIFIER .)
    LEQ             reduce using rule 111 (cadena -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 111 (cadena -> IDENTIFIER .)
    LEFTARROW       reduce using rule 111 (cadena -> IDENTIFIER .)
    RPAREN          reduce using rule 111 (cadena -> IDENTIFIER .)
    SEMICOLON       reduce using rule 111 (cadena -> IDENTIFIER .)
    LLLAVE          reduce using rule 111 (cadena -> IDENTIFIER .)
    AND             reduce using rule 111 (cadena -> IDENTIFIER .)
    OR              reduce using rule 111 (cadena -> IDENTIFIER .)


state 184

    (105) condicional -> IF comparacion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 211


state 185

    (103) proposicion -> comparacion . conector proposicion
    (104) proposicion -> comparacion .
    (101) conector -> . AND
    (102) conector -> . OR

    LLLAVE          reduce using rule 104 (proposicion -> comparacion .)
    AND             shift and go to state 134
    OR              shift and go to state 135

    conector                       shift and go to state 133

state 186

    (103) proposicion -> comparacion conector proposicion .

    LLLAVE          reduce using rule 103 (proposicion -> comparacion conector proposicion .)


state 187

    (106) condicional -> IF proposicion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 212


state 188

    (32) comparacion -> valor EQ valor .

    LLLAVE          reduce using rule 32 (comparacion -> valor EQ valor .)
    AND             reduce using rule 32 (comparacion -> valor EQ valor .)
    OR              reduce using rule 32 (comparacion -> valor EQ valor .)


state 189

    (33) comparacion -> valor NEQ valor .

    LLLAVE          reduce using rule 33 (comparacion -> valor NEQ valor .)
    AND             reduce using rule 33 (comparacion -> valor NEQ valor .)
    OR              reduce using rule 33 (comparacion -> valor NEQ valor .)


state 190

    (34) comparacion -> valor GEQ valor .

    LLLAVE          reduce using rule 34 (comparacion -> valor GEQ valor .)
    AND             reduce using rule 34 (comparacion -> valor GEQ valor .)
    OR              reduce using rule 34 (comparacion -> valor GEQ valor .)


state 191

    (35) comparacion -> valor LEQ valor .

    LLLAVE          reduce using rule 35 (comparacion -> valor LEQ valor .)
    AND             reduce using rule 35 (comparacion -> valor LEQ valor .)
    OR              reduce using rule 35 (comparacion -> valor LEQ valor .)


state 192

    (36) comparacion -> valor RIGHTARROW valor .

    LLLAVE          reduce using rule 36 (comparacion -> valor RIGHTARROW valor .)
    AND             reduce using rule 36 (comparacion -> valor RIGHTARROW valor .)
    OR              reduce using rule 36 (comparacion -> valor RIGHTARROW valor .)


state 193

    (37) comparacion -> valor LEFTARROW valor .

    LLLAVE          reduce using rule 37 (comparacion -> valor LEFTARROW valor .)
    AND             reduce using rule 37 (comparacion -> valor LEFTARROW valor .)
    OR              reduce using rule 37 (comparacion -> valor LEFTARROW valor .)


state 194

    (95) some_data_type -> data_type COMMA some_data_type .

    RCORCH          reduce using rule 95 (some_data_type -> data_type COMMA some_data_type .)
    RPAREN          reduce using rule 95 (some_data_type -> data_type COMMA some_data_type .)


state 195

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (122) sentencias -> . error
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (121) llamada -> . IDENTIFIER LPAREN RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    error           shift and go to state 35
    LET             shift and go to state 36
    PRINTLN         shift and go to state 38
    STD             shift and go to state 39
    LCORCH          shift and go to state 40
    IDENTIFIER      shift and go to state 37
    IF              shift and go to state 42

    programa                       shift and go to state 213
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 41

state 196

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (64) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 215

    retorno                        shift and go to state 214

state 197

    (30) lista_asignacion -> list_type ASIG . arreglos
    (97) arreglos -> . LCORCH valores RCORCH

    LCORCH          shift and go to state 40

    arreglos                       shift and go to state 216

state 198

    (31) tupla_asignacion -> tuple_type ASIG . tuplas
    (98) tuplas -> . LPAREN valores RPAREN

    LPAREN          shift and go to state 218

    tuplas                         shift and go to state 217

state 199

    (22) string_asignacion -> REFERENCE STR . ASIG STRING
    (75) data_type -> REFERENCE STR .

    ASIG            shift and go to state 219
    SEMICOLON       reduce using rule 75 (data_type -> REFERENCE STR .)


state 200

    (23) numero_asignacion -> signed_integer ASIG . INTEGER
    (24) numero_asignacion -> signed_integer ASIG . MINUS INTEGER

    INTEGER         shift and go to state 220
    MINUS           shift and go to state 221


state 201

    (25) numero_asignacion -> unsigned_integer ASIG . INTEGER

    INTEGER         shift and go to state 222


state 202

    (26) numero_asignacion -> float_type ASIG . FLOAT
    (27) numero_asignacion -> float_type ASIG . MINUS FLOAT

    FLOAT           shift and go to state 223
    MINUS           shift and go to state 224


state 203

    (28) boolean_asignacion -> BOOL ASIG . TRUE
    (29) boolean_asignacion -> BOOL ASIG . FALSE

    TRUE            shift and go to state 225
    FALSE           shift and go to state 226


state 204

    (10) asignacion_variable -> LET MUT IDENTIFIER ASIG valor .

    SEMICOLON       reduce using rule 10 (asignacion_variable -> LET MUT IDENTIFIER ASIG valor .)


state 205

    (12) asignacion_variable -> LET MUT IDENTIFIER COLON asignacion .

    SEMICOLON       reduce using rule 12 (asignacion_variable -> LET MUT IDENTIFIER COLON asignacion .)


state 206

    (16) declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type .

    SEMICOLON       reduce using rule 16 (declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type .)


state 207

    (58) impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 58 (impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .)


state 208

    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA . valores RPAREN
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 87
    valores                        shift and go to state 227
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 209

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT . STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    STDIN           shift and go to state 228


state 210

    (119) indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .

    COMMA           reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RCORCH          reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    EQ              reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    NEQ             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    GEQ             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEQ             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RIGHTARROW      reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEFTARROW       reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RPAREN          reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    SEMICOLON       reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LLLAVE          reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    AND             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    OR              reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)


state 211

    (105) condicional -> IF comparacion LLLAVE programa RLLAVE .

    error           reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    LET             reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    STD             reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IF              reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)


state 212

    (106) condicional -> IF proposicion LLLAVE programa RLLAVE .

    error           reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    LET             reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    STD             reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IF              reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)


state 213

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (64) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 215

    retorno                        shift and go to state 229

state 214

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 230


state 215

    (64) retorno -> RETURN . valor SEMICOLON
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valor                          shift and go to state 231
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 216

    (30) lista_asignacion -> list_type ASIG arreglos .

    SEMICOLON       reduce using rule 30 (lista_asignacion -> list_type ASIG arreglos .)


state 217

    (31) tupla_asignacion -> tuple_type ASIG tuplas .

    SEMICOLON       reduce using rule 31 (tupla_asignacion -> tuple_type ASIG tuplas .)


state 218

    (98) tuplas -> LPAREN . valores RPAREN
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . MINUS INTEGER
    (40) valor -> . FLOAT
    (41) valor -> . MINUS FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 88
    MINUS           shift and go to state 89
    FLOAT           shift and go to state 90
    IDENTIFIER      shift and go to state 91
    STRING          shift and go to state 95
    LCORCH          shift and go to state 40
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100

    valores                        shift and go to state 232
    valor                          shift and go to state 87
    operacion                      shift and go to state 92
    indexacion                     shift and go to state 93
    arreglos                       shift and go to state 94
    booleanos                      shift and go to state 96
    numeric                        shift and go to state 97
    cadena                         shift and go to state 98

state 219

    (22) string_asignacion -> REFERENCE STR ASIG . STRING

    STRING          shift and go to state 233


state 220

    (23) numero_asignacion -> signed_integer ASIG INTEGER .

    SEMICOLON       reduce using rule 23 (numero_asignacion -> signed_integer ASIG INTEGER .)


state 221

    (24) numero_asignacion -> signed_integer ASIG MINUS . INTEGER

    INTEGER         shift and go to state 234


state 222

    (25) numero_asignacion -> unsigned_integer ASIG INTEGER .

    SEMICOLON       reduce using rule 25 (numero_asignacion -> unsigned_integer ASIG INTEGER .)


state 223

    (26) numero_asignacion -> float_type ASIG FLOAT .

    SEMICOLON       reduce using rule 26 (numero_asignacion -> float_type ASIG FLOAT .)


state 224

    (27) numero_asignacion -> float_type ASIG MINUS . FLOAT

    FLOAT           shift and go to state 235


state 225

    (28) boolean_asignacion -> BOOL ASIG TRUE .

    SEMICOLON       reduce using rule 28 (boolean_asignacion -> BOOL ASIG TRUE .)


state 226

    (29) boolean_asignacion -> BOOL ASIG FALSE .

    SEMICOLON       reduce using rule 29 (boolean_asignacion -> BOOL ASIG FALSE .)


state 227

    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores . RPAREN

    RPAREN          shift and go to state 236


state 228

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN . LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 237


state 229

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 238


state 230

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    FN              reduce using rule 63 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 63 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 231

    (64) retorno -> RETURN valor . SEMICOLON

    SEMICOLON       shift and go to state 239


state 232

    (98) tuplas -> LPAREN valores . RPAREN

    RPAREN          shift and go to state 240


state 233

    (22) string_asignacion -> REFERENCE STR ASIG STRING .

    SEMICOLON       reduce using rule 22 (string_asignacion -> REFERENCE STR ASIG STRING .)


state 234

    (24) numero_asignacion -> signed_integer ASIG MINUS INTEGER .

    SEMICOLON       reduce using rule 24 (numero_asignacion -> signed_integer ASIG MINUS INTEGER .)


state 235

    (27) numero_asignacion -> float_type ASIG MINUS FLOAT .

    SEMICOLON       reduce using rule 27 (numero_asignacion -> float_type ASIG MINUS FLOAT .)


state 236

    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .

    SEMICOLON       reduce using rule 59 (impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .)


state 237

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN . RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    RPAREN          shift and go to state 241


state 238

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    FN              reduce using rule 62 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 62 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 239

    (64) retorno -> RETURN valor SEMICOLON .

    RLLAVE          reduce using rule 64 (retorno -> RETURN valor SEMICOLON .)


state 240

    (98) tuplas -> LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 98 (tuplas -> LPAREN valores RPAREN .)


state 241

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN . DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 242


state 242

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT . READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    READLINE        shift and go to state 243


state 243

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE . LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 244


state 244

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN . REFERENCE MUT IDENTIFIER RPAREN

    REFERENCE       shift and go to state 245


state 245

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE . MUT IDENTIFIER RPAREN

    MUT             shift and go to state 246


state 246

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 247


state 247

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER . RPAREN

    RPAREN          shift and go to state 248


state 248

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .

    SEMICOLON       reduce using rule 68 (ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 15 resolved as shift
WARNING: shift/reduce conflict for LLLAVE in state 101 resolved as shift
WARNING: reduce/reduce conflict in state 91 resolved using rule (numeric -> IDENTIFIER)
WARNING: rejected rule (cadena -> IDENTIFIER) in state 91
