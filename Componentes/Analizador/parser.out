Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ASIG
    BOOL
    CHAR
    COLON
    COMMA
    DIVIDE
    DOUBLE_QUOTATION_MARK
    ELSE
    EXCLAMATION
    F32
    F64
    FALSE
    FOR
    FROM
    GEQ
    I16
    I32
    I64
    I8
    IF
    IMPL
    IN
    INTD
    ISIZE
    LEFTARROW
    LEQ
    MAIN
    MATCH
    MINUS
    MOD
    NEQ
    NOT
    OR
    PLUS
    QUOTATION_MARK
    RAND
    RETURN
    RIGHTARROW
    SELF
    STR
    STRING
    STRUCT
    TIMES
    TRUE
    U128
    U16
    U32
    U64
    U8
    USIZE
    WHILE

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencias
Rule 2     programa -> sentencias programa
Rule 3     asignacion -> LET IDENTIFIER EQ valor
Rule 4     valor -> INTEGER
Rule 5     valor -> FLOAT
Rule 6     valor -> IDENTIFIER
Rule 7     sentencias -> asignacion SEMICOLON
Rule 8     sentencias -> impresion SEMICOLON
Rule 9     sentencias -> funcion SEMICOLON
Rule 10    sentencias -> ingreso_datos SEMICOLON
Rule 11    sentencias -> arreglos SEMICOLON
Rule 12    impresion -> PRINTLN LPAREN valor RPAREN
Rule 13    funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
Rule 14    ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
Rule 15    arreglos -> LCORCH valor RCORCH

Terminals, with rules where they appear

AND                  : 
ASIG                 : 
BOOL                 : 
CHAR                 : 
COLON                : 
COMMA                : 
DIVIDE               : 
DOT                  : 14 14
DOUBLE_COLON         : 14 14
DOUBLE_QUOTATION_MARK : 
ELSE                 : 
EQ                   : 3
EXCLAMATION          : 
F32                  : 
F64                  : 
FALSE                : 
FLOAT                : 5
FN                   : 13
FOR                  : 
FROM                 : 
GEQ                  : 
I16                  : 
I32                  : 
I64                  : 
I8                   : 
IDENTIFIER           : 3 6 13 14
IF                   : 
IMPL                 : 
IN                   : 
INTD                 : 
INTEGER              : 4
IO                   : 14
ISIZE                : 
LCORCH               : 15
LEFTARROW            : 
LEQ                  : 
LET                  : 3
LLLAVE               : 13
LPAREN               : 12 13 14 14
MAIN                 : 
MATCH                : 
MINUS                : 
MOD                  : 
MUT                  : 14
NEQ                  : 
NOT                  : 
OR                   : 
PLUS                 : 
PRINTLN              : 12
QUOTATION_MARK       : 
RAND                 : 
RCORCH               : 15
READLINE             : 14
REFERENCE            : 14
RETURN               : 
RIGHTARROW           : 
RLLAVE               : 13
RPAREN               : 12 13 14 14
SELF                 : 
SEMICOLON            : 7 8 9 10 11
STD                  : 14
STDIN                : 14
STR                  : 
STRING               : 
STRUCT               : 
TIMES                : 
TRUE                 : 
U128                 : 
U16                  : 
U32                  : 
U64                  : 
U8                   : 
USIZE                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arreglos             : 11
asignacion           : 7
funcion              : 9
impresion            : 8
ingreso_datos        : 10
programa             : 2 13 0
sentencias           : 1 2
valor                : 3 12 15

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (7) sentencias -> . asignacion SEMICOLON
    (8) sentencias -> . impresion SEMICOLON
    (9) sentencias -> . funcion SEMICOLON
    (10) sentencias -> . ingreso_datos SEMICOLON
    (11) sentencias -> . arreglos SEMICOLON
    (3) asignacion -> . LET IDENTIFIER EQ valor
    (12) impresion -> . PRINTLN LPAREN valor RPAREN
    (13) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (14) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (15) arreglos -> . LCORCH valor RCORCH

    LET             shift and go to state 8
    PRINTLN         shift and go to state 9
    FN              shift and go to state 10
    STD             shift and go to state 11
    LCORCH          shift and go to state 12

    programa                       shift and go to state 1
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencias .
    (2) programa -> sentencias . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (7) sentencias -> . asignacion SEMICOLON
    (8) sentencias -> . impresion SEMICOLON
    (9) sentencias -> . funcion SEMICOLON
    (10) sentencias -> . ingreso_datos SEMICOLON
    (11) sentencias -> . arreglos SEMICOLON
    (3) asignacion -> . LET IDENTIFIER EQ valor
    (12) impresion -> . PRINTLN LPAREN valor RPAREN
    (13) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (14) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (15) arreglos -> . LCORCH valor RCORCH

    $end            reduce using rule 1 (programa -> sentencias .)
    RLLAVE          reduce using rule 1 (programa -> sentencias .)
    LET             shift and go to state 8
    PRINTLN         shift and go to state 9
    FN              shift and go to state 10
    STD             shift and go to state 11
    LCORCH          shift and go to state 12

    sentencias                     shift and go to state 2
    programa                       shift and go to state 13
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7

state 3

    (7) sentencias -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 14


state 4

    (8) sentencias -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 15


state 5

    (9) sentencias -> funcion . SEMICOLON

    SEMICOLON       shift and go to state 16


state 6

    (10) sentencias -> ingreso_datos . SEMICOLON

    SEMICOLON       shift and go to state 17


state 7

    (11) sentencias -> arreglos . SEMICOLON

    SEMICOLON       shift and go to state 18


state 8

    (3) asignacion -> LET . IDENTIFIER EQ valor

    IDENTIFIER      shift and go to state 19


state 9

    (12) impresion -> PRINTLN . LPAREN valor RPAREN

    LPAREN          shift and go to state 20


state 10

    (13) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE

    IDENTIFIER      shift and go to state 21


state 11

    (14) ingreso_datos -> STD . DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 22


state 12

    (15) arreglos -> LCORCH . valor RCORCH
    (4) valor -> . INTEGER
    (5) valor -> . FLOAT
    (6) valor -> . IDENTIFIER

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 26

    valor                          shift and go to state 23

state 13

    (2) programa -> sentencias programa .

    $end            reduce using rule 2 (programa -> sentencias programa .)
    RLLAVE          reduce using rule 2 (programa -> sentencias programa .)


state 14

    (7) sentencias -> asignacion SEMICOLON .

    LET             reduce using rule 7 (sentencias -> asignacion SEMICOLON .)
    PRINTLN         reduce using rule 7 (sentencias -> asignacion SEMICOLON .)
    FN              reduce using rule 7 (sentencias -> asignacion SEMICOLON .)
    STD             reduce using rule 7 (sentencias -> asignacion SEMICOLON .)
    LCORCH          reduce using rule 7 (sentencias -> asignacion SEMICOLON .)
    $end            reduce using rule 7 (sentencias -> asignacion SEMICOLON .)
    RLLAVE          reduce using rule 7 (sentencias -> asignacion SEMICOLON .)


state 15

    (8) sentencias -> impresion SEMICOLON .

    LET             reduce using rule 8 (sentencias -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 8 (sentencias -> impresion SEMICOLON .)
    FN              reduce using rule 8 (sentencias -> impresion SEMICOLON .)
    STD             reduce using rule 8 (sentencias -> impresion SEMICOLON .)
    LCORCH          reduce using rule 8 (sentencias -> impresion SEMICOLON .)
    $end            reduce using rule 8 (sentencias -> impresion SEMICOLON .)
    RLLAVE          reduce using rule 8 (sentencias -> impresion SEMICOLON .)


state 16

    (9) sentencias -> funcion SEMICOLON .

    LET             reduce using rule 9 (sentencias -> funcion SEMICOLON .)
    PRINTLN         reduce using rule 9 (sentencias -> funcion SEMICOLON .)
    FN              reduce using rule 9 (sentencias -> funcion SEMICOLON .)
    STD             reduce using rule 9 (sentencias -> funcion SEMICOLON .)
    LCORCH          reduce using rule 9 (sentencias -> funcion SEMICOLON .)
    $end            reduce using rule 9 (sentencias -> funcion SEMICOLON .)
    RLLAVE          reduce using rule 9 (sentencias -> funcion SEMICOLON .)


state 17

    (10) sentencias -> ingreso_datos SEMICOLON .

    LET             reduce using rule 10 (sentencias -> ingreso_datos SEMICOLON .)
    PRINTLN         reduce using rule 10 (sentencias -> ingreso_datos SEMICOLON .)
    FN              reduce using rule 10 (sentencias -> ingreso_datos SEMICOLON .)
    STD             reduce using rule 10 (sentencias -> ingreso_datos SEMICOLON .)
    LCORCH          reduce using rule 10 (sentencias -> ingreso_datos SEMICOLON .)
    $end            reduce using rule 10 (sentencias -> ingreso_datos SEMICOLON .)
    RLLAVE          reduce using rule 10 (sentencias -> ingreso_datos SEMICOLON .)


state 18

    (11) sentencias -> arreglos SEMICOLON .

    LET             reduce using rule 11 (sentencias -> arreglos SEMICOLON .)
    PRINTLN         reduce using rule 11 (sentencias -> arreglos SEMICOLON .)
    FN              reduce using rule 11 (sentencias -> arreglos SEMICOLON .)
    STD             reduce using rule 11 (sentencias -> arreglos SEMICOLON .)
    LCORCH          reduce using rule 11 (sentencias -> arreglos SEMICOLON .)
    $end            reduce using rule 11 (sentencias -> arreglos SEMICOLON .)
    RLLAVE          reduce using rule 11 (sentencias -> arreglos SEMICOLON .)


state 19

    (3) asignacion -> LET IDENTIFIER . EQ valor

    EQ              shift and go to state 27


state 20

    (12) impresion -> PRINTLN LPAREN . valor RPAREN
    (4) valor -> . INTEGER
    (5) valor -> . FLOAT
    (6) valor -> . IDENTIFIER

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 26

    valor                          shift and go to state 28

state 21

    (13) funcion -> FN IDENTIFIER . LPAREN RPAREN LLLAVE programa RLLAVE

    LPAREN          shift and go to state 29


state 22

    (14) ingreso_datos -> STD DOUBLE_COLON . IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    IO              shift and go to state 30


state 23

    (15) arreglos -> LCORCH valor . RCORCH

    RCORCH          shift and go to state 31


state 24

    (4) valor -> INTEGER .

    RCORCH          reduce using rule 4 (valor -> INTEGER .)
    RPAREN          reduce using rule 4 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 4 (valor -> INTEGER .)


state 25

    (5) valor -> FLOAT .

    RCORCH          reduce using rule 5 (valor -> FLOAT .)
    RPAREN          reduce using rule 5 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 5 (valor -> FLOAT .)


state 26

    (6) valor -> IDENTIFIER .

    RCORCH          reduce using rule 6 (valor -> IDENTIFIER .)
    RPAREN          reduce using rule 6 (valor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 6 (valor -> IDENTIFIER .)


state 27

    (3) asignacion -> LET IDENTIFIER EQ . valor
    (4) valor -> . INTEGER
    (5) valor -> . FLOAT
    (6) valor -> . IDENTIFIER

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 26

    valor                          shift and go to state 32

state 28

    (12) impresion -> PRINTLN LPAREN valor . RPAREN

    RPAREN          shift and go to state 33


state 29

    (13) funcion -> FN IDENTIFIER LPAREN . RPAREN LLLAVE programa RLLAVE

    RPAREN          shift and go to state 34


state 30

    (14) ingreso_datos -> STD DOUBLE_COLON IO . DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 35


state 31

    (15) arreglos -> LCORCH valor RCORCH .

    SEMICOLON       reduce using rule 15 (arreglos -> LCORCH valor RCORCH .)


state 32

    (3) asignacion -> LET IDENTIFIER EQ valor .

    SEMICOLON       reduce using rule 3 (asignacion -> LET IDENTIFIER EQ valor .)


state 33

    (12) impresion -> PRINTLN LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 12 (impresion -> PRINTLN LPAREN valor RPAREN .)


state 34

    (13) funcion -> FN IDENTIFIER LPAREN RPAREN . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 36


state 35

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON . DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 37


state 36

    (13) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (7) sentencias -> . asignacion SEMICOLON
    (8) sentencias -> . impresion SEMICOLON
    (9) sentencias -> . funcion SEMICOLON
    (10) sentencias -> . ingreso_datos SEMICOLON
    (11) sentencias -> . arreglos SEMICOLON
    (3) asignacion -> . LET IDENTIFIER EQ valor
    (12) impresion -> . PRINTLN LPAREN valor RPAREN
    (13) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (14) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (15) arreglos -> . LCORCH valor RCORCH

    LET             shift and go to state 8
    PRINTLN         shift and go to state 9
    FN              shift and go to state 10
    STD             shift and go to state 11
    LCORCH          shift and go to state 12

    programa                       shift and go to state 38
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7

state 37

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT . STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    STDIN           shift and go to state 39


state 38

    (13) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 40


state 39

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN . LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 41


state 40

    (13) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .

    SEMICOLON       reduce using rule 13 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)


state 41

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN . RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    RPAREN          shift and go to state 42


state 42

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN . DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 43


state 43

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT . READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    READLINE        shift and go to state 44


state 44

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE . LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 45


state 45

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN . REFERENCE MUT IDENTIFIER RPAREN

    REFERENCE       shift and go to state 46


state 46

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE . MUT IDENTIFIER RPAREN

    MUT             shift and go to state 47


state 47

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 48


state 48

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER . RPAREN

    RPAREN          shift and go to state 49


state 49

    (14) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .

    SEMICOLON       reduce using rule 14 (ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .)

