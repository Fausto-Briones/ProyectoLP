Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOUBLE_QUOTATION_MARK
    ELSE
    FOR
    FROM
    IMPL
    IN
    MATCH
    NOT
    QUOTATION_MARK
    RAND
    SELF
    STRUCT
    WHILE

Grammar

Rule 0     S' -> codigoRust
Rule 1     codigoRust -> funciones main funciones
Rule 2     codigoRust -> funciones main
Rule 3     codigoRust -> main funciones
Rule 4     codigoRust -> main
Rule 5     funciones -> funcion
Rule 6     funciones -> funcion funciones
Rule 7     programa -> sentencias
Rule 8     programa -> sentencias programa
Rule 9     asignacion_variable -> LET IDENTIFIER ASIG valor
Rule 10    asignacion_variable -> LET MUT ASIG valor
Rule 11    asignacion_variable -> LET IDENTIFIER COLON asignacion
Rule 12    asignacion_variable -> LET MUT IDENTIFIER COLON asignacion
Rule 13    declaracion_variable -> LET IDENTIFIER
Rule 14    declaracion_variable -> LET MUT IDENTIFIER
Rule 15    declaracion_variable -> LET IDENTIFIER COLON asig_data_type
Rule 16    declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type
Rule 17    asignacion -> string_asignacion
Rule 18    asignacion -> char_asignacion
Rule 19    asignacion -> numero_asignacion
Rule 20    asignacion -> boolean_asignacion
Rule 21    asignacion -> lista_asignacion
Rule 22    asignacion -> tupla_asignacion
Rule 23    string_asignacion -> REFERENCE STR ASIG STRING
Rule 24    char_asignacion -> CHAR ASIG CHARACTER
Rule 25    numero_asignacion -> signed_integer ASIG INTEGER
Rule 26    numero_asignacion -> signed_integer ASIG MINUS INTEGER
Rule 27    numero_asignacion -> unsigned_integer ASIG INTEGER
Rule 28    numero_asignacion -> float_type ASIG FLOAT
Rule 29    numero_asignacion -> float_type ASIG MINUS FLOAT
Rule 30    boolean_asignacion -> BOOL ASIG TRUE
Rule 31    boolean_asignacion -> BOOL ASIG FALSE
Rule 32    lista_asignacion -> list_type ASIG arreglos
Rule 33    tupla_asignacion -> tuple_type ASIG tuplas
Rule 34    comparacion -> valor EQ valor
Rule 35    comparacion -> valor NEQ valor
Rule 36    comparacion -> valor GEQ valor
Rule 37    comparacion -> valor LEQ valor
Rule 38    comparacion -> valor RIGHTARROW valor
Rule 39    comparacion -> valor LEFTARROW valor
Rule 40    valor -> INTEGER
Rule 41    valor -> FLOAT
Rule 42    valor -> IDENTIFIER
Rule 43    valor -> operacion
Rule 44    valor -> indexacion
Rule 45    valor -> arreglos
Rule 46    valor -> STRING
Rule 47    valor -> booleanos
Rule 48    booleanos -> TRUE
Rule 49    booleanos -> FALSE
Rule 50    vacio -> <empty>
Rule 51    sentencias -> asignacion_variable SEMICOLON
Rule 52    sentencias -> declaracion_variable SEMICOLON
Rule 53    sentencias -> impresion SEMICOLON
Rule 54    sentencias -> ingreso_datos SEMICOLON
Rule 55    sentencias -> arreglos SEMICOLON
Rule 56    sentencias -> control_structure
Rule 57    sentencias -> llamada SEMICOLON
Rule 58    impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN
Rule 59    impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
Rule 60    funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
Rule 61    funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
Rule 62    funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 63    funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 64    retorno -> RETURN valor SEMICOLON
Rule 65    parameters -> IDENTIFIER COLON asig_data_type
Rule 66    parameters -> IDENTIFIER COLON asig_data_type COMMA parameters
Rule 67    parameters -> vacio
Rule 68    ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
Rule 69    asig_data_type -> data_type
Rule 70    asig_data_type -> list_type
Rule 71    asig_data_type -> tuple_type
Rule 72    list_type -> LCORCH some_data_type RCORCH
Rule 73    tuple_type -> LPAREN some_data_type RPAREN
Rule 74    data_type -> CHAR
Rule 75    data_type -> REFERENCE STR
Rule 76    data_type -> signed_integer
Rule 77    data_type -> unsigned_integer
Rule 78    data_type -> float_type
Rule 79    data_type -> BOOL
Rule 80    signed_integer -> I8
Rule 81    signed_integer -> I16
Rule 82    signed_integer -> I32
Rule 83    signed_integer -> I64
Rule 84    signed_integer -> I128
Rule 85    signed_integer -> ISIZE
Rule 86    unsigned_integer -> U8
Rule 87    unsigned_integer -> U16
Rule 88    unsigned_integer -> U32
Rule 89    unsigned_integer -> U64
Rule 90    unsigned_integer -> U128
Rule 91    unsigned_integer -> USIZE
Rule 92    float_type -> F32
Rule 93    float_type -> F64
Rule 94    some_data_type -> data_type
Rule 95    some_data_type -> data_type COMMA some_data_type
Rule 96    control_structure -> condicional
Rule 97    arreglos -> LCORCH valores RCORCH
Rule 98    tuplas -> LPAREN valores RPAREN
Rule 99    valores -> valor
Rule 100   valores -> valor COMMA valores
Rule 101   conector -> AND
Rule 102   conector -> OR
Rule 103   proposicion -> comparacion conector proposicion
Rule 104   proposicion -> comparacion
Rule 105   condicional -> IF comparacion LLLAVE programa RLLAVE
Rule 106   condicional -> IF proposicion LLLAVE programa RLLAVE
Rule 107   numeric -> INTEGER
Rule 108   numeric -> FLOAT
Rule 109   numeric -> IDENTIFIER
Rule 110   cadena -> STRING
Rule 111   cadena -> IDENTIFIER
Rule 112   operacion -> numeric PLUS numeric
Rule 113   operacion -> numeric MINUS numeric
Rule 114   operacion -> numeric TIMES numeric
Rule 115   operacion -> numeric DIVIDE numeric
Rule 116   operacion -> numeric MOD numeric
Rule 117   operacion -> numeric INTD numeric
Rule 118   operacion -> cadena PLUS cadena
Rule 119   indexacion -> IDENTIFIER LCORCH INTEGER RCORCH
Rule 120   llamada -> IDENTIFIER LPAREN valores RPAREN
Rule 121   main -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE

Terminals, with rules where they appear

AND                  : 101
ASIG                 : 9 10 23 24 25 26 27 28 29 30 31 32 33
BOOL                 : 30 31 79
CHAR                 : 24 74
CHARACTER            : 24
COLON                : 11 12 15 16 65 66
COMMA                : 59 66 95 100
DIVIDE               : 115
DOT                  : 68 68
DOUBLE_COLON         : 68 68
DOUBLE_QUOTATION_MARK : 
ELSE                 : 
EQ                   : 34
EXCLAMATION          : 58 59
F32                  : 92
F64                  : 93
FALSE                : 31 49
FLOAT                : 28 29 41 108
FN                   : 60 61 62 63 121
FOR                  : 
FROM                 : 
GEQ                  : 36
I128                 : 84
I16                  : 81
I32                  : 82
I64                  : 83
I8                   : 80
IDENTIFIER           : 9 11 12 13 14 15 16 42 60 61 62 63 65 66 68 109 111 119 120
IF                   : 105 106
IMPL                 : 
IN                   : 
INTD                 : 117
INTEGER              : 25 26 27 40 107 119
IO                   : 68
ISIZE                : 85
LCORCH               : 72 97 119
LEFTARROW            : 39
LEQ                  : 37
LET                  : 9 10 11 12 13 14 15 16
LLLAVE               : 60 61 62 63 105 106 121
LPAREN               : 58 59 60 61 62 63 68 68 73 98 120 121
MAIN                 : 121
MATCH                : 
MINUS                : 26 29 62 63 113
MOD                  : 116
MUT                  : 10 12 14 16 68
NEQ                  : 35
NOT                  : 
OR                   : 102
PLUS                 : 112 118
PRINTLN              : 58 59
QUOTATION_MARK       : 
RAND                 : 
RCORCH               : 72 97 119
READLINE             : 68
REFERENCE            : 23 68 75
RETURN               : 64
RIGHTARROW           : 38 62 63
RLLAVE               : 60 61 62 63 105 106 121
RPAREN               : 58 59 60 61 62 63 68 68 73 98 120 121
SELF                 : 
SEMICOLON            : 51 52 53 54 55 57 64
STD                  : 68
STDIN                : 68
STR                  : 23 75
STRING               : 23 46 110
STRUCT               : 
TIMES                : 114
TRUE                 : 30 48
U128                 : 90
U16                  : 87
U32                  : 88
U64                  : 89
U8                   : 86
USIZE                : 91
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arreglos             : 32 45 55
asig_data_type       : 15 16 65 66
asignacion           : 11 12
asignacion_variable  : 51
boolean_asignacion   : 20
booleanos            : 47
cadena               : 118 118
char_asignacion      : 18
codigoRust           : 0
comparacion          : 103 104 105
condicional          : 96
conector             : 103
control_structure    : 56
data_type            : 62 63 69 94 95
declaracion_variable : 52
float_type           : 28 29 78
funcion              : 5 6
funciones            : 1 1 2 3 6
impresion            : 53
indexacion           : 44
ingreso_datos        : 54
list_type            : 32 70
lista_asignacion     : 21
llamada              : 57
main                 : 1 2 3 4
numeric              : 112 112 113 113 114 114 115 115 116 116 117 117
numero_asignacion    : 19
operacion            : 43
parameters           : 60 62 66
programa             : 8 60 61 62 63 105 106 121
proposicion          : 103 106
retorno              : 62 63
sentencias           : 7 8
signed_integer       : 25 26 76
some_data_type       : 72 73 95
string_asignacion    : 17
tupla_asignacion     : 22
tuplas               : 33
tuple_type           : 33 71
unsigned_integer     : 27 77
vacio                : 67
valor                : 9 10 34 34 35 35 36 36 37 37 38 38 39 39 58 59 64 99 100
valores              : 59 97 98 100 120

Parsing method: LALR

state 0

    (0) S' -> . codigoRust
    (1) codigoRust -> . funciones main funciones
    (2) codigoRust -> . funciones main
    (3) codigoRust -> . main funciones
    (4) codigoRust -> . main
    (5) funciones -> . funcion
    (6) funciones -> . funcion funciones
    (121) main -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    FN              shift and go to state 5

    codigoRust                     shift and go to state 1
    funciones                      shift and go to state 2
    main                           shift and go to state 3
    funcion                        shift and go to state 4

state 1

    (0) S' -> codigoRust .



state 2

    (1) codigoRust -> funciones . main funciones
    (2) codigoRust -> funciones . main
    (121) main -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE

    FN              shift and go to state 7

    main                           shift and go to state 6

state 3

    (3) codigoRust -> main . funciones
    (4) codigoRust -> main .
    (5) funciones -> . funcion
    (6) funciones -> . funcion funciones
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    $end            reduce using rule 4 (codigoRust -> main .)
    FN              shift and go to state 9

    funciones                      shift and go to state 8
    funcion                        shift and go to state 4

state 4

    (5) funciones -> funcion .
    (6) funciones -> funcion . funciones
    (5) funciones -> . funcion
    (6) funciones -> . funcion funciones
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

  ! shift/reduce conflict for FN resolved as shift
    $end            reduce using rule 5 (funciones -> funcion .)
    FN              shift and go to state 9

  ! FN              [ reduce using rule 5 (funciones -> funcion .) ]

    funcion                        shift and go to state 4
    funciones                      shift and go to state 10

state 5

    (121) main -> FN . MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN . IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    MAIN            shift and go to state 11
    IDENTIFIER      shift and go to state 12


state 6

    (1) codigoRust -> funciones main . funciones
    (2) codigoRust -> funciones main .
    (5) funciones -> . funcion
    (6) funciones -> . funcion funciones
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    $end            reduce using rule 2 (codigoRust -> funciones main .)
    FN              shift and go to state 9

    funciones                      shift and go to state 13
    funcion                        shift and go to state 4

state 7

    (121) main -> FN . MAIN LPAREN RPAREN LLLAVE programa RLLAVE

    MAIN            shift and go to state 11


state 8

    (3) codigoRust -> main funciones .

    $end            reduce using rule 3 (codigoRust -> main funciones .)


state 9

    (60) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN . IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    IDENTIFIER      shift and go to state 12


state 10

    (6) funciones -> funcion funciones .

    FN              reduce using rule 6 (funciones -> funcion funciones .)
    $end            reduce using rule 6 (funciones -> funcion funciones .)


state 11

    (121) main -> FN MAIN . LPAREN RPAREN LLLAVE programa RLLAVE

    LPAREN          shift and go to state 14


state 12

    (60) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN IDENTIFIER . LPAREN RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN IDENTIFIER . LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LPAREN          shift and go to state 15


state 13

    (1) codigoRust -> funciones main funciones .

    $end            reduce using rule 1 (codigoRust -> funciones main funciones .)


state 14

    (121) main -> FN MAIN LPAREN . RPAREN LLLAVE programa RLLAVE

    RPAREN          shift and go to state 16


state 15

    (60) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN LLLAVE programa RLLAVE
    (61) funcion -> FN IDENTIFIER LPAREN . RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) funcion -> FN IDENTIFIER LPAREN . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (65) parameters -> . IDENTIFIER COLON asig_data_type
    (66) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (67) parameters -> . vacio
    (50) vacio -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 17

  ! RPAREN          [ reduce using rule 50 (vacio -> .) ]

    parameters                     shift and go to state 18
    vacio                          shift and go to state 20

state 16

    (121) main -> FN MAIN LPAREN RPAREN . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 21


state 17

    (65) parameters -> IDENTIFIER . COLON asig_data_type
    (66) parameters -> IDENTIFIER . COLON asig_data_type COMMA parameters

    COLON           shift and go to state 22


state 18

    (60) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RPAREN          shift and go to state 23


state 19

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN . LLLAVE programa RLLAVE
    (63) funcion -> FN IDENTIFIER LPAREN RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 24
    MINUS           shift and go to state 25


state 20

    (67) parameters -> vacio .

    RPAREN          reduce using rule 67 (parameters -> vacio .)


state 21

    (121) main -> FN MAIN LPAREN RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 26
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 22

    (65) parameters -> IDENTIFIER COLON . asig_data_type
    (66) parameters -> IDENTIFIER COLON . asig_data_type COMMA parameters
    (69) asig_data_type -> . data_type
    (70) asig_data_type -> . list_type
    (71) asig_data_type -> . tuple_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (72) list_type -> . LCORCH some_data_type RCORCH
    (73) tuple_type -> . LPAREN some_data_type RPAREN
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    LCORCH          shift and go to state 52
    LPAREN          shift and go to state 53
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    asig_data_type                 shift and go to state 42
    data_type                      shift and go to state 43
    list_type                      shift and go to state 44
    tuple_type                     shift and go to state 45
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 23

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . LLLAVE programa RLLAVE
    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 68
    MINUS           shift and go to state 69


state 24

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 70
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 25

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 71


state 26

    (121) main -> FN MAIN LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 72


state 27

    (7) programa -> sentencias .
    (8) programa -> sentencias . programa
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    RLLAVE          reduce using rule 7 (programa -> sentencias .)
    RETURN          reduce using rule 7 (programa -> sentencias .)
    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    sentencias                     shift and go to state 27
    programa                       shift and go to state 73
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 28

    (51) sentencias -> asignacion_variable . SEMICOLON

    SEMICOLON       shift and go to state 74


state 29

    (52) sentencias -> declaracion_variable . SEMICOLON

    SEMICOLON       shift and go to state 75


state 30

    (53) sentencias -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 76


state 31

    (54) sentencias -> ingreso_datos . SEMICOLON

    SEMICOLON       shift and go to state 77


state 32

    (55) sentencias -> arreglos . SEMICOLON

    SEMICOLON       shift and go to state 78


state 33

    (56) sentencias -> control_structure .

    LET             reduce using rule 56 (sentencias -> control_structure .)
    PRINTLN         reduce using rule 56 (sentencias -> control_structure .)
    STD             reduce using rule 56 (sentencias -> control_structure .)
    LCORCH          reduce using rule 56 (sentencias -> control_structure .)
    IDENTIFIER      reduce using rule 56 (sentencias -> control_structure .)
    IF              reduce using rule 56 (sentencias -> control_structure .)
    RLLAVE          reduce using rule 56 (sentencias -> control_structure .)
    RETURN          reduce using rule 56 (sentencias -> control_structure .)


state 34

    (57) sentencias -> llamada . SEMICOLON

    SEMICOLON       shift and go to state 79


state 35

    (9) asignacion_variable -> LET . IDENTIFIER ASIG valor
    (10) asignacion_variable -> LET . MUT ASIG valor
    (11) asignacion_variable -> LET . IDENTIFIER COLON asignacion
    (12) asignacion_variable -> LET . MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> LET . IDENTIFIER
    (14) declaracion_variable -> LET . MUT IDENTIFIER
    (15) declaracion_variable -> LET . IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> LET . MUT IDENTIFIER COLON asig_data_type

    IDENTIFIER      shift and go to state 80
    MUT             shift and go to state 81


state 36

    (120) llamada -> IDENTIFIER . LPAREN valores RPAREN

    LPAREN          shift and go to state 82


state 37

    (58) impresion -> PRINTLN . EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> PRINTLN . EXCLAMATION LPAREN valor COMMA valores RPAREN

    EXCLAMATION     shift and go to state 83


state 38

    (68) ingreso_datos -> STD . DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 84


state 39

    (97) arreglos -> LCORCH . valores RCORCH
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valores                        shift and go to state 85
    valor                          shift and go to state 86
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 40

    (96) control_structure -> condicional .

    LET             reduce using rule 96 (control_structure -> condicional .)
    PRINTLN         reduce using rule 96 (control_structure -> condicional .)
    STD             reduce using rule 96 (control_structure -> condicional .)
    LCORCH          reduce using rule 96 (control_structure -> condicional .)
    IDENTIFIER      reduce using rule 96 (control_structure -> condicional .)
    IF              reduce using rule 96 (control_structure -> condicional .)
    RLLAVE          reduce using rule 96 (control_structure -> condicional .)
    RETURN          reduce using rule 96 (control_structure -> condicional .)


state 41

    (105) condicional -> IF . comparacion LLLAVE programa RLLAVE
    (106) condicional -> IF . proposicion LLLAVE programa RLLAVE
    (34) comparacion -> . valor EQ valor
    (35) comparacion -> . valor NEQ valor
    (36) comparacion -> . valor GEQ valor
    (37) comparacion -> . valor LEQ valor
    (38) comparacion -> . valor RIGHTARROW valor
    (39) comparacion -> . valor LEFTARROW valor
    (103) proposicion -> . comparacion conector proposicion
    (104) proposicion -> . comparacion
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    comparacion                    shift and go to state 99
    proposicion                    shift and go to state 100
    valor                          shift and go to state 101
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 42

    (65) parameters -> IDENTIFIER COLON asig_data_type .
    (66) parameters -> IDENTIFIER COLON asig_data_type . COMMA parameters

    RPAREN          reduce using rule 65 (parameters -> IDENTIFIER COLON asig_data_type .)
    COMMA           shift and go to state 102


state 43

    (69) asig_data_type -> data_type .

    COMMA           reduce using rule 69 (asig_data_type -> data_type .)
    RPAREN          reduce using rule 69 (asig_data_type -> data_type .)
    SEMICOLON       reduce using rule 69 (asig_data_type -> data_type .)


state 44

    (70) asig_data_type -> list_type .

    COMMA           reduce using rule 70 (asig_data_type -> list_type .)
    RPAREN          reduce using rule 70 (asig_data_type -> list_type .)


state 45

    (71) asig_data_type -> tuple_type .

    COMMA           reduce using rule 71 (asig_data_type -> tuple_type .)
    RPAREN          reduce using rule 71 (asig_data_type -> tuple_type .)


state 46

    (74) data_type -> CHAR .

    COMMA           reduce using rule 74 (data_type -> CHAR .)
    RPAREN          reduce using rule 74 (data_type -> CHAR .)
    RCORCH          reduce using rule 74 (data_type -> CHAR .)
    LLLAVE          reduce using rule 74 (data_type -> CHAR .)


state 47

    (75) data_type -> REFERENCE . STR

    STR             shift and go to state 103


state 48

    (76) data_type -> signed_integer .

    COMMA           reduce using rule 76 (data_type -> signed_integer .)
    RPAREN          reduce using rule 76 (data_type -> signed_integer .)
    RCORCH          reduce using rule 76 (data_type -> signed_integer .)
    LLLAVE          reduce using rule 76 (data_type -> signed_integer .)


state 49

    (77) data_type -> unsigned_integer .

    COMMA           reduce using rule 77 (data_type -> unsigned_integer .)
    RPAREN          reduce using rule 77 (data_type -> unsigned_integer .)
    RCORCH          reduce using rule 77 (data_type -> unsigned_integer .)
    LLLAVE          reduce using rule 77 (data_type -> unsigned_integer .)


state 50

    (78) data_type -> float_type .

    COMMA           reduce using rule 78 (data_type -> float_type .)
    RPAREN          reduce using rule 78 (data_type -> float_type .)
    RCORCH          reduce using rule 78 (data_type -> float_type .)
    LLLAVE          reduce using rule 78 (data_type -> float_type .)


state 51

    (79) data_type -> BOOL .

    COMMA           reduce using rule 79 (data_type -> BOOL .)
    RPAREN          reduce using rule 79 (data_type -> BOOL .)
    RCORCH          reduce using rule 79 (data_type -> BOOL .)
    LLLAVE          reduce using rule 79 (data_type -> BOOL .)


state 52

    (72) list_type -> LCORCH . some_data_type RCORCH
    (94) some_data_type -> . data_type
    (95) some_data_type -> . data_type COMMA some_data_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    some_data_type                 shift and go to state 104
    data_type                      shift and go to state 105
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 53

    (73) tuple_type -> LPAREN . some_data_type RPAREN
    (94) some_data_type -> . data_type
    (95) some_data_type -> . data_type COMMA some_data_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    some_data_type                 shift and go to state 106
    data_type                      shift and go to state 105
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 54

    (80) signed_integer -> I8 .

    COMMA           reduce using rule 80 (signed_integer -> I8 .)
    RPAREN          reduce using rule 80 (signed_integer -> I8 .)
    RCORCH          reduce using rule 80 (signed_integer -> I8 .)
    LLLAVE          reduce using rule 80 (signed_integer -> I8 .)
    ASIG            reduce using rule 80 (signed_integer -> I8 .)
    SEMICOLON       reduce using rule 80 (signed_integer -> I8 .)


state 55

    (81) signed_integer -> I16 .

    COMMA           reduce using rule 81 (signed_integer -> I16 .)
    RPAREN          reduce using rule 81 (signed_integer -> I16 .)
    RCORCH          reduce using rule 81 (signed_integer -> I16 .)
    LLLAVE          reduce using rule 81 (signed_integer -> I16 .)
    ASIG            reduce using rule 81 (signed_integer -> I16 .)
    SEMICOLON       reduce using rule 81 (signed_integer -> I16 .)


state 56

    (82) signed_integer -> I32 .

    COMMA           reduce using rule 82 (signed_integer -> I32 .)
    RPAREN          reduce using rule 82 (signed_integer -> I32 .)
    RCORCH          reduce using rule 82 (signed_integer -> I32 .)
    LLLAVE          reduce using rule 82 (signed_integer -> I32 .)
    ASIG            reduce using rule 82 (signed_integer -> I32 .)
    SEMICOLON       reduce using rule 82 (signed_integer -> I32 .)


state 57

    (83) signed_integer -> I64 .

    COMMA           reduce using rule 83 (signed_integer -> I64 .)
    RPAREN          reduce using rule 83 (signed_integer -> I64 .)
    RCORCH          reduce using rule 83 (signed_integer -> I64 .)
    LLLAVE          reduce using rule 83 (signed_integer -> I64 .)
    ASIG            reduce using rule 83 (signed_integer -> I64 .)
    SEMICOLON       reduce using rule 83 (signed_integer -> I64 .)


state 58

    (84) signed_integer -> I128 .

    COMMA           reduce using rule 84 (signed_integer -> I128 .)
    RPAREN          reduce using rule 84 (signed_integer -> I128 .)
    RCORCH          reduce using rule 84 (signed_integer -> I128 .)
    LLLAVE          reduce using rule 84 (signed_integer -> I128 .)
    ASIG            reduce using rule 84 (signed_integer -> I128 .)
    SEMICOLON       reduce using rule 84 (signed_integer -> I128 .)


state 59

    (85) signed_integer -> ISIZE .

    COMMA           reduce using rule 85 (signed_integer -> ISIZE .)
    RPAREN          reduce using rule 85 (signed_integer -> ISIZE .)
    RCORCH          reduce using rule 85 (signed_integer -> ISIZE .)
    LLLAVE          reduce using rule 85 (signed_integer -> ISIZE .)
    ASIG            reduce using rule 85 (signed_integer -> ISIZE .)
    SEMICOLON       reduce using rule 85 (signed_integer -> ISIZE .)


state 60

    (86) unsigned_integer -> U8 .

    COMMA           reduce using rule 86 (unsigned_integer -> U8 .)
    RPAREN          reduce using rule 86 (unsigned_integer -> U8 .)
    RCORCH          reduce using rule 86 (unsigned_integer -> U8 .)
    LLLAVE          reduce using rule 86 (unsigned_integer -> U8 .)
    ASIG            reduce using rule 86 (unsigned_integer -> U8 .)
    SEMICOLON       reduce using rule 86 (unsigned_integer -> U8 .)


state 61

    (87) unsigned_integer -> U16 .

    COMMA           reduce using rule 87 (unsigned_integer -> U16 .)
    RPAREN          reduce using rule 87 (unsigned_integer -> U16 .)
    RCORCH          reduce using rule 87 (unsigned_integer -> U16 .)
    LLLAVE          reduce using rule 87 (unsigned_integer -> U16 .)
    ASIG            reduce using rule 87 (unsigned_integer -> U16 .)
    SEMICOLON       reduce using rule 87 (unsigned_integer -> U16 .)


state 62

    (88) unsigned_integer -> U32 .

    COMMA           reduce using rule 88 (unsigned_integer -> U32 .)
    RPAREN          reduce using rule 88 (unsigned_integer -> U32 .)
    RCORCH          reduce using rule 88 (unsigned_integer -> U32 .)
    LLLAVE          reduce using rule 88 (unsigned_integer -> U32 .)
    ASIG            reduce using rule 88 (unsigned_integer -> U32 .)
    SEMICOLON       reduce using rule 88 (unsigned_integer -> U32 .)


state 63

    (89) unsigned_integer -> U64 .

    COMMA           reduce using rule 89 (unsigned_integer -> U64 .)
    RPAREN          reduce using rule 89 (unsigned_integer -> U64 .)
    RCORCH          reduce using rule 89 (unsigned_integer -> U64 .)
    LLLAVE          reduce using rule 89 (unsigned_integer -> U64 .)
    ASIG            reduce using rule 89 (unsigned_integer -> U64 .)
    SEMICOLON       reduce using rule 89 (unsigned_integer -> U64 .)


state 64

    (90) unsigned_integer -> U128 .

    COMMA           reduce using rule 90 (unsigned_integer -> U128 .)
    RPAREN          reduce using rule 90 (unsigned_integer -> U128 .)
    RCORCH          reduce using rule 90 (unsigned_integer -> U128 .)
    LLLAVE          reduce using rule 90 (unsigned_integer -> U128 .)
    ASIG            reduce using rule 90 (unsigned_integer -> U128 .)
    SEMICOLON       reduce using rule 90 (unsigned_integer -> U128 .)


state 65

    (91) unsigned_integer -> USIZE .

    COMMA           reduce using rule 91 (unsigned_integer -> USIZE .)
    RPAREN          reduce using rule 91 (unsigned_integer -> USIZE .)
    RCORCH          reduce using rule 91 (unsigned_integer -> USIZE .)
    LLLAVE          reduce using rule 91 (unsigned_integer -> USIZE .)
    ASIG            reduce using rule 91 (unsigned_integer -> USIZE .)
    SEMICOLON       reduce using rule 91 (unsigned_integer -> USIZE .)


state 66

    (92) float_type -> F32 .

    COMMA           reduce using rule 92 (float_type -> F32 .)
    RPAREN          reduce using rule 92 (float_type -> F32 .)
    RCORCH          reduce using rule 92 (float_type -> F32 .)
    LLLAVE          reduce using rule 92 (float_type -> F32 .)
    ASIG            reduce using rule 92 (float_type -> F32 .)
    SEMICOLON       reduce using rule 92 (float_type -> F32 .)


state 67

    (93) float_type -> F64 .

    COMMA           reduce using rule 93 (float_type -> F64 .)
    RPAREN          reduce using rule 93 (float_type -> F64 .)
    RCORCH          reduce using rule 93 (float_type -> F64 .)
    LLLAVE          reduce using rule 93 (float_type -> F64 .)
    ASIG            reduce using rule 93 (float_type -> F64 .)
    SEMICOLON       reduce using rule 93 (float_type -> F64 .)


state 68

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 107
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 69

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 108


state 70

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 109


state 71

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    data_type                      shift and go to state 110
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 72

    (121) main -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 121 (main -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 121 (main -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)


state 73

    (8) programa -> sentencias programa .

    RLLAVE          reduce using rule 8 (programa -> sentencias programa .)
    RETURN          reduce using rule 8 (programa -> sentencias programa .)


state 74

    (51) sentencias -> asignacion_variable SEMICOLON .

    LET             reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    PRINTLN         reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    STD             reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    LCORCH          reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    IF              reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    RLLAVE          reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)
    RETURN          reduce using rule 51 (sentencias -> asignacion_variable SEMICOLON .)


state 75

    (52) sentencias -> declaracion_variable SEMICOLON .

    LET             reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    PRINTLN         reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    STD             reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    LCORCH          reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    IDENTIFIER      reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    IF              reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    RLLAVE          reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)
    RETURN          reduce using rule 52 (sentencias -> declaracion_variable SEMICOLON .)


state 76

    (53) sentencias -> impresion SEMICOLON .

    LET             reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    STD             reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    LCORCH          reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    IF              reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    RLLAVE          reduce using rule 53 (sentencias -> impresion SEMICOLON .)
    RETURN          reduce using rule 53 (sentencias -> impresion SEMICOLON .)


state 77

    (54) sentencias -> ingreso_datos SEMICOLON .

    LET             reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    PRINTLN         reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    STD             reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    LCORCH          reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    IDENTIFIER      reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    IF              reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    RLLAVE          reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)
    RETURN          reduce using rule 54 (sentencias -> ingreso_datos SEMICOLON .)


state 78

    (55) sentencias -> arreglos SEMICOLON .

    LET             reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    PRINTLN         reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    STD             reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    LCORCH          reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    IF              reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    RLLAVE          reduce using rule 55 (sentencias -> arreglos SEMICOLON .)
    RETURN          reduce using rule 55 (sentencias -> arreglos SEMICOLON .)


state 79

    (57) sentencias -> llamada SEMICOLON .

    LET             reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    PRINTLN         reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    STD             reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    LCORCH          reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    IF              reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    RLLAVE          reduce using rule 57 (sentencias -> llamada SEMICOLON .)
    RETURN          reduce using rule 57 (sentencias -> llamada SEMICOLON .)


state 80

    (9) asignacion_variable -> LET IDENTIFIER . ASIG valor
    (11) asignacion_variable -> LET IDENTIFIER . COLON asignacion
    (13) declaracion_variable -> LET IDENTIFIER .
    (15) declaracion_variable -> LET IDENTIFIER . COLON asig_data_type

    ASIG            shift and go to state 111
    COLON           shift and go to state 112
    SEMICOLON       reduce using rule 13 (declaracion_variable -> LET IDENTIFIER .)


state 81

    (10) asignacion_variable -> LET MUT . ASIG valor
    (12) asignacion_variable -> LET MUT . IDENTIFIER COLON asignacion
    (14) declaracion_variable -> LET MUT . IDENTIFIER
    (16) declaracion_variable -> LET MUT . IDENTIFIER COLON asig_data_type

    ASIG            shift and go to state 113
    IDENTIFIER      shift and go to state 114


state 82

    (120) llamada -> IDENTIFIER LPAREN . valores RPAREN
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valores                        shift and go to state 115
    valor                          shift and go to state 86
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 83

    (58) impresion -> PRINTLN EXCLAMATION . LPAREN valor RPAREN
    (59) impresion -> PRINTLN EXCLAMATION . LPAREN valor COMMA valores RPAREN

    LPAREN          shift and go to state 116


state 84

    (68) ingreso_datos -> STD DOUBLE_COLON . IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    IO              shift and go to state 117


state 85

    (97) arreglos -> LCORCH valores . RCORCH

    RCORCH          shift and go to state 118


state 86

    (99) valores -> valor .
    (100) valores -> valor . COMMA valores

    RCORCH          reduce using rule 99 (valores -> valor .)
    RPAREN          reduce using rule 99 (valores -> valor .)
    COMMA           shift and go to state 119


state 87

    (40) valor -> INTEGER .
    (107) numeric -> INTEGER .

    COMMA           reduce using rule 40 (valor -> INTEGER .)
    RCORCH          reduce using rule 40 (valor -> INTEGER .)
    EQ              reduce using rule 40 (valor -> INTEGER .)
    NEQ             reduce using rule 40 (valor -> INTEGER .)
    GEQ             reduce using rule 40 (valor -> INTEGER .)
    LEQ             reduce using rule 40 (valor -> INTEGER .)
    RIGHTARROW      reduce using rule 40 (valor -> INTEGER .)
    LEFTARROW       reduce using rule 40 (valor -> INTEGER .)
    RPAREN          reduce using rule 40 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 40 (valor -> INTEGER .)
    LLLAVE          reduce using rule 40 (valor -> INTEGER .)
    AND             reduce using rule 40 (valor -> INTEGER .)
    OR              reduce using rule 40 (valor -> INTEGER .)
    PLUS            reduce using rule 107 (numeric -> INTEGER .)
    MINUS           reduce using rule 107 (numeric -> INTEGER .)
    TIMES           reduce using rule 107 (numeric -> INTEGER .)
    DIVIDE          reduce using rule 107 (numeric -> INTEGER .)
    MOD             reduce using rule 107 (numeric -> INTEGER .)
    INTD            reduce using rule 107 (numeric -> INTEGER .)


state 88

    (41) valor -> FLOAT .
    (108) numeric -> FLOAT .

    COMMA           reduce using rule 41 (valor -> FLOAT .)
    RCORCH          reduce using rule 41 (valor -> FLOAT .)
    EQ              reduce using rule 41 (valor -> FLOAT .)
    NEQ             reduce using rule 41 (valor -> FLOAT .)
    GEQ             reduce using rule 41 (valor -> FLOAT .)
    LEQ             reduce using rule 41 (valor -> FLOAT .)
    RIGHTARROW      reduce using rule 41 (valor -> FLOAT .)
    LEFTARROW       reduce using rule 41 (valor -> FLOAT .)
    RPAREN          reduce using rule 41 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 41 (valor -> FLOAT .)
    LLLAVE          reduce using rule 41 (valor -> FLOAT .)
    AND             reduce using rule 41 (valor -> FLOAT .)
    OR              reduce using rule 41 (valor -> FLOAT .)
    PLUS            reduce using rule 108 (numeric -> FLOAT .)
    MINUS           reduce using rule 108 (numeric -> FLOAT .)
    TIMES           reduce using rule 108 (numeric -> FLOAT .)
    DIVIDE          reduce using rule 108 (numeric -> FLOAT .)
    MOD             reduce using rule 108 (numeric -> FLOAT .)
    INTD            reduce using rule 108 (numeric -> FLOAT .)


state 89

    (42) valor -> IDENTIFIER .
    (119) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH
    (109) numeric -> IDENTIFIER .
    (111) cadena -> IDENTIFIER .

  ! reduce/reduce conflict for PLUS resolved using rule 109 (numeric -> IDENTIFIER .)
    COMMA           reduce using rule 42 (valor -> IDENTIFIER .)
    RCORCH          reduce using rule 42 (valor -> IDENTIFIER .)
    EQ              reduce using rule 42 (valor -> IDENTIFIER .)
    NEQ             reduce using rule 42 (valor -> IDENTIFIER .)
    GEQ             reduce using rule 42 (valor -> IDENTIFIER .)
    LEQ             reduce using rule 42 (valor -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 42 (valor -> IDENTIFIER .)
    LEFTARROW       reduce using rule 42 (valor -> IDENTIFIER .)
    RPAREN          reduce using rule 42 (valor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 42 (valor -> IDENTIFIER .)
    LLLAVE          reduce using rule 42 (valor -> IDENTIFIER .)
    AND             reduce using rule 42 (valor -> IDENTIFIER .)
    OR              reduce using rule 42 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 120
    PLUS            reduce using rule 109 (numeric -> IDENTIFIER .)
    MINUS           reduce using rule 109 (numeric -> IDENTIFIER .)
    TIMES           reduce using rule 109 (numeric -> IDENTIFIER .)
    DIVIDE          reduce using rule 109 (numeric -> IDENTIFIER .)
    MOD             reduce using rule 109 (numeric -> IDENTIFIER .)
    INTD            reduce using rule 109 (numeric -> IDENTIFIER .)

  ! PLUS            [ reduce using rule 111 (cadena -> IDENTIFIER .) ]


state 90

    (43) valor -> operacion .

    COMMA           reduce using rule 43 (valor -> operacion .)
    RCORCH          reduce using rule 43 (valor -> operacion .)
    EQ              reduce using rule 43 (valor -> operacion .)
    NEQ             reduce using rule 43 (valor -> operacion .)
    GEQ             reduce using rule 43 (valor -> operacion .)
    LEQ             reduce using rule 43 (valor -> operacion .)
    RIGHTARROW      reduce using rule 43 (valor -> operacion .)
    LEFTARROW       reduce using rule 43 (valor -> operacion .)
    RPAREN          reduce using rule 43 (valor -> operacion .)
    SEMICOLON       reduce using rule 43 (valor -> operacion .)
    LLLAVE          reduce using rule 43 (valor -> operacion .)
    AND             reduce using rule 43 (valor -> operacion .)
    OR              reduce using rule 43 (valor -> operacion .)


state 91

    (44) valor -> indexacion .

    COMMA           reduce using rule 44 (valor -> indexacion .)
    RCORCH          reduce using rule 44 (valor -> indexacion .)
    EQ              reduce using rule 44 (valor -> indexacion .)
    NEQ             reduce using rule 44 (valor -> indexacion .)
    GEQ             reduce using rule 44 (valor -> indexacion .)
    LEQ             reduce using rule 44 (valor -> indexacion .)
    RIGHTARROW      reduce using rule 44 (valor -> indexacion .)
    LEFTARROW       reduce using rule 44 (valor -> indexacion .)
    RPAREN          reduce using rule 44 (valor -> indexacion .)
    SEMICOLON       reduce using rule 44 (valor -> indexacion .)
    LLLAVE          reduce using rule 44 (valor -> indexacion .)
    AND             reduce using rule 44 (valor -> indexacion .)
    OR              reduce using rule 44 (valor -> indexacion .)


state 92

    (45) valor -> arreglos .

    COMMA           reduce using rule 45 (valor -> arreglos .)
    RCORCH          reduce using rule 45 (valor -> arreglos .)
    EQ              reduce using rule 45 (valor -> arreglos .)
    NEQ             reduce using rule 45 (valor -> arreglos .)
    GEQ             reduce using rule 45 (valor -> arreglos .)
    LEQ             reduce using rule 45 (valor -> arreglos .)
    RIGHTARROW      reduce using rule 45 (valor -> arreglos .)
    LEFTARROW       reduce using rule 45 (valor -> arreglos .)
    RPAREN          reduce using rule 45 (valor -> arreglos .)
    SEMICOLON       reduce using rule 45 (valor -> arreglos .)
    LLLAVE          reduce using rule 45 (valor -> arreglos .)
    AND             reduce using rule 45 (valor -> arreglos .)
    OR              reduce using rule 45 (valor -> arreglos .)


state 93

    (46) valor -> STRING .
    (110) cadena -> STRING .

    COMMA           reduce using rule 46 (valor -> STRING .)
    RCORCH          reduce using rule 46 (valor -> STRING .)
    EQ              reduce using rule 46 (valor -> STRING .)
    NEQ             reduce using rule 46 (valor -> STRING .)
    GEQ             reduce using rule 46 (valor -> STRING .)
    LEQ             reduce using rule 46 (valor -> STRING .)
    RIGHTARROW      reduce using rule 46 (valor -> STRING .)
    LEFTARROW       reduce using rule 46 (valor -> STRING .)
    RPAREN          reduce using rule 46 (valor -> STRING .)
    SEMICOLON       reduce using rule 46 (valor -> STRING .)
    LLLAVE          reduce using rule 46 (valor -> STRING .)
    AND             reduce using rule 46 (valor -> STRING .)
    OR              reduce using rule 46 (valor -> STRING .)
    PLUS            reduce using rule 110 (cadena -> STRING .)


state 94

    (47) valor -> booleanos .

    COMMA           reduce using rule 47 (valor -> booleanos .)
    RCORCH          reduce using rule 47 (valor -> booleanos .)
    EQ              reduce using rule 47 (valor -> booleanos .)
    NEQ             reduce using rule 47 (valor -> booleanos .)
    GEQ             reduce using rule 47 (valor -> booleanos .)
    LEQ             reduce using rule 47 (valor -> booleanos .)
    RIGHTARROW      reduce using rule 47 (valor -> booleanos .)
    LEFTARROW       reduce using rule 47 (valor -> booleanos .)
    RPAREN          reduce using rule 47 (valor -> booleanos .)
    SEMICOLON       reduce using rule 47 (valor -> booleanos .)
    LLLAVE          reduce using rule 47 (valor -> booleanos .)
    AND             reduce using rule 47 (valor -> booleanos .)
    OR              reduce using rule 47 (valor -> booleanos .)


state 95

    (112) operacion -> numeric . PLUS numeric
    (113) operacion -> numeric . MINUS numeric
    (114) operacion -> numeric . TIMES numeric
    (115) operacion -> numeric . DIVIDE numeric
    (116) operacion -> numeric . MOD numeric
    (117) operacion -> numeric . INTD numeric

    PLUS            shift and go to state 121
    MINUS           shift and go to state 122
    TIMES           shift and go to state 123
    DIVIDE          shift and go to state 124
    MOD             shift and go to state 125
    INTD            shift and go to state 126


state 96

    (118) operacion -> cadena . PLUS cadena

    PLUS            shift and go to state 127


state 97

    (48) booleanos -> TRUE .

    COMMA           reduce using rule 48 (booleanos -> TRUE .)
    RCORCH          reduce using rule 48 (booleanos -> TRUE .)
    EQ              reduce using rule 48 (booleanos -> TRUE .)
    NEQ             reduce using rule 48 (booleanos -> TRUE .)
    GEQ             reduce using rule 48 (booleanos -> TRUE .)
    LEQ             reduce using rule 48 (booleanos -> TRUE .)
    RIGHTARROW      reduce using rule 48 (booleanos -> TRUE .)
    LEFTARROW       reduce using rule 48 (booleanos -> TRUE .)
    RPAREN          reduce using rule 48 (booleanos -> TRUE .)
    SEMICOLON       reduce using rule 48 (booleanos -> TRUE .)
    LLLAVE          reduce using rule 48 (booleanos -> TRUE .)
    AND             reduce using rule 48 (booleanos -> TRUE .)
    OR              reduce using rule 48 (booleanos -> TRUE .)


state 98

    (49) booleanos -> FALSE .

    COMMA           reduce using rule 49 (booleanos -> FALSE .)
    RCORCH          reduce using rule 49 (booleanos -> FALSE .)
    EQ              reduce using rule 49 (booleanos -> FALSE .)
    NEQ             reduce using rule 49 (booleanos -> FALSE .)
    GEQ             reduce using rule 49 (booleanos -> FALSE .)
    LEQ             reduce using rule 49 (booleanos -> FALSE .)
    RIGHTARROW      reduce using rule 49 (booleanos -> FALSE .)
    LEFTARROW       reduce using rule 49 (booleanos -> FALSE .)
    RPAREN          reduce using rule 49 (booleanos -> FALSE .)
    SEMICOLON       reduce using rule 49 (booleanos -> FALSE .)
    LLLAVE          reduce using rule 49 (booleanos -> FALSE .)
    AND             reduce using rule 49 (booleanos -> FALSE .)
    OR              reduce using rule 49 (booleanos -> FALSE .)


state 99

    (105) condicional -> IF comparacion . LLLAVE programa RLLAVE
    (103) proposicion -> comparacion . conector proposicion
    (104) proposicion -> comparacion .
    (101) conector -> . AND
    (102) conector -> . OR

  ! shift/reduce conflict for LLLAVE resolved as shift
    LLLAVE          shift and go to state 128
    AND             shift and go to state 130
    OR              shift and go to state 131

  ! LLLAVE          [ reduce using rule 104 (proposicion -> comparacion .) ]

    conector                       shift and go to state 129

state 100

    (106) condicional -> IF proposicion . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 132


state 101

    (34) comparacion -> valor . EQ valor
    (35) comparacion -> valor . NEQ valor
    (36) comparacion -> valor . GEQ valor
    (37) comparacion -> valor . LEQ valor
    (38) comparacion -> valor . RIGHTARROW valor
    (39) comparacion -> valor . LEFTARROW valor

    EQ              shift and go to state 133
    NEQ             shift and go to state 134
    GEQ             shift and go to state 135
    LEQ             shift and go to state 136
    RIGHTARROW      shift and go to state 137
    LEFTARROW       shift and go to state 138


state 102

    (66) parameters -> IDENTIFIER COLON asig_data_type COMMA . parameters
    (65) parameters -> . IDENTIFIER COLON asig_data_type
    (66) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (67) parameters -> . vacio
    (50) vacio -> .

    IDENTIFIER      shift and go to state 17
    RPAREN          reduce using rule 50 (vacio -> .)

    parameters                     shift and go to state 139
    vacio                          shift and go to state 20

state 103

    (75) data_type -> REFERENCE STR .

    COMMA           reduce using rule 75 (data_type -> REFERENCE STR .)
    RPAREN          reduce using rule 75 (data_type -> REFERENCE STR .)
    RCORCH          reduce using rule 75 (data_type -> REFERENCE STR .)
    LLLAVE          reduce using rule 75 (data_type -> REFERENCE STR .)


state 104

    (72) list_type -> LCORCH some_data_type . RCORCH

    RCORCH          shift and go to state 140


state 105

    (94) some_data_type -> data_type .
    (95) some_data_type -> data_type . COMMA some_data_type

    RCORCH          reduce using rule 94 (some_data_type -> data_type .)
    RPAREN          reduce using rule 94 (some_data_type -> data_type .)
    COMMA           shift and go to state 141


state 106

    (73) tuple_type -> LPAREN some_data_type . RPAREN

    RPAREN          shift and go to state 142


state 107

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 143


state 108

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    data_type                      shift and go to state 144
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 109

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 61 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 61 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)


state 110

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 145


state 111

    (9) asignacion_variable -> LET IDENTIFIER ASIG . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 146
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 112

    (11) asignacion_variable -> LET IDENTIFIER COLON . asignacion
    (15) declaracion_variable -> LET IDENTIFIER COLON . asig_data_type
    (17) asignacion -> . string_asignacion
    (18) asignacion -> . char_asignacion
    (19) asignacion -> . numero_asignacion
    (20) asignacion -> . boolean_asignacion
    (21) asignacion -> . lista_asignacion
    (22) asignacion -> . tupla_asignacion
    (69) asig_data_type -> . data_type
    (70) asig_data_type -> . list_type
    (71) asig_data_type -> . tuple_type
    (23) string_asignacion -> . REFERENCE STR ASIG STRING
    (24) char_asignacion -> . CHAR ASIG CHARACTER
    (25) numero_asignacion -> . signed_integer ASIG INTEGER
    (26) numero_asignacion -> . signed_integer ASIG MINUS INTEGER
    (27) numero_asignacion -> . unsigned_integer ASIG INTEGER
    (28) numero_asignacion -> . float_type ASIG FLOAT
    (29) numero_asignacion -> . float_type ASIG MINUS FLOAT
    (30) boolean_asignacion -> . BOOL ASIG TRUE
    (31) boolean_asignacion -> . BOOL ASIG FALSE
    (32) lista_asignacion -> . list_type ASIG arreglos
    (33) tupla_asignacion -> . tuple_type ASIG tuplas
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (72) list_type -> . LCORCH some_data_type RCORCH
    (73) tuple_type -> . LPAREN some_data_type RPAREN
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    REFERENCE       shift and go to state 157
    CHAR            shift and go to state 158
    BOOL            shift and go to state 162
    LCORCH          shift and go to state 52
    LPAREN          shift and go to state 53
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    asignacion                     shift and go to state 147
    asig_data_type                 shift and go to state 148
    string_asignacion              shift and go to state 149
    char_asignacion                shift and go to state 150
    numero_asignacion              shift and go to state 151
    boolean_asignacion             shift and go to state 152
    lista_asignacion               shift and go to state 153
    tupla_asignacion               shift and go to state 154
    data_type                      shift and go to state 43
    list_type                      shift and go to state 155
    tuple_type                     shift and go to state 156
    signed_integer                 shift and go to state 159
    unsigned_integer               shift and go to state 160
    float_type                     shift and go to state 161

state 113

    (10) asignacion_variable -> LET MUT ASIG . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 163
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 114

    (12) asignacion_variable -> LET MUT IDENTIFIER . COLON asignacion
    (14) declaracion_variable -> LET MUT IDENTIFIER .
    (16) declaracion_variable -> LET MUT IDENTIFIER . COLON asig_data_type

    COLON           shift and go to state 164
    SEMICOLON       reduce using rule 14 (declaracion_variable -> LET MUT IDENTIFIER .)


state 115

    (120) llamada -> IDENTIFIER LPAREN valores . RPAREN

    RPAREN          shift and go to state 165


state 116

    (58) impresion -> PRINTLN EXCLAMATION LPAREN . valor RPAREN
    (59) impresion -> PRINTLN EXCLAMATION LPAREN . valor COMMA valores RPAREN
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 166
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 117

    (68) ingreso_datos -> STD DOUBLE_COLON IO . DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 167


state 118

    (97) arreglos -> LCORCH valores RCORCH .

    SEMICOLON       reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    COMMA           reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    RCORCH          reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    EQ              reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    NEQ             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    GEQ             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    LEQ             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    RIGHTARROW      reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    LEFTARROW       reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    RPAREN          reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    LLLAVE          reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    AND             reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)
    OR              reduce using rule 97 (arreglos -> LCORCH valores RCORCH .)


state 119

    (100) valores -> valor COMMA . valores
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 86
    valores                        shift and go to state 168
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 120

    (119) indexacion -> IDENTIFIER LCORCH . INTEGER RCORCH

    INTEGER         shift and go to state 169


state 121

    (112) operacion -> numeric PLUS . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 171
    FLOAT           shift and go to state 172
    IDENTIFIER      shift and go to state 173

    numeric                        shift and go to state 170

state 122

    (113) operacion -> numeric MINUS . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 171
    FLOAT           shift and go to state 172
    IDENTIFIER      shift and go to state 173

    numeric                        shift and go to state 174

state 123

    (114) operacion -> numeric TIMES . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 171
    FLOAT           shift and go to state 172
    IDENTIFIER      shift and go to state 173

    numeric                        shift and go to state 175

state 124

    (115) operacion -> numeric DIVIDE . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 171
    FLOAT           shift and go to state 172
    IDENTIFIER      shift and go to state 173

    numeric                        shift and go to state 176

state 125

    (116) operacion -> numeric MOD . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 171
    FLOAT           shift and go to state 172
    IDENTIFIER      shift and go to state 173

    numeric                        shift and go to state 177

state 126

    (117) operacion -> numeric INTD . numeric
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 171
    FLOAT           shift and go to state 172
    IDENTIFIER      shift and go to state 173

    numeric                        shift and go to state 178

state 127

    (118) operacion -> cadena PLUS . cadena
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    STRING          shift and go to state 180
    IDENTIFIER      shift and go to state 181

    cadena                         shift and go to state 179

state 128

    (105) condicional -> IF comparacion LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 182
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 129

    (103) proposicion -> comparacion conector . proposicion
    (103) proposicion -> . comparacion conector proposicion
    (104) proposicion -> . comparacion
    (34) comparacion -> . valor EQ valor
    (35) comparacion -> . valor NEQ valor
    (36) comparacion -> . valor GEQ valor
    (37) comparacion -> . valor LEQ valor
    (38) comparacion -> . valor RIGHTARROW valor
    (39) comparacion -> . valor LEFTARROW valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    comparacion                    shift and go to state 183
    proposicion                    shift and go to state 184
    valor                          shift and go to state 101
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 130

    (101) conector -> AND .

    INTEGER         reduce using rule 101 (conector -> AND .)
    FLOAT           reduce using rule 101 (conector -> AND .)
    IDENTIFIER      reduce using rule 101 (conector -> AND .)
    STRING          reduce using rule 101 (conector -> AND .)
    LCORCH          reduce using rule 101 (conector -> AND .)
    TRUE            reduce using rule 101 (conector -> AND .)
    FALSE           reduce using rule 101 (conector -> AND .)


state 131

    (102) conector -> OR .

    INTEGER         reduce using rule 102 (conector -> OR .)
    FLOAT           reduce using rule 102 (conector -> OR .)
    IDENTIFIER      reduce using rule 102 (conector -> OR .)
    STRING          reduce using rule 102 (conector -> OR .)
    LCORCH          reduce using rule 102 (conector -> OR .)
    TRUE            reduce using rule 102 (conector -> OR .)
    FALSE           reduce using rule 102 (conector -> OR .)


state 132

    (106) condicional -> IF proposicion LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 185
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 133

    (34) comparacion -> valor EQ . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 186
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 134

    (35) comparacion -> valor NEQ . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 187
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 135

    (36) comparacion -> valor GEQ . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 188
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 136

    (37) comparacion -> valor LEQ . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 189
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 137

    (38) comparacion -> valor RIGHTARROW . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 190
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 138

    (39) comparacion -> valor LEFTARROW . valor
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 191
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 139

    (66) parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .

    RPAREN          reduce using rule 66 (parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .)


state 140

    (72) list_type -> LCORCH some_data_type RCORCH .

    COMMA           reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)
    RPAREN          reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)
    ASIG            reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)
    SEMICOLON       reduce using rule 72 (list_type -> LCORCH some_data_type RCORCH .)


state 141

    (95) some_data_type -> data_type COMMA . some_data_type
    (94) some_data_type -> . data_type
    (95) some_data_type -> . data_type COMMA some_data_type
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    data_type                      shift and go to state 105
    some_data_type                 shift and go to state 192
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 142

    (73) tuple_type -> LPAREN some_data_type RPAREN .

    COMMA           reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)
    RPAREN          reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)
    ASIG            reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)
    SEMICOLON       reduce using rule 73 (tuple_type -> LPAREN some_data_type RPAREN .)


state 143

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 60 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 60 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)


state 144

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 193


state 145

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 194
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 146

    (9) asignacion_variable -> LET IDENTIFIER ASIG valor .

    SEMICOLON       reduce using rule 9 (asignacion_variable -> LET IDENTIFIER ASIG valor .)


state 147

    (11) asignacion_variable -> LET IDENTIFIER COLON asignacion .

    SEMICOLON       reduce using rule 11 (asignacion_variable -> LET IDENTIFIER COLON asignacion .)


state 148

    (15) declaracion_variable -> LET IDENTIFIER COLON asig_data_type .

    SEMICOLON       reduce using rule 15 (declaracion_variable -> LET IDENTIFIER COLON asig_data_type .)


state 149

    (17) asignacion -> string_asignacion .

    SEMICOLON       reduce using rule 17 (asignacion -> string_asignacion .)


state 150

    (18) asignacion -> char_asignacion .

    SEMICOLON       reduce using rule 18 (asignacion -> char_asignacion .)


state 151

    (19) asignacion -> numero_asignacion .

    SEMICOLON       reduce using rule 19 (asignacion -> numero_asignacion .)


state 152

    (20) asignacion -> boolean_asignacion .

    SEMICOLON       reduce using rule 20 (asignacion -> boolean_asignacion .)


state 153

    (21) asignacion -> lista_asignacion .

    SEMICOLON       reduce using rule 21 (asignacion -> lista_asignacion .)


state 154

    (22) asignacion -> tupla_asignacion .

    SEMICOLON       reduce using rule 22 (asignacion -> tupla_asignacion .)


state 155

    (70) asig_data_type -> list_type .
    (32) lista_asignacion -> list_type . ASIG arreglos

    SEMICOLON       reduce using rule 70 (asig_data_type -> list_type .)
    ASIG            shift and go to state 195


state 156

    (71) asig_data_type -> tuple_type .
    (33) tupla_asignacion -> tuple_type . ASIG tuplas

    SEMICOLON       reduce using rule 71 (asig_data_type -> tuple_type .)
    ASIG            shift and go to state 196


state 157

    (23) string_asignacion -> REFERENCE . STR ASIG STRING
    (75) data_type -> REFERENCE . STR

    STR             shift and go to state 197


state 158

    (24) char_asignacion -> CHAR . ASIG CHARACTER
    (74) data_type -> CHAR .

    ASIG            shift and go to state 198
    SEMICOLON       reduce using rule 74 (data_type -> CHAR .)


state 159

    (25) numero_asignacion -> signed_integer . ASIG INTEGER
    (26) numero_asignacion -> signed_integer . ASIG MINUS INTEGER
    (76) data_type -> signed_integer .

    ASIG            shift and go to state 199
    SEMICOLON       reduce using rule 76 (data_type -> signed_integer .)


state 160

    (27) numero_asignacion -> unsigned_integer . ASIG INTEGER
    (77) data_type -> unsigned_integer .

    ASIG            shift and go to state 200
    SEMICOLON       reduce using rule 77 (data_type -> unsigned_integer .)


state 161

    (28) numero_asignacion -> float_type . ASIG FLOAT
    (29) numero_asignacion -> float_type . ASIG MINUS FLOAT
    (78) data_type -> float_type .

    ASIG            shift and go to state 201
    SEMICOLON       reduce using rule 78 (data_type -> float_type .)


state 162

    (30) boolean_asignacion -> BOOL . ASIG TRUE
    (31) boolean_asignacion -> BOOL . ASIG FALSE
    (79) data_type -> BOOL .

    ASIG            shift and go to state 202
    SEMICOLON       reduce using rule 79 (data_type -> BOOL .)


state 163

    (10) asignacion_variable -> LET MUT ASIG valor .

    SEMICOLON       reduce using rule 10 (asignacion_variable -> LET MUT ASIG valor .)


state 164

    (12) asignacion_variable -> LET MUT IDENTIFIER COLON . asignacion
    (16) declaracion_variable -> LET MUT IDENTIFIER COLON . asig_data_type
    (17) asignacion -> . string_asignacion
    (18) asignacion -> . char_asignacion
    (19) asignacion -> . numero_asignacion
    (20) asignacion -> . boolean_asignacion
    (21) asignacion -> . lista_asignacion
    (22) asignacion -> . tupla_asignacion
    (69) asig_data_type -> . data_type
    (70) asig_data_type -> . list_type
    (71) asig_data_type -> . tuple_type
    (23) string_asignacion -> . REFERENCE STR ASIG STRING
    (24) char_asignacion -> . CHAR ASIG CHARACTER
    (25) numero_asignacion -> . signed_integer ASIG INTEGER
    (26) numero_asignacion -> . signed_integer ASIG MINUS INTEGER
    (27) numero_asignacion -> . unsigned_integer ASIG INTEGER
    (28) numero_asignacion -> . float_type ASIG FLOAT
    (29) numero_asignacion -> . float_type ASIG MINUS FLOAT
    (30) boolean_asignacion -> . BOOL ASIG TRUE
    (31) boolean_asignacion -> . BOOL ASIG FALSE
    (32) lista_asignacion -> . list_type ASIG arreglos
    (33) tupla_asignacion -> . tuple_type ASIG tuplas
    (74) data_type -> . CHAR
    (75) data_type -> . REFERENCE STR
    (76) data_type -> . signed_integer
    (77) data_type -> . unsigned_integer
    (78) data_type -> . float_type
    (79) data_type -> . BOOL
    (72) list_type -> . LCORCH some_data_type RCORCH
    (73) tuple_type -> . LPAREN some_data_type RPAREN
    (80) signed_integer -> . I8
    (81) signed_integer -> . I16
    (82) signed_integer -> . I32
    (83) signed_integer -> . I64
    (84) signed_integer -> . I128
    (85) signed_integer -> . ISIZE
    (86) unsigned_integer -> . U8
    (87) unsigned_integer -> . U16
    (88) unsigned_integer -> . U32
    (89) unsigned_integer -> . U64
    (90) unsigned_integer -> . U128
    (91) unsigned_integer -> . USIZE
    (92) float_type -> . F32
    (93) float_type -> . F64

    REFERENCE       shift and go to state 157
    CHAR            shift and go to state 158
    BOOL            shift and go to state 162
    LCORCH          shift and go to state 52
    LPAREN          shift and go to state 53
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    asignacion                     shift and go to state 203
    asig_data_type                 shift and go to state 204
    string_asignacion              shift and go to state 149
    char_asignacion                shift and go to state 150
    numero_asignacion              shift and go to state 151
    boolean_asignacion             shift and go to state 152
    lista_asignacion               shift and go to state 153
    tupla_asignacion               shift and go to state 154
    data_type                      shift and go to state 43
    list_type                      shift and go to state 155
    tuple_type                     shift and go to state 156
    signed_integer                 shift and go to state 159
    unsigned_integer               shift and go to state 160
    float_type                     shift and go to state 161

state 165

    (120) llamada -> IDENTIFIER LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 120 (llamada -> IDENTIFIER LPAREN valores RPAREN .)


state 166

    (58) impresion -> PRINTLN EXCLAMATION LPAREN valor . RPAREN
    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor . COMMA valores RPAREN

    RPAREN          shift and go to state 205
    COMMA           shift and go to state 206


state 167

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON . DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 207


state 168

    (100) valores -> valor COMMA valores .

    RCORCH          reduce using rule 100 (valores -> valor COMMA valores .)
    RPAREN          reduce using rule 100 (valores -> valor COMMA valores .)


state 169

    (119) indexacion -> IDENTIFIER LCORCH INTEGER . RCORCH

    RCORCH          shift and go to state 208


state 170

    (112) operacion -> numeric PLUS numeric .

    COMMA           reduce using rule 112 (operacion -> numeric PLUS numeric .)
    RCORCH          reduce using rule 112 (operacion -> numeric PLUS numeric .)
    EQ              reduce using rule 112 (operacion -> numeric PLUS numeric .)
    NEQ             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    GEQ             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    LEQ             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    RIGHTARROW      reduce using rule 112 (operacion -> numeric PLUS numeric .)
    LEFTARROW       reduce using rule 112 (operacion -> numeric PLUS numeric .)
    RPAREN          reduce using rule 112 (operacion -> numeric PLUS numeric .)
    SEMICOLON       reduce using rule 112 (operacion -> numeric PLUS numeric .)
    LLLAVE          reduce using rule 112 (operacion -> numeric PLUS numeric .)
    AND             reduce using rule 112 (operacion -> numeric PLUS numeric .)
    OR              reduce using rule 112 (operacion -> numeric PLUS numeric .)


state 171

    (107) numeric -> INTEGER .

    COMMA           reduce using rule 107 (numeric -> INTEGER .)
    RCORCH          reduce using rule 107 (numeric -> INTEGER .)
    EQ              reduce using rule 107 (numeric -> INTEGER .)
    NEQ             reduce using rule 107 (numeric -> INTEGER .)
    GEQ             reduce using rule 107 (numeric -> INTEGER .)
    LEQ             reduce using rule 107 (numeric -> INTEGER .)
    RIGHTARROW      reduce using rule 107 (numeric -> INTEGER .)
    LEFTARROW       reduce using rule 107 (numeric -> INTEGER .)
    RPAREN          reduce using rule 107 (numeric -> INTEGER .)
    SEMICOLON       reduce using rule 107 (numeric -> INTEGER .)
    LLLAVE          reduce using rule 107 (numeric -> INTEGER .)
    AND             reduce using rule 107 (numeric -> INTEGER .)
    OR              reduce using rule 107 (numeric -> INTEGER .)


state 172

    (108) numeric -> FLOAT .

    COMMA           reduce using rule 108 (numeric -> FLOAT .)
    RCORCH          reduce using rule 108 (numeric -> FLOAT .)
    EQ              reduce using rule 108 (numeric -> FLOAT .)
    NEQ             reduce using rule 108 (numeric -> FLOAT .)
    GEQ             reduce using rule 108 (numeric -> FLOAT .)
    LEQ             reduce using rule 108 (numeric -> FLOAT .)
    RIGHTARROW      reduce using rule 108 (numeric -> FLOAT .)
    LEFTARROW       reduce using rule 108 (numeric -> FLOAT .)
    RPAREN          reduce using rule 108 (numeric -> FLOAT .)
    SEMICOLON       reduce using rule 108 (numeric -> FLOAT .)
    LLLAVE          reduce using rule 108 (numeric -> FLOAT .)
    AND             reduce using rule 108 (numeric -> FLOAT .)
    OR              reduce using rule 108 (numeric -> FLOAT .)


state 173

    (109) numeric -> IDENTIFIER .

    COMMA           reduce using rule 109 (numeric -> IDENTIFIER .)
    RCORCH          reduce using rule 109 (numeric -> IDENTIFIER .)
    EQ              reduce using rule 109 (numeric -> IDENTIFIER .)
    NEQ             reduce using rule 109 (numeric -> IDENTIFIER .)
    GEQ             reduce using rule 109 (numeric -> IDENTIFIER .)
    LEQ             reduce using rule 109 (numeric -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 109 (numeric -> IDENTIFIER .)
    LEFTARROW       reduce using rule 109 (numeric -> IDENTIFIER .)
    RPAREN          reduce using rule 109 (numeric -> IDENTIFIER .)
    SEMICOLON       reduce using rule 109 (numeric -> IDENTIFIER .)
    LLLAVE          reduce using rule 109 (numeric -> IDENTIFIER .)
    AND             reduce using rule 109 (numeric -> IDENTIFIER .)
    OR              reduce using rule 109 (numeric -> IDENTIFIER .)


state 174

    (113) operacion -> numeric MINUS numeric .

    COMMA           reduce using rule 113 (operacion -> numeric MINUS numeric .)
    RCORCH          reduce using rule 113 (operacion -> numeric MINUS numeric .)
    EQ              reduce using rule 113 (operacion -> numeric MINUS numeric .)
    NEQ             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    GEQ             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    LEQ             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    RIGHTARROW      reduce using rule 113 (operacion -> numeric MINUS numeric .)
    LEFTARROW       reduce using rule 113 (operacion -> numeric MINUS numeric .)
    RPAREN          reduce using rule 113 (operacion -> numeric MINUS numeric .)
    SEMICOLON       reduce using rule 113 (operacion -> numeric MINUS numeric .)
    LLLAVE          reduce using rule 113 (operacion -> numeric MINUS numeric .)
    AND             reduce using rule 113 (operacion -> numeric MINUS numeric .)
    OR              reduce using rule 113 (operacion -> numeric MINUS numeric .)


state 175

    (114) operacion -> numeric TIMES numeric .

    COMMA           reduce using rule 114 (operacion -> numeric TIMES numeric .)
    RCORCH          reduce using rule 114 (operacion -> numeric TIMES numeric .)
    EQ              reduce using rule 114 (operacion -> numeric TIMES numeric .)
    NEQ             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    GEQ             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    LEQ             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    RIGHTARROW      reduce using rule 114 (operacion -> numeric TIMES numeric .)
    LEFTARROW       reduce using rule 114 (operacion -> numeric TIMES numeric .)
    RPAREN          reduce using rule 114 (operacion -> numeric TIMES numeric .)
    SEMICOLON       reduce using rule 114 (operacion -> numeric TIMES numeric .)
    LLLAVE          reduce using rule 114 (operacion -> numeric TIMES numeric .)
    AND             reduce using rule 114 (operacion -> numeric TIMES numeric .)
    OR              reduce using rule 114 (operacion -> numeric TIMES numeric .)


state 176

    (115) operacion -> numeric DIVIDE numeric .

    COMMA           reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    RCORCH          reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    EQ              reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    NEQ             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    GEQ             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    LEQ             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    RIGHTARROW      reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    LEFTARROW       reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    RPAREN          reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    SEMICOLON       reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    LLLAVE          reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    AND             reduce using rule 115 (operacion -> numeric DIVIDE numeric .)
    OR              reduce using rule 115 (operacion -> numeric DIVIDE numeric .)


state 177

    (116) operacion -> numeric MOD numeric .

    COMMA           reduce using rule 116 (operacion -> numeric MOD numeric .)
    RCORCH          reduce using rule 116 (operacion -> numeric MOD numeric .)
    EQ              reduce using rule 116 (operacion -> numeric MOD numeric .)
    NEQ             reduce using rule 116 (operacion -> numeric MOD numeric .)
    GEQ             reduce using rule 116 (operacion -> numeric MOD numeric .)
    LEQ             reduce using rule 116 (operacion -> numeric MOD numeric .)
    RIGHTARROW      reduce using rule 116 (operacion -> numeric MOD numeric .)
    LEFTARROW       reduce using rule 116 (operacion -> numeric MOD numeric .)
    RPAREN          reduce using rule 116 (operacion -> numeric MOD numeric .)
    SEMICOLON       reduce using rule 116 (operacion -> numeric MOD numeric .)
    LLLAVE          reduce using rule 116 (operacion -> numeric MOD numeric .)
    AND             reduce using rule 116 (operacion -> numeric MOD numeric .)
    OR              reduce using rule 116 (operacion -> numeric MOD numeric .)


state 178

    (117) operacion -> numeric INTD numeric .

    COMMA           reduce using rule 117 (operacion -> numeric INTD numeric .)
    RCORCH          reduce using rule 117 (operacion -> numeric INTD numeric .)
    EQ              reduce using rule 117 (operacion -> numeric INTD numeric .)
    NEQ             reduce using rule 117 (operacion -> numeric INTD numeric .)
    GEQ             reduce using rule 117 (operacion -> numeric INTD numeric .)
    LEQ             reduce using rule 117 (operacion -> numeric INTD numeric .)
    RIGHTARROW      reduce using rule 117 (operacion -> numeric INTD numeric .)
    LEFTARROW       reduce using rule 117 (operacion -> numeric INTD numeric .)
    RPAREN          reduce using rule 117 (operacion -> numeric INTD numeric .)
    SEMICOLON       reduce using rule 117 (operacion -> numeric INTD numeric .)
    LLLAVE          reduce using rule 117 (operacion -> numeric INTD numeric .)
    AND             reduce using rule 117 (operacion -> numeric INTD numeric .)
    OR              reduce using rule 117 (operacion -> numeric INTD numeric .)


state 179

    (118) operacion -> cadena PLUS cadena .

    COMMA           reduce using rule 118 (operacion -> cadena PLUS cadena .)
    RCORCH          reduce using rule 118 (operacion -> cadena PLUS cadena .)
    EQ              reduce using rule 118 (operacion -> cadena PLUS cadena .)
    NEQ             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    GEQ             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    LEQ             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    RIGHTARROW      reduce using rule 118 (operacion -> cadena PLUS cadena .)
    LEFTARROW       reduce using rule 118 (operacion -> cadena PLUS cadena .)
    RPAREN          reduce using rule 118 (operacion -> cadena PLUS cadena .)
    SEMICOLON       reduce using rule 118 (operacion -> cadena PLUS cadena .)
    LLLAVE          reduce using rule 118 (operacion -> cadena PLUS cadena .)
    AND             reduce using rule 118 (operacion -> cadena PLUS cadena .)
    OR              reduce using rule 118 (operacion -> cadena PLUS cadena .)


state 180

    (110) cadena -> STRING .

    COMMA           reduce using rule 110 (cadena -> STRING .)
    RCORCH          reduce using rule 110 (cadena -> STRING .)
    EQ              reduce using rule 110 (cadena -> STRING .)
    NEQ             reduce using rule 110 (cadena -> STRING .)
    GEQ             reduce using rule 110 (cadena -> STRING .)
    LEQ             reduce using rule 110 (cadena -> STRING .)
    RIGHTARROW      reduce using rule 110 (cadena -> STRING .)
    LEFTARROW       reduce using rule 110 (cadena -> STRING .)
    RPAREN          reduce using rule 110 (cadena -> STRING .)
    SEMICOLON       reduce using rule 110 (cadena -> STRING .)
    LLLAVE          reduce using rule 110 (cadena -> STRING .)
    AND             reduce using rule 110 (cadena -> STRING .)
    OR              reduce using rule 110 (cadena -> STRING .)


state 181

    (111) cadena -> IDENTIFIER .

    COMMA           reduce using rule 111 (cadena -> IDENTIFIER .)
    RCORCH          reduce using rule 111 (cadena -> IDENTIFIER .)
    EQ              reduce using rule 111 (cadena -> IDENTIFIER .)
    NEQ             reduce using rule 111 (cadena -> IDENTIFIER .)
    GEQ             reduce using rule 111 (cadena -> IDENTIFIER .)
    LEQ             reduce using rule 111 (cadena -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 111 (cadena -> IDENTIFIER .)
    LEFTARROW       reduce using rule 111 (cadena -> IDENTIFIER .)
    RPAREN          reduce using rule 111 (cadena -> IDENTIFIER .)
    SEMICOLON       reduce using rule 111 (cadena -> IDENTIFIER .)
    LLLAVE          reduce using rule 111 (cadena -> IDENTIFIER .)
    AND             reduce using rule 111 (cadena -> IDENTIFIER .)
    OR              reduce using rule 111 (cadena -> IDENTIFIER .)


state 182

    (105) condicional -> IF comparacion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 209


state 183

    (103) proposicion -> comparacion . conector proposicion
    (104) proposicion -> comparacion .
    (101) conector -> . AND
    (102) conector -> . OR

    LLLAVE          reduce using rule 104 (proposicion -> comparacion .)
    AND             shift and go to state 130
    OR              shift and go to state 131

    conector                       shift and go to state 129

state 184

    (103) proposicion -> comparacion conector proposicion .

    LLLAVE          reduce using rule 103 (proposicion -> comparacion conector proposicion .)


state 185

    (106) condicional -> IF proposicion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 210


state 186

    (34) comparacion -> valor EQ valor .

    LLLAVE          reduce using rule 34 (comparacion -> valor EQ valor .)
    AND             reduce using rule 34 (comparacion -> valor EQ valor .)
    OR              reduce using rule 34 (comparacion -> valor EQ valor .)


state 187

    (35) comparacion -> valor NEQ valor .

    LLLAVE          reduce using rule 35 (comparacion -> valor NEQ valor .)
    AND             reduce using rule 35 (comparacion -> valor NEQ valor .)
    OR              reduce using rule 35 (comparacion -> valor NEQ valor .)


state 188

    (36) comparacion -> valor GEQ valor .

    LLLAVE          reduce using rule 36 (comparacion -> valor GEQ valor .)
    AND             reduce using rule 36 (comparacion -> valor GEQ valor .)
    OR              reduce using rule 36 (comparacion -> valor GEQ valor .)


state 189

    (37) comparacion -> valor LEQ valor .

    LLLAVE          reduce using rule 37 (comparacion -> valor LEQ valor .)
    AND             reduce using rule 37 (comparacion -> valor LEQ valor .)
    OR              reduce using rule 37 (comparacion -> valor LEQ valor .)


state 190

    (38) comparacion -> valor RIGHTARROW valor .

    LLLAVE          reduce using rule 38 (comparacion -> valor RIGHTARROW valor .)
    AND             reduce using rule 38 (comparacion -> valor RIGHTARROW valor .)
    OR              reduce using rule 38 (comparacion -> valor RIGHTARROW valor .)


state 191

    (39) comparacion -> valor LEFTARROW valor .

    LLLAVE          reduce using rule 39 (comparacion -> valor LEFTARROW valor .)
    AND             reduce using rule 39 (comparacion -> valor LEFTARROW valor .)
    OR              reduce using rule 39 (comparacion -> valor LEFTARROW valor .)


state 192

    (95) some_data_type -> data_type COMMA some_data_type .

    RCORCH          reduce using rule 95 (some_data_type -> data_type COMMA some_data_type .)
    RPAREN          reduce using rule 95 (some_data_type -> data_type COMMA some_data_type .)


state 193

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (51) sentencias -> . asignacion_variable SEMICOLON
    (52) sentencias -> . declaracion_variable SEMICOLON
    (53) sentencias -> . impresion SEMICOLON
    (54) sentencias -> . ingreso_datos SEMICOLON
    (55) sentencias -> . arreglos SEMICOLON
    (56) sentencias -> . control_structure
    (57) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (58) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (59) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (68) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (97) arreglos -> . LCORCH valores RCORCH
    (96) control_structure -> . condicional
    (120) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (105) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (106) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 211
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 194

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (64) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 213

    retorno                        shift and go to state 212

state 195

    (32) lista_asignacion -> list_type ASIG . arreglos
    (97) arreglos -> . LCORCH valores RCORCH

    LCORCH          shift and go to state 39

    arreglos                       shift and go to state 214

state 196

    (33) tupla_asignacion -> tuple_type ASIG . tuplas
    (98) tuplas -> . LPAREN valores RPAREN

    LPAREN          shift and go to state 216

    tuplas                         shift and go to state 215

state 197

    (23) string_asignacion -> REFERENCE STR . ASIG STRING
    (75) data_type -> REFERENCE STR .

    ASIG            shift and go to state 217
    SEMICOLON       reduce using rule 75 (data_type -> REFERENCE STR .)


state 198

    (24) char_asignacion -> CHAR ASIG . CHARACTER

    CHARACTER       shift and go to state 218


state 199

    (25) numero_asignacion -> signed_integer ASIG . INTEGER
    (26) numero_asignacion -> signed_integer ASIG . MINUS INTEGER

    INTEGER         shift and go to state 219
    MINUS           shift and go to state 220


state 200

    (27) numero_asignacion -> unsigned_integer ASIG . INTEGER

    INTEGER         shift and go to state 221


state 201

    (28) numero_asignacion -> float_type ASIG . FLOAT
    (29) numero_asignacion -> float_type ASIG . MINUS FLOAT

    FLOAT           shift and go to state 222
    MINUS           shift and go to state 223


state 202

    (30) boolean_asignacion -> BOOL ASIG . TRUE
    (31) boolean_asignacion -> BOOL ASIG . FALSE

    TRUE            shift and go to state 224
    FALSE           shift and go to state 225


state 203

    (12) asignacion_variable -> LET MUT IDENTIFIER COLON asignacion .

    SEMICOLON       reduce using rule 12 (asignacion_variable -> LET MUT IDENTIFIER COLON asignacion .)


state 204

    (16) declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type .

    SEMICOLON       reduce using rule 16 (declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type .)


state 205

    (58) impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 58 (impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .)


state 206

    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA . valores RPAREN
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 86
    valores                        shift and go to state 226
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 207

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT . STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    STDIN           shift and go to state 227


state 208

    (119) indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .

    COMMA           reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RCORCH          reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    EQ              reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    NEQ             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    GEQ             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEQ             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RIGHTARROW      reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEFTARROW       reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RPAREN          reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    SEMICOLON       reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LLLAVE          reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    AND             reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    OR              reduce using rule 119 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)


state 209

    (105) condicional -> IF comparacion LLLAVE programa RLLAVE .

    LET             reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    STD             reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IF              reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 105 (condicional -> IF comparacion LLLAVE programa RLLAVE .)


state 210

    (106) condicional -> IF proposicion LLLAVE programa RLLAVE .

    LET             reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    STD             reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IF              reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 106 (condicional -> IF proposicion LLLAVE programa RLLAVE .)


state 211

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (64) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 213

    retorno                        shift and go to state 228

state 212

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 229


state 213

    (64) retorno -> RETURN . valor SEMICOLON
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 230
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 214

    (32) lista_asignacion -> list_type ASIG arreglos .

    SEMICOLON       reduce using rule 32 (lista_asignacion -> list_type ASIG arreglos .)


state 215

    (33) tupla_asignacion -> tuple_type ASIG tuplas .

    SEMICOLON       reduce using rule 33 (tupla_asignacion -> tuple_type ASIG tuplas .)


state 216

    (98) tuplas -> LPAREN . valores RPAREN
    (99) valores -> . valor
    (100) valores -> . valor COMMA valores
    (40) valor -> . INTEGER
    (41) valor -> . FLOAT
    (42) valor -> . IDENTIFIER
    (43) valor -> . operacion
    (44) valor -> . indexacion
    (45) valor -> . arreglos
    (46) valor -> . STRING
    (47) valor -> . booleanos
    (112) operacion -> . numeric PLUS numeric
    (113) operacion -> . numeric MINUS numeric
    (114) operacion -> . numeric TIMES numeric
    (115) operacion -> . numeric DIVIDE numeric
    (116) operacion -> . numeric MOD numeric
    (117) operacion -> . numeric INTD numeric
    (118) operacion -> . cadena PLUS cadena
    (119) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (97) arreglos -> . LCORCH valores RCORCH
    (48) booleanos -> . TRUE
    (49) booleanos -> . FALSE
    (107) numeric -> . INTEGER
    (108) numeric -> . FLOAT
    (109) numeric -> . IDENTIFIER
    (110) cadena -> . STRING
    (111) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valores                        shift and go to state 231
    valor                          shift and go to state 86
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 217

    (23) string_asignacion -> REFERENCE STR ASIG . STRING

    STRING          shift and go to state 232


state 218

    (24) char_asignacion -> CHAR ASIG CHARACTER .

    SEMICOLON       reduce using rule 24 (char_asignacion -> CHAR ASIG CHARACTER .)


state 219

    (25) numero_asignacion -> signed_integer ASIG INTEGER .

    SEMICOLON       reduce using rule 25 (numero_asignacion -> signed_integer ASIG INTEGER .)


state 220

    (26) numero_asignacion -> signed_integer ASIG MINUS . INTEGER

    INTEGER         shift and go to state 233


state 221

    (27) numero_asignacion -> unsigned_integer ASIG INTEGER .

    SEMICOLON       reduce using rule 27 (numero_asignacion -> unsigned_integer ASIG INTEGER .)


state 222

    (28) numero_asignacion -> float_type ASIG FLOAT .

    SEMICOLON       reduce using rule 28 (numero_asignacion -> float_type ASIG FLOAT .)


state 223

    (29) numero_asignacion -> float_type ASIG MINUS . FLOAT

    FLOAT           shift and go to state 234


state 224

    (30) boolean_asignacion -> BOOL ASIG TRUE .

    SEMICOLON       reduce using rule 30 (boolean_asignacion -> BOOL ASIG TRUE .)


state 225

    (31) boolean_asignacion -> BOOL ASIG FALSE .

    SEMICOLON       reduce using rule 31 (boolean_asignacion -> BOOL ASIG FALSE .)


state 226

    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores . RPAREN

    RPAREN          shift and go to state 235


state 227

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN . LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 236


state 228

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 237


state 229

    (63) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    FN              reduce using rule 63 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 63 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 230

    (64) retorno -> RETURN valor . SEMICOLON

    SEMICOLON       shift and go to state 238


state 231

    (98) tuplas -> LPAREN valores . RPAREN

    RPAREN          shift and go to state 239


state 232

    (23) string_asignacion -> REFERENCE STR ASIG STRING .

    SEMICOLON       reduce using rule 23 (string_asignacion -> REFERENCE STR ASIG STRING .)


state 233

    (26) numero_asignacion -> signed_integer ASIG MINUS INTEGER .

    SEMICOLON       reduce using rule 26 (numero_asignacion -> signed_integer ASIG MINUS INTEGER .)


state 234

    (29) numero_asignacion -> float_type ASIG MINUS FLOAT .

    SEMICOLON       reduce using rule 29 (numero_asignacion -> float_type ASIG MINUS FLOAT .)


state 235

    (59) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .

    SEMICOLON       reduce using rule 59 (impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .)


state 236

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN . RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    RPAREN          shift and go to state 240


state 237

    (62) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    FN              reduce using rule 62 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 62 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 238

    (64) retorno -> RETURN valor SEMICOLON .

    RLLAVE          reduce using rule 64 (retorno -> RETURN valor SEMICOLON .)


state 239

    (98) tuplas -> LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 98 (tuplas -> LPAREN valores RPAREN .)


state 240

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN . DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 241


state 241

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT . READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    READLINE        shift and go to state 242


state 242

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE . LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 243


state 243

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN . REFERENCE MUT IDENTIFIER RPAREN

    REFERENCE       shift and go to state 244


state 244

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE . MUT IDENTIFIER RPAREN

    MUT             shift and go to state 245


state 245

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 246


state 246

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER . RPAREN

    RPAREN          shift and go to state 247


state 247

    (68) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .

    SEMICOLON       reduce using rule 68 (ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 15 resolved as shift
WARNING: shift/reduce conflict for LLLAVE in state 99 resolved as shift
WARNING: reduce/reduce conflict in state 89 resolved using rule (numeric -> IDENTIFIER)
WARNING: rejected rule (cadena -> IDENTIFIER) in state 89
