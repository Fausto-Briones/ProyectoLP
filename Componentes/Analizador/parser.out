Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOUBLE_QUOTATION_MARK
    ELSE
    FALSE
    FOR
    FROM
    IMPL
    IN
    MATCH
    NOT
    QUOTATION_MARK
    RAND
    RETURN
    SELF
    STR
    STRUCT
    TRUE
    WHILE

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencias
Rule 2     programa -> sentencias programa
Rule 3     asignacion -> LET IDENTIFIER ASIG valor
Rule 4     asignacion -> LET MUT IDENTIFIER ASIG valor
Rule 5     asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor
Rule 6     asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor
Rule 7     comparacion -> valor EQ IDENTIFIER
Rule 8     comparacion -> valor NEQ IDENTIFIER
Rule 9     comparacion -> valor GEQ IDENTIFIER
Rule 10    comparacion -> valor LEQ IDENTIFIER
Rule 11    comparacion -> valor RIGHTARROW IDENTIFIER
Rule 12    comparacion -> valor LEFTARROW IDENTIFIER
Rule 13    valor -> INTEGER
Rule 14    valor -> FLOAT
Rule 15    valor -> IDENTIFIER
Rule 16    valor -> operacion
Rule 17    valor -> indexacion
Rule 18    valor -> arreglos
Rule 19    valor -> STRING
Rule 20    vacio -> <empty>
Rule 21    sentencias -> asignacion SEMICOLON
Rule 22    sentencias -> impresion SEMICOLON
Rule 23    sentencias -> funcion
Rule 24    sentencias -> ingreso_datos SEMICOLON
Rule 25    sentencias -> arreglos SEMICOLON
Rule 26    sentencias -> control_structure SEMICOLON
Rule 27    impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN
Rule 28    impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
Rule 29    funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
Rule 30    funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
Rule 31    parameters -> IDENTIFIER COLON asig_data_type
Rule 32    parameters -> IDENTIFIER COLON asig_data_type COMMA parameters
Rule 33    parameters -> vacio
Rule 34    ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
Rule 35    asig_data_type -> data_type
Rule 36    asig_data_type -> LPAREN some_data_type RPAREN
Rule 37    asig_data_type -> LCORCH some_data_type RCORCH
Rule 38    data_type -> CHAR
Rule 39    data_type -> signed_integer
Rule 40    data_type -> unsigned_integer
Rule 41    data_type -> float_type
Rule 42    data_type -> BOOL
Rule 43    signed_integer -> I8
Rule 44    signed_integer -> I16
Rule 45    signed_integer -> I32
Rule 46    signed_integer -> I64
Rule 47    signed_integer -> I128
Rule 48    signed_integer -> ISIZE
Rule 49    unsigned_integer -> U8
Rule 50    unsigned_integer -> U16
Rule 51    unsigned_integer -> U32
Rule 52    unsigned_integer -> U64
Rule 53    unsigned_integer -> U128
Rule 54    unsigned_integer -> USIZE
Rule 55    float_type -> F32
Rule 56    float_type -> F64
Rule 57    some_data_type -> data_type
Rule 58    some_data_type -> data_type COMMA some_data_type
Rule 59    control_structure -> condicional
Rule 60    arreglos -> LCORCH valores RCORCH
Rule 61    valores -> valor
Rule 62    valores -> valor COMMA valores
Rule 63    conector -> AND
Rule 64    conector -> OR
Rule 65    proposicion -> comparacion conector proposicion
Rule 66    proposicion -> comparacion
Rule 67    condicional -> IF comparacion LLLAVE programa RLLAVE
Rule 68    condicional -> IF proposicion LLLAVE programa RLLAVE
Rule 69    operacion -> valor PLUS valor
Rule 70    operacion -> valor MINUS valor
Rule 71    operacion -> valor TIMES valor
Rule 72    operacion -> valor DIVIDE valor
Rule 73    operacion -> valor MOD valor
Rule 74    operacion -> valor INTD valor
Rule 75    indexacion -> IDENTIFIER LCORCH INTEGER RCORCH

Terminals, with rules where they appear

AND                  : 63
ASIG                 : 3 4 5 6
BOOL                 : 42
CHAR                 : 38
COLON                : 5 6 31 32
COMMA                : 28 32 58 62
DIVIDE               : 72
DOT                  : 34 34
DOUBLE_COLON         : 34 34
DOUBLE_QUOTATION_MARK : 
ELSE                 : 
EQ                   : 7
EXCLAMATION          : 27 28
F32                  : 55
F64                  : 56
FALSE                : 
FLOAT                : 14
FN                   : 29 30
FOR                  : 
FROM                 : 
GEQ                  : 9
I128                 : 47
I16                  : 44
I32                  : 45
I64                  : 46
I8                   : 43
IDENTIFIER           : 3 4 5 6 7 8 9 10 11 12 15 29 31 32 34 75
IF                   : 67 68
IMPL                 : 
IN                   : 
INTD                 : 74
INTEGER              : 13 75
IO                   : 34
ISIZE                : 48
LCORCH               : 37 60 75
LEFTARROW            : 12
LEQ                  : 10
LET                  : 3 4 5 6
LLLAVE               : 29 30 67 68
LPAREN               : 27 28 29 30 34 34 36
MAIN                 : 30
MATCH                : 
MINUS                : 70
MOD                  : 73
MUT                  : 4 6 34
NEQ                  : 8
NOT                  : 
OR                   : 64
PLUS                 : 69
PRINTLN              : 27 28
QUOTATION_MARK       : 
RAND                 : 
RCORCH               : 37 60 75
READLINE             : 34
REFERENCE            : 34
RETURN               : 
RIGHTARROW           : 11
RLLAVE               : 29 30 67 68
RPAREN               : 27 28 29 30 34 34 36
SELF                 : 
SEMICOLON            : 21 22 24 25 26
STD                  : 34
STDIN                : 34
STR                  : 
STRING               : 19
STRUCT               : 
TIMES                : 71
TRUE                 : 
U128                 : 53
U16                  : 50
U32                  : 51
U64                  : 52
U8                   : 49
USIZE                : 54
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arreglos             : 18 25
asig_data_type       : 5 6 31 32
asignacion           : 21
comparacion          : 65 66 67
condicional          : 59
conector             : 65
control_structure    : 26
data_type            : 35 57 58
float_type           : 41
funcion              : 23
impresion            : 22
indexacion           : 17
ingreso_datos        : 24
operacion            : 16
parameters           : 29 30 32
programa             : 2 67 68 0
proposicion          : 65 68
sentencias           : 1 2 29 30
signed_integer       : 39
some_data_type       : 36 37 58
unsigned_integer     : 40
vacio                : 33
valor                : 3 4 5 6 7 8 9 10 11 12 27 28 61 62 69 69 70 70 71 71 72 72 73 73 74 74
valores              : 28 60 62

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (21) sentencias -> . asignacion SEMICOLON
    (22) sentencias -> . impresion SEMICOLON
    (23) sentencias -> . funcion
    (24) sentencias -> . ingreso_datos SEMICOLON
    (25) sentencias -> . arreglos SEMICOLON
    (26) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (27) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (28) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (29) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (30) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (34) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (60) arreglos -> . LCORCH valores RCORCH
    (59) control_structure -> . condicional
    (67) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (68) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    programa                       shift and go to state 1
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencias .
    (2) programa -> sentencias . programa
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (21) sentencias -> . asignacion SEMICOLON
    (22) sentencias -> . impresion SEMICOLON
    (23) sentencias -> . funcion
    (24) sentencias -> . ingreso_datos SEMICOLON
    (25) sentencias -> . arreglos SEMICOLON
    (26) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (27) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (28) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (29) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (30) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (34) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (60) arreglos -> . LCORCH valores RCORCH
    (59) control_structure -> . condicional
    (67) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (68) condicional -> . IF proposicion LLLAVE programa RLLAVE

    $end            reduce using rule 1 (programa -> sentencias .)
    RLLAVE          reduce using rule 1 (programa -> sentencias .)
    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    sentencias                     shift and go to state 2
    programa                       shift and go to state 16
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 3

    (21) sentencias -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 17


state 4

    (22) sentencias -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 18


state 5

    (23) sentencias -> funcion .

    LET             reduce using rule 23 (sentencias -> funcion .)
    PRINTLN         reduce using rule 23 (sentencias -> funcion .)
    FN              reduce using rule 23 (sentencias -> funcion .)
    STD             reduce using rule 23 (sentencias -> funcion .)
    LCORCH          reduce using rule 23 (sentencias -> funcion .)
    IF              reduce using rule 23 (sentencias -> funcion .)
    $end            reduce using rule 23 (sentencias -> funcion .)
    RLLAVE          reduce using rule 23 (sentencias -> funcion .)


state 6

    (24) sentencias -> ingreso_datos . SEMICOLON

    SEMICOLON       shift and go to state 19


state 7

    (25) sentencias -> arreglos . SEMICOLON

    SEMICOLON       shift and go to state 20


state 8

    (26) sentencias -> control_structure . SEMICOLON

    SEMICOLON       shift and go to state 21


state 9

    (3) asignacion -> LET . IDENTIFIER ASIG valor
    (4) asignacion -> LET . MUT IDENTIFIER ASIG valor
    (5) asignacion -> LET . IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> LET . MUT IDENTIFIER COLON asig_data_type ASIG valor

    IDENTIFIER      shift and go to state 22
    MUT             shift and go to state 23


state 10

    (27) impresion -> PRINTLN . EXCLAMATION LPAREN valor RPAREN
    (28) impresion -> PRINTLN . EXCLAMATION LPAREN valor COMMA valores RPAREN

    EXCLAMATION     shift and go to state 24


state 11

    (29) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (30) funcion -> FN . MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE

    IDENTIFIER      shift and go to state 25
    MAIN            shift and go to state 26


state 12

    (34) ingreso_datos -> STD . DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 27


state 13

    (60) arreglos -> LCORCH . valores RCORCH
    (61) valores -> . valor
    (62) valores -> . valor COMMA valores
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valores                        shift and go to state 28
    valor                          shift and go to state 29
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 14

    (59) control_structure -> condicional .

    SEMICOLON       reduce using rule 59 (control_structure -> condicional .)


state 15

    (67) condicional -> IF . comparacion LLLAVE programa RLLAVE
    (68) condicional -> IF . proposicion LLLAVE programa RLLAVE
    (7) comparacion -> . valor EQ IDENTIFIER
    (8) comparacion -> . valor NEQ IDENTIFIER
    (9) comparacion -> . valor GEQ IDENTIFIER
    (10) comparacion -> . valor LEQ IDENTIFIER
    (11) comparacion -> . valor RIGHTARROW IDENTIFIER
    (12) comparacion -> . valor LEFTARROW IDENTIFIER
    (65) proposicion -> . comparacion conector proposicion
    (66) proposicion -> . comparacion
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    comparacion                    shift and go to state 37
    proposicion                    shift and go to state 38
    valor                          shift and go to state 39
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 16

    (2) programa -> sentencias programa .

    $end            reduce using rule 2 (programa -> sentencias programa .)
    RLLAVE          reduce using rule 2 (programa -> sentencias programa .)


state 17

    (21) sentencias -> asignacion SEMICOLON .

    LET             reduce using rule 21 (sentencias -> asignacion SEMICOLON .)
    PRINTLN         reduce using rule 21 (sentencias -> asignacion SEMICOLON .)
    FN              reduce using rule 21 (sentencias -> asignacion SEMICOLON .)
    STD             reduce using rule 21 (sentencias -> asignacion SEMICOLON .)
    LCORCH          reduce using rule 21 (sentencias -> asignacion SEMICOLON .)
    IF              reduce using rule 21 (sentencias -> asignacion SEMICOLON .)
    $end            reduce using rule 21 (sentencias -> asignacion SEMICOLON .)
    RLLAVE          reduce using rule 21 (sentencias -> asignacion SEMICOLON .)


state 18

    (22) sentencias -> impresion SEMICOLON .

    LET             reduce using rule 22 (sentencias -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 22 (sentencias -> impresion SEMICOLON .)
    FN              reduce using rule 22 (sentencias -> impresion SEMICOLON .)
    STD             reduce using rule 22 (sentencias -> impresion SEMICOLON .)
    LCORCH          reduce using rule 22 (sentencias -> impresion SEMICOLON .)
    IF              reduce using rule 22 (sentencias -> impresion SEMICOLON .)
    $end            reduce using rule 22 (sentencias -> impresion SEMICOLON .)
    RLLAVE          reduce using rule 22 (sentencias -> impresion SEMICOLON .)


state 19

    (24) sentencias -> ingreso_datos SEMICOLON .

    LET             reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)
    PRINTLN         reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)
    FN              reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)
    STD             reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)
    LCORCH          reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)
    IF              reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)
    $end            reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)
    RLLAVE          reduce using rule 24 (sentencias -> ingreso_datos SEMICOLON .)


state 20

    (25) sentencias -> arreglos SEMICOLON .

    LET             reduce using rule 25 (sentencias -> arreglos SEMICOLON .)
    PRINTLN         reduce using rule 25 (sentencias -> arreglos SEMICOLON .)
    FN              reduce using rule 25 (sentencias -> arreglos SEMICOLON .)
    STD             reduce using rule 25 (sentencias -> arreglos SEMICOLON .)
    LCORCH          reduce using rule 25 (sentencias -> arreglos SEMICOLON .)
    IF              reduce using rule 25 (sentencias -> arreglos SEMICOLON .)
    $end            reduce using rule 25 (sentencias -> arreglos SEMICOLON .)
    RLLAVE          reduce using rule 25 (sentencias -> arreglos SEMICOLON .)


state 21

    (26) sentencias -> control_structure SEMICOLON .

    LET             reduce using rule 26 (sentencias -> control_structure SEMICOLON .)
    PRINTLN         reduce using rule 26 (sentencias -> control_structure SEMICOLON .)
    FN              reduce using rule 26 (sentencias -> control_structure SEMICOLON .)
    STD             reduce using rule 26 (sentencias -> control_structure SEMICOLON .)
    LCORCH          reduce using rule 26 (sentencias -> control_structure SEMICOLON .)
    IF              reduce using rule 26 (sentencias -> control_structure SEMICOLON .)
    $end            reduce using rule 26 (sentencias -> control_structure SEMICOLON .)
    RLLAVE          reduce using rule 26 (sentencias -> control_structure SEMICOLON .)


state 22

    (3) asignacion -> LET IDENTIFIER . ASIG valor
    (5) asignacion -> LET IDENTIFIER . COLON asig_data_type ASIG valor

    ASIG            shift and go to state 40
    COLON           shift and go to state 41


state 23

    (4) asignacion -> LET MUT . IDENTIFIER ASIG valor
    (6) asignacion -> LET MUT . IDENTIFIER COLON asig_data_type ASIG valor

    IDENTIFIER      shift and go to state 42


state 24

    (27) impresion -> PRINTLN EXCLAMATION . LPAREN valor RPAREN
    (28) impresion -> PRINTLN EXCLAMATION . LPAREN valor COMMA valores RPAREN

    LPAREN          shift and go to state 43


state 25

    (29) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN LLLAVE sentencias RLLAVE

    LPAREN          shift and go to state 44


state 26

    (30) funcion -> FN MAIN . LPAREN parameters RPAREN LLLAVE sentencias RLLAVE

    LPAREN          shift and go to state 45


state 27

    (34) ingreso_datos -> STD DOUBLE_COLON . IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    IO              shift and go to state 46


state 28

    (60) arreglos -> LCORCH valores . RCORCH

    RCORCH          shift and go to state 47


state 29

    (61) valores -> valor .
    (62) valores -> valor . COMMA valores
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

    RCORCH          reduce using rule 61 (valores -> valor .)
    RPAREN          reduce using rule 61 (valores -> valor .)
    COMMA           shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54


state 30

    (13) valor -> INTEGER .

    COMMA           reduce using rule 13 (valor -> INTEGER .)
    PLUS            reduce using rule 13 (valor -> INTEGER .)
    MINUS           reduce using rule 13 (valor -> INTEGER .)
    TIMES           reduce using rule 13 (valor -> INTEGER .)
    DIVIDE          reduce using rule 13 (valor -> INTEGER .)
    MOD             reduce using rule 13 (valor -> INTEGER .)
    INTD            reduce using rule 13 (valor -> INTEGER .)
    RCORCH          reduce using rule 13 (valor -> INTEGER .)
    EQ              reduce using rule 13 (valor -> INTEGER .)
    NEQ             reduce using rule 13 (valor -> INTEGER .)
    GEQ             reduce using rule 13 (valor -> INTEGER .)
    LEQ             reduce using rule 13 (valor -> INTEGER .)
    RIGHTARROW      reduce using rule 13 (valor -> INTEGER .)
    LEFTARROW       reduce using rule 13 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 13 (valor -> INTEGER .)
    RPAREN          reduce using rule 13 (valor -> INTEGER .)


state 31

    (14) valor -> FLOAT .

    COMMA           reduce using rule 14 (valor -> FLOAT .)
    PLUS            reduce using rule 14 (valor -> FLOAT .)
    MINUS           reduce using rule 14 (valor -> FLOAT .)
    TIMES           reduce using rule 14 (valor -> FLOAT .)
    DIVIDE          reduce using rule 14 (valor -> FLOAT .)
    MOD             reduce using rule 14 (valor -> FLOAT .)
    INTD            reduce using rule 14 (valor -> FLOAT .)
    RCORCH          reduce using rule 14 (valor -> FLOAT .)
    EQ              reduce using rule 14 (valor -> FLOAT .)
    NEQ             reduce using rule 14 (valor -> FLOAT .)
    GEQ             reduce using rule 14 (valor -> FLOAT .)
    LEQ             reduce using rule 14 (valor -> FLOAT .)
    RIGHTARROW      reduce using rule 14 (valor -> FLOAT .)
    LEFTARROW       reduce using rule 14 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 14 (valor -> FLOAT .)
    RPAREN          reduce using rule 14 (valor -> FLOAT .)


state 32

    (15) valor -> IDENTIFIER .
    (75) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH

    COMMA           reduce using rule 15 (valor -> IDENTIFIER .)
    PLUS            reduce using rule 15 (valor -> IDENTIFIER .)
    MINUS           reduce using rule 15 (valor -> IDENTIFIER .)
    TIMES           reduce using rule 15 (valor -> IDENTIFIER .)
    DIVIDE          reduce using rule 15 (valor -> IDENTIFIER .)
    MOD             reduce using rule 15 (valor -> IDENTIFIER .)
    INTD            reduce using rule 15 (valor -> IDENTIFIER .)
    RCORCH          reduce using rule 15 (valor -> IDENTIFIER .)
    EQ              reduce using rule 15 (valor -> IDENTIFIER .)
    NEQ             reduce using rule 15 (valor -> IDENTIFIER .)
    GEQ             reduce using rule 15 (valor -> IDENTIFIER .)
    LEQ             reduce using rule 15 (valor -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 15 (valor -> IDENTIFIER .)
    LEFTARROW       reduce using rule 15 (valor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 15 (valor -> IDENTIFIER .)
    RPAREN          reduce using rule 15 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 55


state 33

    (16) valor -> operacion .

    COMMA           reduce using rule 16 (valor -> operacion .)
    PLUS            reduce using rule 16 (valor -> operacion .)
    MINUS           reduce using rule 16 (valor -> operacion .)
    TIMES           reduce using rule 16 (valor -> operacion .)
    DIVIDE          reduce using rule 16 (valor -> operacion .)
    MOD             reduce using rule 16 (valor -> operacion .)
    INTD            reduce using rule 16 (valor -> operacion .)
    RCORCH          reduce using rule 16 (valor -> operacion .)
    EQ              reduce using rule 16 (valor -> operacion .)
    NEQ             reduce using rule 16 (valor -> operacion .)
    GEQ             reduce using rule 16 (valor -> operacion .)
    LEQ             reduce using rule 16 (valor -> operacion .)
    RIGHTARROW      reduce using rule 16 (valor -> operacion .)
    LEFTARROW       reduce using rule 16 (valor -> operacion .)
    SEMICOLON       reduce using rule 16 (valor -> operacion .)
    RPAREN          reduce using rule 16 (valor -> operacion .)


state 34

    (17) valor -> indexacion .

    COMMA           reduce using rule 17 (valor -> indexacion .)
    PLUS            reduce using rule 17 (valor -> indexacion .)
    MINUS           reduce using rule 17 (valor -> indexacion .)
    TIMES           reduce using rule 17 (valor -> indexacion .)
    DIVIDE          reduce using rule 17 (valor -> indexacion .)
    MOD             reduce using rule 17 (valor -> indexacion .)
    INTD            reduce using rule 17 (valor -> indexacion .)
    RCORCH          reduce using rule 17 (valor -> indexacion .)
    EQ              reduce using rule 17 (valor -> indexacion .)
    NEQ             reduce using rule 17 (valor -> indexacion .)
    GEQ             reduce using rule 17 (valor -> indexacion .)
    LEQ             reduce using rule 17 (valor -> indexacion .)
    RIGHTARROW      reduce using rule 17 (valor -> indexacion .)
    LEFTARROW       reduce using rule 17 (valor -> indexacion .)
    SEMICOLON       reduce using rule 17 (valor -> indexacion .)
    RPAREN          reduce using rule 17 (valor -> indexacion .)


state 35

    (18) valor -> arreglos .

    COMMA           reduce using rule 18 (valor -> arreglos .)
    PLUS            reduce using rule 18 (valor -> arreglos .)
    MINUS           reduce using rule 18 (valor -> arreglos .)
    TIMES           reduce using rule 18 (valor -> arreglos .)
    DIVIDE          reduce using rule 18 (valor -> arreglos .)
    MOD             reduce using rule 18 (valor -> arreglos .)
    INTD            reduce using rule 18 (valor -> arreglos .)
    RCORCH          reduce using rule 18 (valor -> arreglos .)
    EQ              reduce using rule 18 (valor -> arreglos .)
    NEQ             reduce using rule 18 (valor -> arreglos .)
    GEQ             reduce using rule 18 (valor -> arreglos .)
    LEQ             reduce using rule 18 (valor -> arreglos .)
    RIGHTARROW      reduce using rule 18 (valor -> arreglos .)
    LEFTARROW       reduce using rule 18 (valor -> arreglos .)
    SEMICOLON       reduce using rule 18 (valor -> arreglos .)
    RPAREN          reduce using rule 18 (valor -> arreglos .)


state 36

    (19) valor -> STRING .

    COMMA           reduce using rule 19 (valor -> STRING .)
    PLUS            reduce using rule 19 (valor -> STRING .)
    MINUS           reduce using rule 19 (valor -> STRING .)
    TIMES           reduce using rule 19 (valor -> STRING .)
    DIVIDE          reduce using rule 19 (valor -> STRING .)
    MOD             reduce using rule 19 (valor -> STRING .)
    INTD            reduce using rule 19 (valor -> STRING .)
    RCORCH          reduce using rule 19 (valor -> STRING .)
    EQ              reduce using rule 19 (valor -> STRING .)
    NEQ             reduce using rule 19 (valor -> STRING .)
    GEQ             reduce using rule 19 (valor -> STRING .)
    LEQ             reduce using rule 19 (valor -> STRING .)
    RIGHTARROW      reduce using rule 19 (valor -> STRING .)
    LEFTARROW       reduce using rule 19 (valor -> STRING .)
    SEMICOLON       reduce using rule 19 (valor -> STRING .)
    RPAREN          reduce using rule 19 (valor -> STRING .)


state 37

    (67) condicional -> IF comparacion . LLLAVE programa RLLAVE
    (65) proposicion -> comparacion . conector proposicion
    (66) proposicion -> comparacion .
    (63) conector -> . AND
    (64) conector -> . OR

  ! shift/reduce conflict for LLLAVE resolved as shift
    LLLAVE          shift and go to state 56
    AND             shift and go to state 58
    OR              shift and go to state 59

  ! LLLAVE          [ reduce using rule 66 (proposicion -> comparacion .) ]

    conector                       shift and go to state 57

state 38

    (68) condicional -> IF proposicion . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 60


state 39

    (7) comparacion -> valor . EQ IDENTIFIER
    (8) comparacion -> valor . NEQ IDENTIFIER
    (9) comparacion -> valor . GEQ IDENTIFIER
    (10) comparacion -> valor . LEQ IDENTIFIER
    (11) comparacion -> valor . RIGHTARROW IDENTIFIER
    (12) comparacion -> valor . LEFTARROW IDENTIFIER
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

    EQ              shift and go to state 61
    NEQ             shift and go to state 62
    GEQ             shift and go to state 63
    LEQ             shift and go to state 64
    RIGHTARROW      shift and go to state 65
    LEFTARROW       shift and go to state 66
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54


state 40

    (3) asignacion -> LET IDENTIFIER ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 67
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 41

    (5) asignacion -> LET IDENTIFIER COLON . asig_data_type ASIG valor
    (35) asig_data_type -> . data_type
    (36) asig_data_type -> . LPAREN some_data_type RPAREN
    (37) asig_data_type -> . LCORCH some_data_type RCORCH
    (38) data_type -> . CHAR
    (39) data_type -> . signed_integer
    (40) data_type -> . unsigned_integer
    (41) data_type -> . float_type
    (42) data_type -> . BOOL
    (43) signed_integer -> . I8
    (44) signed_integer -> . I16
    (45) signed_integer -> . I32
    (46) signed_integer -> . I64
    (47) signed_integer -> . I128
    (48) signed_integer -> . ISIZE
    (49) unsigned_integer -> . U8
    (50) unsigned_integer -> . U16
    (51) unsigned_integer -> . U32
    (52) unsigned_integer -> . U64
    (53) unsigned_integer -> . U128
    (54) unsigned_integer -> . USIZE
    (55) float_type -> . F32
    (56) float_type -> . F64

    LPAREN          shift and go to state 70
    LCORCH          shift and go to state 71
    CHAR            shift and go to state 72
    BOOL            shift and go to state 76
    I8              shift and go to state 77
    I16             shift and go to state 78
    I32             shift and go to state 79
    I64             shift and go to state 80
    I128            shift and go to state 81
    ISIZE           shift and go to state 82
    U8              shift and go to state 83
    U16             shift and go to state 84
    U32             shift and go to state 85
    U64             shift and go to state 86
    U128            shift and go to state 87
    USIZE           shift and go to state 88
    F32             shift and go to state 89
    F64             shift and go to state 90

    asig_data_type                 shift and go to state 68
    data_type                      shift and go to state 69
    signed_integer                 shift and go to state 73
    unsigned_integer               shift and go to state 74
    float_type                     shift and go to state 75

state 42

    (4) asignacion -> LET MUT IDENTIFIER . ASIG valor
    (6) asignacion -> LET MUT IDENTIFIER . COLON asig_data_type ASIG valor

    ASIG            shift and go to state 91
    COLON           shift and go to state 92


state 43

    (27) impresion -> PRINTLN EXCLAMATION LPAREN . valor RPAREN
    (28) impresion -> PRINTLN EXCLAMATION LPAREN . valor COMMA valores RPAREN
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 93
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 44

    (29) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN LLLAVE sentencias RLLAVE
    (31) parameters -> . IDENTIFIER COLON asig_data_type
    (32) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (33) parameters -> . vacio
    (20) vacio -> .

    IDENTIFIER      shift and go to state 94
    RPAREN          reduce using rule 20 (vacio -> .)

    parameters                     shift and go to state 95
    vacio                          shift and go to state 96

state 45

    (30) funcion -> FN MAIN LPAREN . parameters RPAREN LLLAVE sentencias RLLAVE
    (31) parameters -> . IDENTIFIER COLON asig_data_type
    (32) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (33) parameters -> . vacio
    (20) vacio -> .

    IDENTIFIER      shift and go to state 94
    RPAREN          reduce using rule 20 (vacio -> .)

    parameters                     shift and go to state 97
    vacio                          shift and go to state 96

state 46

    (34) ingreso_datos -> STD DOUBLE_COLON IO . DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 98


state 47

    (60) arreglos -> LCORCH valores RCORCH .

    SEMICOLON       reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    COMMA           reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    PLUS            reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    MINUS           reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    TIMES           reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    DIVIDE          reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    MOD             reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    INTD            reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    RCORCH          reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    EQ              reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    NEQ             reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    GEQ             reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    LEQ             reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    RIGHTARROW      reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    LEFTARROW       reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)
    RPAREN          reduce using rule 60 (arreglos -> LCORCH valores RCORCH .)


state 48

    (62) valores -> valor COMMA . valores
    (61) valores -> . valor
    (62) valores -> . valor COMMA valores
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 29
    valores                        shift and go to state 99
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 49

    (69) operacion -> valor PLUS . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 100
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 50

    (70) operacion -> valor MINUS . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 101
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 51

    (71) operacion -> valor TIMES . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 102
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 52

    (72) operacion -> valor DIVIDE . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 103
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 53

    (73) operacion -> valor MOD . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 104
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 54

    (74) operacion -> valor INTD . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 105
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 55

    (75) indexacion -> IDENTIFIER LCORCH . INTEGER RCORCH

    INTEGER         shift and go to state 106


state 56

    (67) condicional -> IF comparacion LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (21) sentencias -> . asignacion SEMICOLON
    (22) sentencias -> . impresion SEMICOLON
    (23) sentencias -> . funcion
    (24) sentencias -> . ingreso_datos SEMICOLON
    (25) sentencias -> . arreglos SEMICOLON
    (26) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (27) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (28) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (29) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (30) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (34) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (60) arreglos -> . LCORCH valores RCORCH
    (59) control_structure -> . condicional
    (67) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (68) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    programa                       shift and go to state 107
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 57

    (65) proposicion -> comparacion conector . proposicion
    (65) proposicion -> . comparacion conector proposicion
    (66) proposicion -> . comparacion
    (7) comparacion -> . valor EQ IDENTIFIER
    (8) comparacion -> . valor NEQ IDENTIFIER
    (9) comparacion -> . valor GEQ IDENTIFIER
    (10) comparacion -> . valor LEQ IDENTIFIER
    (11) comparacion -> . valor RIGHTARROW IDENTIFIER
    (12) comparacion -> . valor LEFTARROW IDENTIFIER
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    comparacion                    shift and go to state 108
    proposicion                    shift and go to state 109
    valor                          shift and go to state 39
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 58

    (63) conector -> AND .

    INTEGER         reduce using rule 63 (conector -> AND .)
    FLOAT           reduce using rule 63 (conector -> AND .)
    IDENTIFIER      reduce using rule 63 (conector -> AND .)
    STRING          reduce using rule 63 (conector -> AND .)
    LCORCH          reduce using rule 63 (conector -> AND .)


state 59

    (64) conector -> OR .

    INTEGER         reduce using rule 64 (conector -> OR .)
    FLOAT           reduce using rule 64 (conector -> OR .)
    IDENTIFIER      reduce using rule 64 (conector -> OR .)
    STRING          reduce using rule 64 (conector -> OR .)
    LCORCH          reduce using rule 64 (conector -> OR .)


state 60

    (68) condicional -> IF proposicion LLLAVE . programa RLLAVE
    (1) programa -> . sentencias
    (2) programa -> . sentencias programa
    (21) sentencias -> . asignacion SEMICOLON
    (22) sentencias -> . impresion SEMICOLON
    (23) sentencias -> . funcion
    (24) sentencias -> . ingreso_datos SEMICOLON
    (25) sentencias -> . arreglos SEMICOLON
    (26) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (27) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (28) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (29) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (30) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (34) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (60) arreglos -> . LCORCH valores RCORCH
    (59) control_structure -> . condicional
    (67) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (68) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    programa                       shift and go to state 110
    sentencias                     shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 61

    (7) comparacion -> valor EQ . IDENTIFIER

    IDENTIFIER      shift and go to state 111


state 62

    (8) comparacion -> valor NEQ . IDENTIFIER

    IDENTIFIER      shift and go to state 112


state 63

    (9) comparacion -> valor GEQ . IDENTIFIER

    IDENTIFIER      shift and go to state 113


state 64

    (10) comparacion -> valor LEQ . IDENTIFIER

    IDENTIFIER      shift and go to state 114


state 65

    (11) comparacion -> valor RIGHTARROW . IDENTIFIER

    IDENTIFIER      shift and go to state 115


state 66

    (12) comparacion -> valor LEFTARROW . IDENTIFIER

    IDENTIFIER      shift and go to state 116


state 67

    (3) asignacion -> LET IDENTIFIER ASIG valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 3 (asignacion -> LET IDENTIFIER ASIG valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54


state 68

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type . ASIG valor

    ASIG            shift and go to state 117


state 69

    (35) asig_data_type -> data_type .

    ASIG            reduce using rule 35 (asig_data_type -> data_type .)
    COMMA           reduce using rule 35 (asig_data_type -> data_type .)
    RPAREN          reduce using rule 35 (asig_data_type -> data_type .)


state 70

    (36) asig_data_type -> LPAREN . some_data_type RPAREN
    (57) some_data_type -> . data_type
    (58) some_data_type -> . data_type COMMA some_data_type
    (38) data_type -> . CHAR
    (39) data_type -> . signed_integer
    (40) data_type -> . unsigned_integer
    (41) data_type -> . float_type
    (42) data_type -> . BOOL
    (43) signed_integer -> . I8
    (44) signed_integer -> . I16
    (45) signed_integer -> . I32
    (46) signed_integer -> . I64
    (47) signed_integer -> . I128
    (48) signed_integer -> . ISIZE
    (49) unsigned_integer -> . U8
    (50) unsigned_integer -> . U16
    (51) unsigned_integer -> . U32
    (52) unsigned_integer -> . U64
    (53) unsigned_integer -> . U128
    (54) unsigned_integer -> . USIZE
    (55) float_type -> . F32
    (56) float_type -> . F64

    CHAR            shift and go to state 72
    BOOL            shift and go to state 76
    I8              shift and go to state 77
    I16             shift and go to state 78
    I32             shift and go to state 79
    I64             shift and go to state 80
    I128            shift and go to state 81
    ISIZE           shift and go to state 82
    U8              shift and go to state 83
    U16             shift and go to state 84
    U32             shift and go to state 85
    U64             shift and go to state 86
    U128            shift and go to state 87
    USIZE           shift and go to state 88
    F32             shift and go to state 89
    F64             shift and go to state 90

    some_data_type                 shift and go to state 118
    data_type                      shift and go to state 119
    signed_integer                 shift and go to state 73
    unsigned_integer               shift and go to state 74
    float_type                     shift and go to state 75

state 71

    (37) asig_data_type -> LCORCH . some_data_type RCORCH
    (57) some_data_type -> . data_type
    (58) some_data_type -> . data_type COMMA some_data_type
    (38) data_type -> . CHAR
    (39) data_type -> . signed_integer
    (40) data_type -> . unsigned_integer
    (41) data_type -> . float_type
    (42) data_type -> . BOOL
    (43) signed_integer -> . I8
    (44) signed_integer -> . I16
    (45) signed_integer -> . I32
    (46) signed_integer -> . I64
    (47) signed_integer -> . I128
    (48) signed_integer -> . ISIZE
    (49) unsigned_integer -> . U8
    (50) unsigned_integer -> . U16
    (51) unsigned_integer -> . U32
    (52) unsigned_integer -> . U64
    (53) unsigned_integer -> . U128
    (54) unsigned_integer -> . USIZE
    (55) float_type -> . F32
    (56) float_type -> . F64

    CHAR            shift and go to state 72
    BOOL            shift and go to state 76
    I8              shift and go to state 77
    I16             shift and go to state 78
    I32             shift and go to state 79
    I64             shift and go to state 80
    I128            shift and go to state 81
    ISIZE           shift and go to state 82
    U8              shift and go to state 83
    U16             shift and go to state 84
    U32             shift and go to state 85
    U64             shift and go to state 86
    U128            shift and go to state 87
    USIZE           shift and go to state 88
    F32             shift and go to state 89
    F64             shift and go to state 90

    some_data_type                 shift and go to state 120
    data_type                      shift and go to state 119
    signed_integer                 shift and go to state 73
    unsigned_integer               shift and go to state 74
    float_type                     shift and go to state 75

state 72

    (38) data_type -> CHAR .

    ASIG            reduce using rule 38 (data_type -> CHAR .)
    COMMA           reduce using rule 38 (data_type -> CHAR .)
    RPAREN          reduce using rule 38 (data_type -> CHAR .)
    RCORCH          reduce using rule 38 (data_type -> CHAR .)


state 73

    (39) data_type -> signed_integer .

    ASIG            reduce using rule 39 (data_type -> signed_integer .)
    COMMA           reduce using rule 39 (data_type -> signed_integer .)
    RPAREN          reduce using rule 39 (data_type -> signed_integer .)
    RCORCH          reduce using rule 39 (data_type -> signed_integer .)


state 74

    (40) data_type -> unsigned_integer .

    ASIG            reduce using rule 40 (data_type -> unsigned_integer .)
    COMMA           reduce using rule 40 (data_type -> unsigned_integer .)
    RPAREN          reduce using rule 40 (data_type -> unsigned_integer .)
    RCORCH          reduce using rule 40 (data_type -> unsigned_integer .)


state 75

    (41) data_type -> float_type .

    ASIG            reduce using rule 41 (data_type -> float_type .)
    COMMA           reduce using rule 41 (data_type -> float_type .)
    RPAREN          reduce using rule 41 (data_type -> float_type .)
    RCORCH          reduce using rule 41 (data_type -> float_type .)


state 76

    (42) data_type -> BOOL .

    ASIG            reduce using rule 42 (data_type -> BOOL .)
    COMMA           reduce using rule 42 (data_type -> BOOL .)
    RPAREN          reduce using rule 42 (data_type -> BOOL .)
    RCORCH          reduce using rule 42 (data_type -> BOOL .)


state 77

    (43) signed_integer -> I8 .

    ASIG            reduce using rule 43 (signed_integer -> I8 .)
    COMMA           reduce using rule 43 (signed_integer -> I8 .)
    RPAREN          reduce using rule 43 (signed_integer -> I8 .)
    RCORCH          reduce using rule 43 (signed_integer -> I8 .)


state 78

    (44) signed_integer -> I16 .

    ASIG            reduce using rule 44 (signed_integer -> I16 .)
    COMMA           reduce using rule 44 (signed_integer -> I16 .)
    RPAREN          reduce using rule 44 (signed_integer -> I16 .)
    RCORCH          reduce using rule 44 (signed_integer -> I16 .)


state 79

    (45) signed_integer -> I32 .

    ASIG            reduce using rule 45 (signed_integer -> I32 .)
    COMMA           reduce using rule 45 (signed_integer -> I32 .)
    RPAREN          reduce using rule 45 (signed_integer -> I32 .)
    RCORCH          reduce using rule 45 (signed_integer -> I32 .)


state 80

    (46) signed_integer -> I64 .

    ASIG            reduce using rule 46 (signed_integer -> I64 .)
    COMMA           reduce using rule 46 (signed_integer -> I64 .)
    RPAREN          reduce using rule 46 (signed_integer -> I64 .)
    RCORCH          reduce using rule 46 (signed_integer -> I64 .)


state 81

    (47) signed_integer -> I128 .

    ASIG            reduce using rule 47 (signed_integer -> I128 .)
    COMMA           reduce using rule 47 (signed_integer -> I128 .)
    RPAREN          reduce using rule 47 (signed_integer -> I128 .)
    RCORCH          reduce using rule 47 (signed_integer -> I128 .)


state 82

    (48) signed_integer -> ISIZE .

    ASIG            reduce using rule 48 (signed_integer -> ISIZE .)
    COMMA           reduce using rule 48 (signed_integer -> ISIZE .)
    RPAREN          reduce using rule 48 (signed_integer -> ISIZE .)
    RCORCH          reduce using rule 48 (signed_integer -> ISIZE .)


state 83

    (49) unsigned_integer -> U8 .

    ASIG            reduce using rule 49 (unsigned_integer -> U8 .)
    COMMA           reduce using rule 49 (unsigned_integer -> U8 .)
    RPAREN          reduce using rule 49 (unsigned_integer -> U8 .)
    RCORCH          reduce using rule 49 (unsigned_integer -> U8 .)


state 84

    (50) unsigned_integer -> U16 .

    ASIG            reduce using rule 50 (unsigned_integer -> U16 .)
    COMMA           reduce using rule 50 (unsigned_integer -> U16 .)
    RPAREN          reduce using rule 50 (unsigned_integer -> U16 .)
    RCORCH          reduce using rule 50 (unsigned_integer -> U16 .)


state 85

    (51) unsigned_integer -> U32 .

    ASIG            reduce using rule 51 (unsigned_integer -> U32 .)
    COMMA           reduce using rule 51 (unsigned_integer -> U32 .)
    RPAREN          reduce using rule 51 (unsigned_integer -> U32 .)
    RCORCH          reduce using rule 51 (unsigned_integer -> U32 .)


state 86

    (52) unsigned_integer -> U64 .

    ASIG            reduce using rule 52 (unsigned_integer -> U64 .)
    COMMA           reduce using rule 52 (unsigned_integer -> U64 .)
    RPAREN          reduce using rule 52 (unsigned_integer -> U64 .)
    RCORCH          reduce using rule 52 (unsigned_integer -> U64 .)


state 87

    (53) unsigned_integer -> U128 .

    ASIG            reduce using rule 53 (unsigned_integer -> U128 .)
    COMMA           reduce using rule 53 (unsigned_integer -> U128 .)
    RPAREN          reduce using rule 53 (unsigned_integer -> U128 .)
    RCORCH          reduce using rule 53 (unsigned_integer -> U128 .)


state 88

    (54) unsigned_integer -> USIZE .

    ASIG            reduce using rule 54 (unsigned_integer -> USIZE .)
    COMMA           reduce using rule 54 (unsigned_integer -> USIZE .)
    RPAREN          reduce using rule 54 (unsigned_integer -> USIZE .)
    RCORCH          reduce using rule 54 (unsigned_integer -> USIZE .)


state 89

    (55) float_type -> F32 .

    ASIG            reduce using rule 55 (float_type -> F32 .)
    COMMA           reduce using rule 55 (float_type -> F32 .)
    RPAREN          reduce using rule 55 (float_type -> F32 .)
    RCORCH          reduce using rule 55 (float_type -> F32 .)


state 90

    (56) float_type -> F64 .

    ASIG            reduce using rule 56 (float_type -> F64 .)
    COMMA           reduce using rule 56 (float_type -> F64 .)
    RPAREN          reduce using rule 56 (float_type -> F64 .)
    RCORCH          reduce using rule 56 (float_type -> F64 .)


state 91

    (4) asignacion -> LET MUT IDENTIFIER ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 121
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 92

    (6) asignacion -> LET MUT IDENTIFIER COLON . asig_data_type ASIG valor
    (35) asig_data_type -> . data_type
    (36) asig_data_type -> . LPAREN some_data_type RPAREN
    (37) asig_data_type -> . LCORCH some_data_type RCORCH
    (38) data_type -> . CHAR
    (39) data_type -> . signed_integer
    (40) data_type -> . unsigned_integer
    (41) data_type -> . float_type
    (42) data_type -> . BOOL
    (43) signed_integer -> . I8
    (44) signed_integer -> . I16
    (45) signed_integer -> . I32
    (46) signed_integer -> . I64
    (47) signed_integer -> . I128
    (48) signed_integer -> . ISIZE
    (49) unsigned_integer -> . U8
    (50) unsigned_integer -> . U16
    (51) unsigned_integer -> . U32
    (52) unsigned_integer -> . U64
    (53) unsigned_integer -> . U128
    (54) unsigned_integer -> . USIZE
    (55) float_type -> . F32
    (56) float_type -> . F64

    LPAREN          shift and go to state 70
    LCORCH          shift and go to state 71
    CHAR            shift and go to state 72
    BOOL            shift and go to state 76
    I8              shift and go to state 77
    I16             shift and go to state 78
    I32             shift and go to state 79
    I64             shift and go to state 80
    I128            shift and go to state 81
    ISIZE           shift and go to state 82
    U8              shift and go to state 83
    U16             shift and go to state 84
    U32             shift and go to state 85
    U64             shift and go to state 86
    U128            shift and go to state 87
    USIZE           shift and go to state 88
    F32             shift and go to state 89
    F64             shift and go to state 90

    asig_data_type                 shift and go to state 122
    data_type                      shift and go to state 69
    signed_integer                 shift and go to state 73
    unsigned_integer               shift and go to state 74
    float_type                     shift and go to state 75

state 93

    (27) impresion -> PRINTLN EXCLAMATION LPAREN valor . RPAREN
    (28) impresion -> PRINTLN EXCLAMATION LPAREN valor . COMMA valores RPAREN
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

    RPAREN          shift and go to state 123
    COMMA           shift and go to state 124
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54


state 94

    (31) parameters -> IDENTIFIER . COLON asig_data_type
    (32) parameters -> IDENTIFIER . COLON asig_data_type COMMA parameters

    COLON           shift and go to state 125


state 95

    (29) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN LLLAVE sentencias RLLAVE

    RPAREN          shift and go to state 126


state 96

    (33) parameters -> vacio .

    RPAREN          reduce using rule 33 (parameters -> vacio .)


state 97

    (30) funcion -> FN MAIN LPAREN parameters . RPAREN LLLAVE sentencias RLLAVE

    RPAREN          shift and go to state 127


state 98

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON . DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 128


state 99

    (62) valores -> valor COMMA valores .

    RCORCH          reduce using rule 62 (valores -> valor COMMA valores .)
    RPAREN          reduce using rule 62 (valores -> valor COMMA valores .)


state 100

    (69) operacion -> valor PLUS valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 69 (operacion -> valor PLUS valor .)
    RCORCH          reduce using rule 69 (operacion -> valor PLUS valor .)
    EQ              reduce using rule 69 (operacion -> valor PLUS valor .)
    NEQ             reduce using rule 69 (operacion -> valor PLUS valor .)
    GEQ             reduce using rule 69 (operacion -> valor PLUS valor .)
    LEQ             reduce using rule 69 (operacion -> valor PLUS valor .)
    RIGHTARROW      reduce using rule 69 (operacion -> valor PLUS valor .)
    LEFTARROW       reduce using rule 69 (operacion -> valor PLUS valor .)
    SEMICOLON       reduce using rule 69 (operacion -> valor PLUS valor .)
    RPAREN          reduce using rule 69 (operacion -> valor PLUS valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54

  ! PLUS            [ reduce using rule 69 (operacion -> valor PLUS valor .) ]
  ! MINUS           [ reduce using rule 69 (operacion -> valor PLUS valor .) ]
  ! TIMES           [ reduce using rule 69 (operacion -> valor PLUS valor .) ]
  ! DIVIDE          [ reduce using rule 69 (operacion -> valor PLUS valor .) ]
  ! MOD             [ reduce using rule 69 (operacion -> valor PLUS valor .) ]
  ! INTD            [ reduce using rule 69 (operacion -> valor PLUS valor .) ]


state 101

    (70) operacion -> valor MINUS valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 70 (operacion -> valor MINUS valor .)
    RCORCH          reduce using rule 70 (operacion -> valor MINUS valor .)
    EQ              reduce using rule 70 (operacion -> valor MINUS valor .)
    NEQ             reduce using rule 70 (operacion -> valor MINUS valor .)
    GEQ             reduce using rule 70 (operacion -> valor MINUS valor .)
    LEQ             reduce using rule 70 (operacion -> valor MINUS valor .)
    RIGHTARROW      reduce using rule 70 (operacion -> valor MINUS valor .)
    LEFTARROW       reduce using rule 70 (operacion -> valor MINUS valor .)
    SEMICOLON       reduce using rule 70 (operacion -> valor MINUS valor .)
    RPAREN          reduce using rule 70 (operacion -> valor MINUS valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54

  ! PLUS            [ reduce using rule 70 (operacion -> valor MINUS valor .) ]
  ! MINUS           [ reduce using rule 70 (operacion -> valor MINUS valor .) ]
  ! TIMES           [ reduce using rule 70 (operacion -> valor MINUS valor .) ]
  ! DIVIDE          [ reduce using rule 70 (operacion -> valor MINUS valor .) ]
  ! MOD             [ reduce using rule 70 (operacion -> valor MINUS valor .) ]
  ! INTD            [ reduce using rule 70 (operacion -> valor MINUS valor .) ]


state 102

    (71) operacion -> valor TIMES valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 71 (operacion -> valor TIMES valor .)
    RCORCH          reduce using rule 71 (operacion -> valor TIMES valor .)
    EQ              reduce using rule 71 (operacion -> valor TIMES valor .)
    NEQ             reduce using rule 71 (operacion -> valor TIMES valor .)
    GEQ             reduce using rule 71 (operacion -> valor TIMES valor .)
    LEQ             reduce using rule 71 (operacion -> valor TIMES valor .)
    RIGHTARROW      reduce using rule 71 (operacion -> valor TIMES valor .)
    LEFTARROW       reduce using rule 71 (operacion -> valor TIMES valor .)
    SEMICOLON       reduce using rule 71 (operacion -> valor TIMES valor .)
    RPAREN          reduce using rule 71 (operacion -> valor TIMES valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54

  ! PLUS            [ reduce using rule 71 (operacion -> valor TIMES valor .) ]
  ! MINUS           [ reduce using rule 71 (operacion -> valor TIMES valor .) ]
  ! TIMES           [ reduce using rule 71 (operacion -> valor TIMES valor .) ]
  ! DIVIDE          [ reduce using rule 71 (operacion -> valor TIMES valor .) ]
  ! MOD             [ reduce using rule 71 (operacion -> valor TIMES valor .) ]
  ! INTD            [ reduce using rule 71 (operacion -> valor TIMES valor .) ]


state 103

    (72) operacion -> valor DIVIDE valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 72 (operacion -> valor DIVIDE valor .)
    RCORCH          reduce using rule 72 (operacion -> valor DIVIDE valor .)
    EQ              reduce using rule 72 (operacion -> valor DIVIDE valor .)
    NEQ             reduce using rule 72 (operacion -> valor DIVIDE valor .)
    GEQ             reduce using rule 72 (operacion -> valor DIVIDE valor .)
    LEQ             reduce using rule 72 (operacion -> valor DIVIDE valor .)
    RIGHTARROW      reduce using rule 72 (operacion -> valor DIVIDE valor .)
    LEFTARROW       reduce using rule 72 (operacion -> valor DIVIDE valor .)
    SEMICOLON       reduce using rule 72 (operacion -> valor DIVIDE valor .)
    RPAREN          reduce using rule 72 (operacion -> valor DIVIDE valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54

  ! PLUS            [ reduce using rule 72 (operacion -> valor DIVIDE valor .) ]
  ! MINUS           [ reduce using rule 72 (operacion -> valor DIVIDE valor .) ]
  ! TIMES           [ reduce using rule 72 (operacion -> valor DIVIDE valor .) ]
  ! DIVIDE          [ reduce using rule 72 (operacion -> valor DIVIDE valor .) ]
  ! MOD             [ reduce using rule 72 (operacion -> valor DIVIDE valor .) ]
  ! INTD            [ reduce using rule 72 (operacion -> valor DIVIDE valor .) ]


state 104

    (73) operacion -> valor MOD valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 73 (operacion -> valor MOD valor .)
    RCORCH          reduce using rule 73 (operacion -> valor MOD valor .)
    EQ              reduce using rule 73 (operacion -> valor MOD valor .)
    NEQ             reduce using rule 73 (operacion -> valor MOD valor .)
    GEQ             reduce using rule 73 (operacion -> valor MOD valor .)
    LEQ             reduce using rule 73 (operacion -> valor MOD valor .)
    RIGHTARROW      reduce using rule 73 (operacion -> valor MOD valor .)
    LEFTARROW       reduce using rule 73 (operacion -> valor MOD valor .)
    SEMICOLON       reduce using rule 73 (operacion -> valor MOD valor .)
    RPAREN          reduce using rule 73 (operacion -> valor MOD valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54

  ! PLUS            [ reduce using rule 73 (operacion -> valor MOD valor .) ]
  ! MINUS           [ reduce using rule 73 (operacion -> valor MOD valor .) ]
  ! TIMES           [ reduce using rule 73 (operacion -> valor MOD valor .) ]
  ! DIVIDE          [ reduce using rule 73 (operacion -> valor MOD valor .) ]
  ! MOD             [ reduce using rule 73 (operacion -> valor MOD valor .) ]
  ! INTD            [ reduce using rule 73 (operacion -> valor MOD valor .) ]


state 105

    (74) operacion -> valor INTD valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INTD resolved as shift
    COMMA           reduce using rule 74 (operacion -> valor INTD valor .)
    RCORCH          reduce using rule 74 (operacion -> valor INTD valor .)
    EQ              reduce using rule 74 (operacion -> valor INTD valor .)
    NEQ             reduce using rule 74 (operacion -> valor INTD valor .)
    GEQ             reduce using rule 74 (operacion -> valor INTD valor .)
    LEQ             reduce using rule 74 (operacion -> valor INTD valor .)
    RIGHTARROW      reduce using rule 74 (operacion -> valor INTD valor .)
    LEFTARROW       reduce using rule 74 (operacion -> valor INTD valor .)
    SEMICOLON       reduce using rule 74 (operacion -> valor INTD valor .)
    RPAREN          reduce using rule 74 (operacion -> valor INTD valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54

  ! PLUS            [ reduce using rule 74 (operacion -> valor INTD valor .) ]
  ! MINUS           [ reduce using rule 74 (operacion -> valor INTD valor .) ]
  ! TIMES           [ reduce using rule 74 (operacion -> valor INTD valor .) ]
  ! DIVIDE          [ reduce using rule 74 (operacion -> valor INTD valor .) ]
  ! MOD             [ reduce using rule 74 (operacion -> valor INTD valor .) ]
  ! INTD            [ reduce using rule 74 (operacion -> valor INTD valor .) ]


state 106

    (75) indexacion -> IDENTIFIER LCORCH INTEGER . RCORCH

    RCORCH          shift and go to state 129


state 107

    (67) condicional -> IF comparacion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 130


state 108

    (65) proposicion -> comparacion . conector proposicion
    (66) proposicion -> comparacion .
    (63) conector -> . AND
    (64) conector -> . OR

    LLLAVE          reduce using rule 66 (proposicion -> comparacion .)
    AND             shift and go to state 58
    OR              shift and go to state 59

    conector                       shift and go to state 57

state 109

    (65) proposicion -> comparacion conector proposicion .

    LLLAVE          reduce using rule 65 (proposicion -> comparacion conector proposicion .)


state 110

    (68) condicional -> IF proposicion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 131


state 111

    (7) comparacion -> valor EQ IDENTIFIER .

    LLLAVE          reduce using rule 7 (comparacion -> valor EQ IDENTIFIER .)
    AND             reduce using rule 7 (comparacion -> valor EQ IDENTIFIER .)
    OR              reduce using rule 7 (comparacion -> valor EQ IDENTIFIER .)


state 112

    (8) comparacion -> valor NEQ IDENTIFIER .

    LLLAVE          reduce using rule 8 (comparacion -> valor NEQ IDENTIFIER .)
    AND             reduce using rule 8 (comparacion -> valor NEQ IDENTIFIER .)
    OR              reduce using rule 8 (comparacion -> valor NEQ IDENTIFIER .)


state 113

    (9) comparacion -> valor GEQ IDENTIFIER .

    LLLAVE          reduce using rule 9 (comparacion -> valor GEQ IDENTIFIER .)
    AND             reduce using rule 9 (comparacion -> valor GEQ IDENTIFIER .)
    OR              reduce using rule 9 (comparacion -> valor GEQ IDENTIFIER .)


state 114

    (10) comparacion -> valor LEQ IDENTIFIER .

    LLLAVE          reduce using rule 10 (comparacion -> valor LEQ IDENTIFIER .)
    AND             reduce using rule 10 (comparacion -> valor LEQ IDENTIFIER .)
    OR              reduce using rule 10 (comparacion -> valor LEQ IDENTIFIER .)


state 115

    (11) comparacion -> valor RIGHTARROW IDENTIFIER .

    LLLAVE          reduce using rule 11 (comparacion -> valor RIGHTARROW IDENTIFIER .)
    AND             reduce using rule 11 (comparacion -> valor RIGHTARROW IDENTIFIER .)
    OR              reduce using rule 11 (comparacion -> valor RIGHTARROW IDENTIFIER .)


state 116

    (12) comparacion -> valor LEFTARROW IDENTIFIER .

    LLLAVE          reduce using rule 12 (comparacion -> valor LEFTARROW IDENTIFIER .)
    AND             reduce using rule 12 (comparacion -> valor LEFTARROW IDENTIFIER .)
    OR              reduce using rule 12 (comparacion -> valor LEFTARROW IDENTIFIER .)


state 117

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 132
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 118

    (36) asig_data_type -> LPAREN some_data_type . RPAREN

    RPAREN          shift and go to state 133


state 119

    (57) some_data_type -> data_type .
    (58) some_data_type -> data_type . COMMA some_data_type

    RPAREN          reduce using rule 57 (some_data_type -> data_type .)
    RCORCH          reduce using rule 57 (some_data_type -> data_type .)
    COMMA           shift and go to state 134


state 120

    (37) asig_data_type -> LCORCH some_data_type . RCORCH

    RCORCH          shift and go to state 135


state 121

    (4) asignacion -> LET MUT IDENTIFIER ASIG valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 4 (asignacion -> LET MUT IDENTIFIER ASIG valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54


state 122

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type . ASIG valor

    ASIG            shift and go to state 136


state 123

    (27) impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 27 (impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .)


state 124

    (28) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA . valores RPAREN
    (61) valores -> . valor
    (62) valores -> . valor COMMA valores
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 29
    valores                        shift and go to state 137
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 125

    (31) parameters -> IDENTIFIER COLON . asig_data_type
    (32) parameters -> IDENTIFIER COLON . asig_data_type COMMA parameters
    (35) asig_data_type -> . data_type
    (36) asig_data_type -> . LPAREN some_data_type RPAREN
    (37) asig_data_type -> . LCORCH some_data_type RCORCH
    (38) data_type -> . CHAR
    (39) data_type -> . signed_integer
    (40) data_type -> . unsigned_integer
    (41) data_type -> . float_type
    (42) data_type -> . BOOL
    (43) signed_integer -> . I8
    (44) signed_integer -> . I16
    (45) signed_integer -> . I32
    (46) signed_integer -> . I64
    (47) signed_integer -> . I128
    (48) signed_integer -> . ISIZE
    (49) unsigned_integer -> . U8
    (50) unsigned_integer -> . U16
    (51) unsigned_integer -> . U32
    (52) unsigned_integer -> . U64
    (53) unsigned_integer -> . U128
    (54) unsigned_integer -> . USIZE
    (55) float_type -> . F32
    (56) float_type -> . F64

    LPAREN          shift and go to state 70
    LCORCH          shift and go to state 71
    CHAR            shift and go to state 72
    BOOL            shift and go to state 76
    I8              shift and go to state 77
    I16             shift and go to state 78
    I32             shift and go to state 79
    I64             shift and go to state 80
    I128            shift and go to state 81
    ISIZE           shift and go to state 82
    U8              shift and go to state 83
    U16             shift and go to state 84
    U32             shift and go to state 85
    U64             shift and go to state 86
    U128            shift and go to state 87
    USIZE           shift and go to state 88
    F32             shift and go to state 89
    F64             shift and go to state 90

    asig_data_type                 shift and go to state 138
    data_type                      shift and go to state 69
    signed_integer                 shift and go to state 73
    unsigned_integer               shift and go to state 74
    float_type                     shift and go to state 75

state 126

    (29) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . LLLAVE sentencias RLLAVE

    LLLAVE          shift and go to state 139


state 127

    (30) funcion -> FN MAIN LPAREN parameters RPAREN . LLLAVE sentencias RLLAVE

    LLLAVE          shift and go to state 140


state 128

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT . STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    STDIN           shift and go to state 141


state 129

    (75) indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .

    COMMA           reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    PLUS            reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    MINUS           reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    TIMES           reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    DIVIDE          reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    MOD             reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    INTD            reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RCORCH          reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    EQ              reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    NEQ             reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    GEQ             reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEQ             reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RIGHTARROW      reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEFTARROW       reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    SEMICOLON       reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RPAREN          reduce using rule 75 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)


state 130

    (67) condicional -> IF comparacion LLLAVE programa RLLAVE .

    SEMICOLON       reduce using rule 67 (condicional -> IF comparacion LLLAVE programa RLLAVE .)


state 131

    (68) condicional -> IF proposicion LLLAVE programa RLLAVE .

    SEMICOLON       reduce using rule 68 (condicional -> IF proposicion LLLAVE programa RLLAVE .)


state 132

    (5) asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 5 (asignacion -> LET IDENTIFIER COLON asig_data_type ASIG valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54


state 133

    (36) asig_data_type -> LPAREN some_data_type RPAREN .

    ASIG            reduce using rule 36 (asig_data_type -> LPAREN some_data_type RPAREN .)
    COMMA           reduce using rule 36 (asig_data_type -> LPAREN some_data_type RPAREN .)
    RPAREN          reduce using rule 36 (asig_data_type -> LPAREN some_data_type RPAREN .)


state 134

    (58) some_data_type -> data_type COMMA . some_data_type
    (57) some_data_type -> . data_type
    (58) some_data_type -> . data_type COMMA some_data_type
    (38) data_type -> . CHAR
    (39) data_type -> . signed_integer
    (40) data_type -> . unsigned_integer
    (41) data_type -> . float_type
    (42) data_type -> . BOOL
    (43) signed_integer -> . I8
    (44) signed_integer -> . I16
    (45) signed_integer -> . I32
    (46) signed_integer -> . I64
    (47) signed_integer -> . I128
    (48) signed_integer -> . ISIZE
    (49) unsigned_integer -> . U8
    (50) unsigned_integer -> . U16
    (51) unsigned_integer -> . U32
    (52) unsigned_integer -> . U64
    (53) unsigned_integer -> . U128
    (54) unsigned_integer -> . USIZE
    (55) float_type -> . F32
    (56) float_type -> . F64

    CHAR            shift and go to state 72
    BOOL            shift and go to state 76
    I8              shift and go to state 77
    I16             shift and go to state 78
    I32             shift and go to state 79
    I64             shift and go to state 80
    I128            shift and go to state 81
    ISIZE           shift and go to state 82
    U8              shift and go to state 83
    U16             shift and go to state 84
    U32             shift and go to state 85
    U64             shift and go to state 86
    U128            shift and go to state 87
    USIZE           shift and go to state 88
    F32             shift and go to state 89
    F64             shift and go to state 90

    data_type                      shift and go to state 119
    some_data_type                 shift and go to state 142
    signed_integer                 shift and go to state 73
    unsigned_integer               shift and go to state 74
    float_type                     shift and go to state 75

state 135

    (37) asig_data_type -> LCORCH some_data_type RCORCH .

    ASIG            reduce using rule 37 (asig_data_type -> LCORCH some_data_type RCORCH .)
    COMMA           reduce using rule 37 (asig_data_type -> LCORCH some_data_type RCORCH .)
    RPAREN          reduce using rule 37 (asig_data_type -> LCORCH some_data_type RCORCH .)


state 136

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG . valor
    (13) valor -> . INTEGER
    (14) valor -> . FLOAT
    (15) valor -> . IDENTIFIER
    (16) valor -> . operacion
    (17) valor -> . indexacion
    (18) valor -> . arreglos
    (19) valor -> . STRING
    (69) operacion -> . valor PLUS valor
    (70) operacion -> . valor MINUS valor
    (71) operacion -> . valor TIMES valor
    (72) operacion -> . valor DIVIDE valor
    (73) operacion -> . valor MOD valor
    (74) operacion -> . valor INTD valor
    (75) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (60) arreglos -> . LCORCH valores RCORCH

    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    IDENTIFIER      shift and go to state 32
    STRING          shift and go to state 36
    LCORCH          shift and go to state 13

    valor                          shift and go to state 143
    operacion                      shift and go to state 33
    indexacion                     shift and go to state 34
    arreglos                       shift and go to state 35

state 137

    (28) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores . RPAREN

    RPAREN          shift and go to state 144


state 138

    (31) parameters -> IDENTIFIER COLON asig_data_type .
    (32) parameters -> IDENTIFIER COLON asig_data_type . COMMA parameters

    RPAREN          reduce using rule 31 (parameters -> IDENTIFIER COLON asig_data_type .)
    COMMA           shift and go to state 145


state 139

    (29) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE . sentencias RLLAVE
    (21) sentencias -> . asignacion SEMICOLON
    (22) sentencias -> . impresion SEMICOLON
    (23) sentencias -> . funcion
    (24) sentencias -> . ingreso_datos SEMICOLON
    (25) sentencias -> . arreglos SEMICOLON
    (26) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (27) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (28) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (29) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (30) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (34) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (60) arreglos -> . LCORCH valores RCORCH
    (59) control_structure -> . condicional
    (67) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (68) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    sentencias                     shift and go to state 146
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 140

    (30) funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE . sentencias RLLAVE
    (21) sentencias -> . asignacion SEMICOLON
    (22) sentencias -> . impresion SEMICOLON
    (23) sentencias -> . funcion
    (24) sentencias -> . ingreso_datos SEMICOLON
    (25) sentencias -> . arreglos SEMICOLON
    (26) sentencias -> . control_structure SEMICOLON
    (3) asignacion -> . LET IDENTIFIER ASIG valor
    (4) asignacion -> . LET MUT IDENTIFIER ASIG valor
    (5) asignacion -> . LET IDENTIFIER COLON asig_data_type ASIG valor
    (6) asignacion -> . LET MUT IDENTIFIER COLON asig_data_type ASIG valor
    (27) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (28) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (29) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (30) funcion -> . FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE
    (34) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (60) arreglos -> . LCORCH valores RCORCH
    (59) control_structure -> . condicional
    (67) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (68) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 9
    PRINTLN         shift and go to state 10
    FN              shift and go to state 11
    STD             shift and go to state 12
    LCORCH          shift and go to state 13
    IF              shift and go to state 15

    sentencias                     shift and go to state 147
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    funcion                        shift and go to state 5
    ingreso_datos                  shift and go to state 6
    arreglos                       shift and go to state 7
    control_structure              shift and go to state 8
    condicional                    shift and go to state 14

state 141

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN . LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 148


state 142

    (58) some_data_type -> data_type COMMA some_data_type .

    RPAREN          reduce using rule 58 (some_data_type -> data_type COMMA some_data_type .)
    RCORCH          reduce using rule 58 (some_data_type -> data_type COMMA some_data_type .)


state 143

    (6) asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor .
    (69) operacion -> valor . PLUS valor
    (70) operacion -> valor . MINUS valor
    (71) operacion -> valor . TIMES valor
    (72) operacion -> valor . DIVIDE valor
    (73) operacion -> valor . MOD valor
    (74) operacion -> valor . INTD valor

    SEMICOLON       reduce using rule 6 (asignacion -> LET MUT IDENTIFIER COLON asig_data_type ASIG valor .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    MOD             shift and go to state 53
    INTD            shift and go to state 54


state 144

    (28) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .

    SEMICOLON       reduce using rule 28 (impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .)


state 145

    (32) parameters -> IDENTIFIER COLON asig_data_type COMMA . parameters
    (31) parameters -> . IDENTIFIER COLON asig_data_type
    (32) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (33) parameters -> . vacio
    (20) vacio -> .

    IDENTIFIER      shift and go to state 94
    RPAREN          reduce using rule 20 (vacio -> .)

    parameters                     shift and go to state 149
    vacio                          shift and go to state 96

state 146

    (29) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias . RLLAVE

    RLLAVE          shift and go to state 150


state 147

    (30) funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias . RLLAVE

    RLLAVE          shift and go to state 151


state 148

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN . RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    RPAREN          shift and go to state 152


state 149

    (32) parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .

    RPAREN          reduce using rule 32 (parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .)


state 150

    (29) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .

    LET             reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    PRINTLN         reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    FN              reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    STD             reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    LCORCH          reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    IF              reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    $end            reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    RLLAVE          reduce using rule 29 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)


state 151

    (30) funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .

    LET             reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    PRINTLN         reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    FN              reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    STD             reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    LCORCH          reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    IF              reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    $end            reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)
    RLLAVE          reduce using rule 30 (funcion -> FN MAIN LPAREN parameters RPAREN LLLAVE sentencias RLLAVE .)


state 152

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN . DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 153


state 153

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT . READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    READLINE        shift and go to state 154


state 154

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE . LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 155


state 155

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN . REFERENCE MUT IDENTIFIER RPAREN

    REFERENCE       shift and go to state 156


state 156

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE . MUT IDENTIFIER RPAREN

    MUT             shift and go to state 157


state 157

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 158


state 158

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER . RPAREN

    RPAREN          shift and go to state 159


state 159

    (34) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .

    SEMICOLON       reduce using rule 34 (ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LLLAVE in state 37 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 100 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 100 resolved as shift
WARNING: shift/reduce conflict for MOD in state 100 resolved as shift
WARNING: shift/reduce conflict for INTD in state 100 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 101 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 101 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 101 resolved as shift
WARNING: shift/reduce conflict for MOD in state 101 resolved as shift
WARNING: shift/reduce conflict for INTD in state 101 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 102 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 102 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 102 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 102 resolved as shift
WARNING: shift/reduce conflict for MOD in state 102 resolved as shift
WARNING: shift/reduce conflict for INTD in state 102 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 103 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 103 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 103 resolved as shift
WARNING: shift/reduce conflict for MOD in state 103 resolved as shift
WARNING: shift/reduce conflict for INTD in state 103 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for MOD in state 104 resolved as shift
WARNING: shift/reduce conflict for INTD in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MOD in state 105 resolved as shift
WARNING: shift/reduce conflict for INTD in state 105 resolved as shift
