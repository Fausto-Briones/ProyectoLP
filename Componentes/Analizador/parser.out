Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHARACTER
    DOUBLE_QUOTATION_MARK
    ELSE
    FOR
    FROM
    IMPL
    IN
    MATCH
    NOT
    QUOTATION_MARK
    RAND
    SELF
    STRUCT
    WHILE

Grammar

Rule 0     S' -> codigoRust
Rule 1     codigoRust -> functions fnmain functions
Rule 2     codigoRust -> functions fnmain
Rule 3     codigoRust -> fnmain functions
Rule 4     codigoRust -> fnmain
Rule 5     functions -> funcion
Rule 6     functions -> funcion functions
Rule 7     programa -> sentencias
Rule 8     programa -> sentencias programa
Rule 9     asignacion_variable -> LET IDENTIFIER ASIG valor
Rule 10    asignacion_variable -> LET MUT IDENTIFIER ASIG valor
Rule 11    asignacion_variable -> LET IDENTIFIER COLON asignacion
Rule 12    asignacion_variable -> LET MUT IDENTIFIER COLON asignacion
Rule 13    declaracion_variable -> LET IDENTIFIER
Rule 14    declaracion_variable -> LET MUT IDENTIFIER
Rule 15    declaracion_variable -> LET IDENTIFIER COLON asig_data_type
Rule 16    declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type
Rule 17    asignacion -> string_asignacion
Rule 18    asignacion -> numero_asignacion
Rule 19    asignacion -> boolean_asignacion
Rule 20    asignacion -> lista_asignacion
Rule 21    asignacion -> tupla_asignacion
Rule 22    string_asignacion -> REFERENCE STR ASIG STRING
Rule 23    numero_asignacion -> signed_integer ASIG INTEGER
Rule 24    numero_asignacion -> signed_integer ASIG MINUS INTEGER
Rule 25    numero_asignacion -> unsigned_integer ASIG INTEGER
Rule 26    numero_asignacion -> float_type ASIG FLOAT
Rule 27    numero_asignacion -> float_type ASIG MINUS FLOAT
Rule 28    boolean_asignacion -> BOOL ASIG TRUE
Rule 29    boolean_asignacion -> BOOL ASIG FALSE
Rule 30    lista_asignacion -> list_type ASIG arreglos
Rule 31    tupla_asignacion -> tuple_type ASIG tuplas
Rule 32    comparacion -> valor EQ valor
Rule 33    comparacion -> valor NEQ valor
Rule 34    comparacion -> valor GEQ valor
Rule 35    comparacion -> valor LEQ valor
Rule 36    comparacion -> valor RIGHTARROW valor
Rule 37    comparacion -> valor LEFTARROW valor
Rule 38    valor -> INTEGER
Rule 39    valor -> FLOAT
Rule 40    valor -> IDENTIFIER
Rule 41    valor -> operacion
Rule 42    valor -> indexacion
Rule 43    valor -> arreglos
Rule 44    valor -> STRING
Rule 45    valor -> booleanos
Rule 46    booleanos -> TRUE
Rule 47    booleanos -> FALSE
Rule 48    vacio -> <empty>
Rule 49    sentencias -> asignacion_variable SEMICOLON
Rule 50    sentencias -> declaracion_variable SEMICOLON
Rule 51    sentencias -> impresion SEMICOLON
Rule 52    sentencias -> ingreso_datos SEMICOLON
Rule 53    sentencias -> arreglos SEMICOLON
Rule 54    sentencias -> control_structure
Rule 55    sentencias -> llamada SEMICOLON
Rule 56    impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN
Rule 57    impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
Rule 58    funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
Rule 59    funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
Rule 60    funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 61    funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
Rule 62    retorno -> RETURN valor SEMICOLON
Rule 63    parameters -> IDENTIFIER COLON asig_data_type
Rule 64    parameters -> IDENTIFIER COLON asig_data_type COMMA parameters
Rule 65    parameters -> vacio
Rule 66    ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
Rule 67    asig_data_type -> data_type
Rule 68    asig_data_type -> list_type
Rule 69    asig_data_type -> tuple_type
Rule 70    list_type -> LCORCH some_data_type RCORCH
Rule 71    tuple_type -> LPAREN some_data_type RPAREN
Rule 72    data_type -> CHAR
Rule 73    data_type -> REFERENCE STR
Rule 74    data_type -> signed_integer
Rule 75    data_type -> unsigned_integer
Rule 76    data_type -> float_type
Rule 77    data_type -> BOOL
Rule 78    signed_integer -> I8
Rule 79    signed_integer -> I16
Rule 80    signed_integer -> I32
Rule 81    signed_integer -> I64
Rule 82    signed_integer -> I128
Rule 83    signed_integer -> ISIZE
Rule 84    unsigned_integer -> U8
Rule 85    unsigned_integer -> U16
Rule 86    unsigned_integer -> U32
Rule 87    unsigned_integer -> U64
Rule 88    unsigned_integer -> U128
Rule 89    unsigned_integer -> USIZE
Rule 90    float_type -> F32
Rule 91    float_type -> F64
Rule 92    some_data_type -> data_type
Rule 93    some_data_type -> data_type COMMA some_data_type
Rule 94    control_structure -> condicional
Rule 95    arreglos -> LCORCH valores RCORCH
Rule 96    tuplas -> LPAREN valores RPAREN
Rule 97    valores -> valor
Rule 98    valores -> valor COMMA valores
Rule 99    conector -> AND
Rule 100   conector -> OR
Rule 101   proposicion -> comparacion conector proposicion
Rule 102   proposicion -> comparacion
Rule 103   condicional -> IF comparacion LLLAVE programa RLLAVE
Rule 104   condicional -> IF proposicion LLLAVE programa RLLAVE
Rule 105   numeric -> INTEGER
Rule 106   numeric -> FLOAT
Rule 107   numeric -> IDENTIFIER
Rule 108   cadena -> STRING
Rule 109   cadena -> IDENTIFIER
Rule 110   operacion -> numeric PLUS numeric
Rule 111   operacion -> numeric MINUS numeric
Rule 112   operacion -> numeric TIMES numeric
Rule 113   operacion -> numeric DIVIDE numeric
Rule 114   operacion -> numeric MOD numeric
Rule 115   operacion -> numeric INTD numeric
Rule 116   operacion -> cadena PLUS cadena
Rule 117   indexacion -> IDENTIFIER LCORCH INTEGER RCORCH
Rule 118   llamada -> IDENTIFIER LPAREN valores RPAREN
Rule 119   llamada -> IDENTIFIER LPAREN RPAREN
Rule 120   fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE

Terminals, with rules where they appear

AND                  : 99
ASIG                 : 9 10 22 23 24 25 26 27 28 29 30 31
BOOL                 : 28 29 77
CHAR                 : 72
CHARACTER            : 
COLON                : 11 12 15 16 63 64
COMMA                : 57 64 93 98
DIVIDE               : 113
DOT                  : 66 66
DOUBLE_COLON         : 66 66
DOUBLE_QUOTATION_MARK : 
ELSE                 : 
EQ                   : 32
EXCLAMATION          : 56 57
F32                  : 90
F64                  : 91
FALSE                : 29 47
FLOAT                : 26 27 39 106
FN                   : 58 59 60 61 120
FOR                  : 
FROM                 : 
GEQ                  : 34
I128                 : 82
I16                  : 79
I32                  : 80
I64                  : 81
I8                   : 78
IDENTIFIER           : 9 10 11 12 13 14 15 16 40 58 59 60 61 63 64 66 107 109 117 118 119
IF                   : 103 104
IMPL                 : 
IN                   : 
INTD                 : 115
INTEGER              : 23 24 25 38 105 117
IO                   : 66
ISIZE                : 83
LCORCH               : 70 95 117
LEFTARROW            : 37
LEQ                  : 35
LET                  : 9 10 11 12 13 14 15 16
LLLAVE               : 58 59 60 61 103 104 120
LPAREN               : 56 57 58 59 60 61 66 66 71 96 118 119 120
MAIN                 : 120
MATCH                : 
MINUS                : 24 27 60 61 111
MOD                  : 114
MUT                  : 10 12 14 16 66
NEQ                  : 33
NOT                  : 
OR                   : 100
PLUS                 : 110 116
PRINTLN              : 56 57
QUOTATION_MARK       : 
RAND                 : 
RCORCH               : 70 95 117
READLINE             : 66
REFERENCE            : 22 66 73
RETURN               : 62
RIGHTARROW           : 36 60 61
RLLAVE               : 58 59 60 61 103 104 120
RPAREN               : 56 57 58 59 60 61 66 66 71 96 118 119 120
SELF                 : 
SEMICOLON            : 49 50 51 52 53 55 62
STD                  : 66
STDIN                : 66
STR                  : 22 73
STRING               : 22 44 108
STRUCT               : 
TIMES                : 112
TRUE                 : 28 46
U128                 : 88
U16                  : 85
U32                  : 86
U64                  : 87
U8                   : 84
USIZE                : 89
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arreglos             : 30 43 53
asig_data_type       : 15 16 63 64
asignacion           : 11 12
asignacion_variable  : 49
boolean_asignacion   : 19
booleanos            : 45
cadena               : 116 116
codigoRust           : 0
comparacion          : 101 102 103
condicional          : 94
conector             : 101
control_structure    : 54
data_type            : 60 61 67 92 93
declaracion_variable : 50
float_type           : 26 27 76
fnmain               : 1 2 3 4
funcion              : 5 6
functions            : 1 1 2 3 6
impresion            : 51
indexacion           : 42
ingreso_datos        : 52
list_type            : 30 68
lista_asignacion     : 20
llamada              : 55
numeric              : 110 110 111 111 112 112 113 113 114 114 115 115
numero_asignacion    : 18
operacion            : 41
parameters           : 58 60 64
programa             : 8 58 59 60 61 103 104 120
proposicion          : 101 104
retorno              : 60 61
sentencias           : 7 8
signed_integer       : 23 24 74
some_data_type       : 70 71 93
string_asignacion    : 17
tupla_asignacion     : 21
tuplas               : 31
tuple_type           : 31 69
unsigned_integer     : 25 75
vacio                : 65
valor                : 9 10 32 32 33 33 34 34 35 35 36 36 37 37 56 57 62 97 98
valores              : 57 95 96 98 118

Parsing method: LALR

state 0

    (0) S' -> . codigoRust
    (1) codigoRust -> . functions fnmain functions
    (2) codigoRust -> . functions fnmain
    (3) codigoRust -> . fnmain functions
    (4) codigoRust -> . fnmain
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (120) fnmain -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (58) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    FN              shift and go to state 5

    codigoRust                     shift and go to state 1
    functions                      shift and go to state 2
    fnmain                         shift and go to state 3
    funcion                        shift and go to state 4

state 1

    (0) S' -> codigoRust .



state 2

    (1) codigoRust -> functions . fnmain functions
    (2) codigoRust -> functions . fnmain
    (120) fnmain -> . FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE

    FN              shift and go to state 7

    fnmain                         shift and go to state 6

state 3

    (3) codigoRust -> fnmain . functions
    (4) codigoRust -> fnmain .
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (58) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    $end            reduce using rule 4 (codigoRust -> fnmain .)
    FN              shift and go to state 9

    functions                      shift and go to state 8
    funcion                        shift and go to state 4

state 4

    (5) functions -> funcion .
    (6) functions -> funcion . functions
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (58) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

  ! shift/reduce conflict for FN resolved as shift
    $end            reduce using rule 5 (functions -> funcion .)
    FN              shift and go to state 9

  ! FN              [ reduce using rule 5 (functions -> funcion .) ]

    funcion                        shift and go to state 4
    functions                      shift and go to state 10

state 5

    (120) fnmain -> FN . MAIN LPAREN RPAREN LLLAVE programa RLLAVE
    (58) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> FN . IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    MAIN            shift and go to state 11
    IDENTIFIER      shift and go to state 12


state 6

    (1) codigoRust -> functions fnmain . functions
    (2) codigoRust -> functions fnmain .
    (5) functions -> . funcion
    (6) functions -> . funcion functions
    (58) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> . FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> . FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> . FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    $end            reduce using rule 2 (codigoRust -> functions fnmain .)
    FN              shift and go to state 9

    functions                      shift and go to state 13
    funcion                        shift and go to state 4

state 7

    (120) fnmain -> FN . MAIN LPAREN RPAREN LLLAVE programa RLLAVE

    MAIN            shift and go to state 11


state 8

    (3) codigoRust -> fnmain functions .

    $end            reduce using rule 3 (codigoRust -> fnmain functions .)


state 9

    (58) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> FN . IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> FN . IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> FN . IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    IDENTIFIER      shift and go to state 12


state 10

    (6) functions -> funcion functions .

    FN              reduce using rule 6 (functions -> funcion functions .)
    $end            reduce using rule 6 (functions -> funcion functions .)


state 11

    (120) fnmain -> FN MAIN . LPAREN RPAREN LLLAVE programa RLLAVE

    LPAREN          shift and go to state 14


state 12

    (58) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> FN IDENTIFIER . LPAREN RPAREN LLLAVE programa RLLAVE
    (60) funcion -> FN IDENTIFIER . LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> FN IDENTIFIER . LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LPAREN          shift and go to state 15


state 13

    (1) codigoRust -> functions fnmain functions .

    $end            reduce using rule 1 (codigoRust -> functions fnmain functions .)


state 14

    (120) fnmain -> FN MAIN LPAREN . RPAREN LLLAVE programa RLLAVE

    RPAREN          shift and go to state 16


state 15

    (58) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN LLLAVE programa RLLAVE
    (59) funcion -> FN IDENTIFIER LPAREN . RPAREN LLLAVE programa RLLAVE
    (60) funcion -> FN IDENTIFIER LPAREN . parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (61) funcion -> FN IDENTIFIER LPAREN . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE
    (63) parameters -> . IDENTIFIER COLON asig_data_type
    (64) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (65) parameters -> . vacio
    (48) vacio -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 17

  ! RPAREN          [ reduce using rule 48 (vacio -> .) ]

    parameters                     shift and go to state 18
    vacio                          shift and go to state 20

state 16

    (120) fnmain -> FN MAIN LPAREN RPAREN . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 21


state 17

    (63) parameters -> IDENTIFIER . COLON asig_data_type
    (64) parameters -> IDENTIFIER . COLON asig_data_type COMMA parameters

    COLON           shift and go to state 22


state 18

    (58) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN LLLAVE programa RLLAVE
    (60) funcion -> FN IDENTIFIER LPAREN parameters . RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RPAREN          shift and go to state 23


state 19

    (59) funcion -> FN IDENTIFIER LPAREN RPAREN . LLLAVE programa RLLAVE
    (61) funcion -> FN IDENTIFIER LPAREN RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 24
    MINUS           shift and go to state 25


state 20

    (65) parameters -> vacio .

    RPAREN          reduce using rule 65 (parameters -> vacio .)


state 21

    (120) fnmain -> FN MAIN LPAREN RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 26
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 22

    (63) parameters -> IDENTIFIER COLON . asig_data_type
    (64) parameters -> IDENTIFIER COLON . asig_data_type COMMA parameters
    (67) asig_data_type -> . data_type
    (68) asig_data_type -> . list_type
    (69) asig_data_type -> . tuple_type
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (70) list_type -> . LCORCH some_data_type RCORCH
    (71) tuple_type -> . LPAREN some_data_type RPAREN
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    LCORCH          shift and go to state 52
    LPAREN          shift and go to state 53
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    asig_data_type                 shift and go to state 42
    data_type                      shift and go to state 43
    list_type                      shift and go to state 44
    tuple_type                     shift and go to state 45
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 23

    (58) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . LLLAVE programa RLLAVE
    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN . MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 68
    MINUS           shift and go to state 69


state 24

    (59) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 70
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 25

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 71


state 26

    (120) fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 72


state 27

    (7) programa -> sentencias .
    (8) programa -> sentencias . programa
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    RLLAVE          reduce using rule 7 (programa -> sentencias .)
    RETURN          reduce using rule 7 (programa -> sentencias .)
    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    sentencias                     shift and go to state 27
    programa                       shift and go to state 73
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 28

    (49) sentencias -> asignacion_variable . SEMICOLON

    SEMICOLON       shift and go to state 74


state 29

    (50) sentencias -> declaracion_variable . SEMICOLON

    SEMICOLON       shift and go to state 75


state 30

    (51) sentencias -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 76


state 31

    (52) sentencias -> ingreso_datos . SEMICOLON

    SEMICOLON       shift and go to state 77


state 32

    (53) sentencias -> arreglos . SEMICOLON

    SEMICOLON       shift and go to state 78


state 33

    (54) sentencias -> control_structure .

    LET             reduce using rule 54 (sentencias -> control_structure .)
    PRINTLN         reduce using rule 54 (sentencias -> control_structure .)
    STD             reduce using rule 54 (sentencias -> control_structure .)
    LCORCH          reduce using rule 54 (sentencias -> control_structure .)
    IDENTIFIER      reduce using rule 54 (sentencias -> control_structure .)
    IF              reduce using rule 54 (sentencias -> control_structure .)
    RLLAVE          reduce using rule 54 (sentencias -> control_structure .)
    RETURN          reduce using rule 54 (sentencias -> control_structure .)


state 34

    (55) sentencias -> llamada . SEMICOLON

    SEMICOLON       shift and go to state 79


state 35

    (9) asignacion_variable -> LET . IDENTIFIER ASIG valor
    (10) asignacion_variable -> LET . MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> LET . IDENTIFIER COLON asignacion
    (12) asignacion_variable -> LET . MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> LET . IDENTIFIER
    (14) declaracion_variable -> LET . MUT IDENTIFIER
    (15) declaracion_variable -> LET . IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> LET . MUT IDENTIFIER COLON asig_data_type

    IDENTIFIER      shift and go to state 80
    MUT             shift and go to state 81


state 36

    (118) llamada -> IDENTIFIER . LPAREN valores RPAREN
    (119) llamada -> IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 82


state 37

    (56) impresion -> PRINTLN . EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> PRINTLN . EXCLAMATION LPAREN valor COMMA valores RPAREN

    EXCLAMATION     shift and go to state 83


state 38

    (66) ingreso_datos -> STD . DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 84


state 39

    (95) arreglos -> LCORCH . valores RCORCH
    (97) valores -> . valor
    (98) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valores                        shift and go to state 85
    valor                          shift and go to state 86
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 40

    (94) control_structure -> condicional .

    LET             reduce using rule 94 (control_structure -> condicional .)
    PRINTLN         reduce using rule 94 (control_structure -> condicional .)
    STD             reduce using rule 94 (control_structure -> condicional .)
    LCORCH          reduce using rule 94 (control_structure -> condicional .)
    IDENTIFIER      reduce using rule 94 (control_structure -> condicional .)
    IF              reduce using rule 94 (control_structure -> condicional .)
    RLLAVE          reduce using rule 94 (control_structure -> condicional .)
    RETURN          reduce using rule 94 (control_structure -> condicional .)


state 41

    (103) condicional -> IF . comparacion LLLAVE programa RLLAVE
    (104) condicional -> IF . proposicion LLLAVE programa RLLAVE
    (32) comparacion -> . valor EQ valor
    (33) comparacion -> . valor NEQ valor
    (34) comparacion -> . valor GEQ valor
    (35) comparacion -> . valor LEQ valor
    (36) comparacion -> . valor RIGHTARROW valor
    (37) comparacion -> . valor LEFTARROW valor
    (101) proposicion -> . comparacion conector proposicion
    (102) proposicion -> . comparacion
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    comparacion                    shift and go to state 99
    proposicion                    shift and go to state 100
    valor                          shift and go to state 101
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 42

    (63) parameters -> IDENTIFIER COLON asig_data_type .
    (64) parameters -> IDENTIFIER COLON asig_data_type . COMMA parameters

    RPAREN          reduce using rule 63 (parameters -> IDENTIFIER COLON asig_data_type .)
    COMMA           shift and go to state 102


state 43

    (67) asig_data_type -> data_type .

    COMMA           reduce using rule 67 (asig_data_type -> data_type .)
    RPAREN          reduce using rule 67 (asig_data_type -> data_type .)
    SEMICOLON       reduce using rule 67 (asig_data_type -> data_type .)


state 44

    (68) asig_data_type -> list_type .

    COMMA           reduce using rule 68 (asig_data_type -> list_type .)
    RPAREN          reduce using rule 68 (asig_data_type -> list_type .)


state 45

    (69) asig_data_type -> tuple_type .

    COMMA           reduce using rule 69 (asig_data_type -> tuple_type .)
    RPAREN          reduce using rule 69 (asig_data_type -> tuple_type .)


state 46

    (72) data_type -> CHAR .

    COMMA           reduce using rule 72 (data_type -> CHAR .)
    RPAREN          reduce using rule 72 (data_type -> CHAR .)
    RCORCH          reduce using rule 72 (data_type -> CHAR .)
    LLLAVE          reduce using rule 72 (data_type -> CHAR .)
    SEMICOLON       reduce using rule 72 (data_type -> CHAR .)


state 47

    (73) data_type -> REFERENCE . STR

    STR             shift and go to state 103


state 48

    (74) data_type -> signed_integer .

    COMMA           reduce using rule 74 (data_type -> signed_integer .)
    RPAREN          reduce using rule 74 (data_type -> signed_integer .)
    RCORCH          reduce using rule 74 (data_type -> signed_integer .)
    LLLAVE          reduce using rule 74 (data_type -> signed_integer .)


state 49

    (75) data_type -> unsigned_integer .

    COMMA           reduce using rule 75 (data_type -> unsigned_integer .)
    RPAREN          reduce using rule 75 (data_type -> unsigned_integer .)
    RCORCH          reduce using rule 75 (data_type -> unsigned_integer .)
    LLLAVE          reduce using rule 75 (data_type -> unsigned_integer .)


state 50

    (76) data_type -> float_type .

    COMMA           reduce using rule 76 (data_type -> float_type .)
    RPAREN          reduce using rule 76 (data_type -> float_type .)
    RCORCH          reduce using rule 76 (data_type -> float_type .)
    LLLAVE          reduce using rule 76 (data_type -> float_type .)


state 51

    (77) data_type -> BOOL .

    COMMA           reduce using rule 77 (data_type -> BOOL .)
    RPAREN          reduce using rule 77 (data_type -> BOOL .)
    RCORCH          reduce using rule 77 (data_type -> BOOL .)
    LLLAVE          reduce using rule 77 (data_type -> BOOL .)


state 52

    (70) list_type -> LCORCH . some_data_type RCORCH
    (92) some_data_type -> . data_type
    (93) some_data_type -> . data_type COMMA some_data_type
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    some_data_type                 shift and go to state 104
    data_type                      shift and go to state 105
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 53

    (71) tuple_type -> LPAREN . some_data_type RPAREN
    (92) some_data_type -> . data_type
    (93) some_data_type -> . data_type COMMA some_data_type
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    some_data_type                 shift and go to state 106
    data_type                      shift and go to state 105
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 54

    (78) signed_integer -> I8 .

    COMMA           reduce using rule 78 (signed_integer -> I8 .)
    RPAREN          reduce using rule 78 (signed_integer -> I8 .)
    RCORCH          reduce using rule 78 (signed_integer -> I8 .)
    LLLAVE          reduce using rule 78 (signed_integer -> I8 .)
    ASIG            reduce using rule 78 (signed_integer -> I8 .)
    SEMICOLON       reduce using rule 78 (signed_integer -> I8 .)


state 55

    (79) signed_integer -> I16 .

    COMMA           reduce using rule 79 (signed_integer -> I16 .)
    RPAREN          reduce using rule 79 (signed_integer -> I16 .)
    RCORCH          reduce using rule 79 (signed_integer -> I16 .)
    LLLAVE          reduce using rule 79 (signed_integer -> I16 .)
    ASIG            reduce using rule 79 (signed_integer -> I16 .)
    SEMICOLON       reduce using rule 79 (signed_integer -> I16 .)


state 56

    (80) signed_integer -> I32 .

    COMMA           reduce using rule 80 (signed_integer -> I32 .)
    RPAREN          reduce using rule 80 (signed_integer -> I32 .)
    RCORCH          reduce using rule 80 (signed_integer -> I32 .)
    LLLAVE          reduce using rule 80 (signed_integer -> I32 .)
    ASIG            reduce using rule 80 (signed_integer -> I32 .)
    SEMICOLON       reduce using rule 80 (signed_integer -> I32 .)


state 57

    (81) signed_integer -> I64 .

    COMMA           reduce using rule 81 (signed_integer -> I64 .)
    RPAREN          reduce using rule 81 (signed_integer -> I64 .)
    RCORCH          reduce using rule 81 (signed_integer -> I64 .)
    LLLAVE          reduce using rule 81 (signed_integer -> I64 .)
    ASIG            reduce using rule 81 (signed_integer -> I64 .)
    SEMICOLON       reduce using rule 81 (signed_integer -> I64 .)


state 58

    (82) signed_integer -> I128 .

    COMMA           reduce using rule 82 (signed_integer -> I128 .)
    RPAREN          reduce using rule 82 (signed_integer -> I128 .)
    RCORCH          reduce using rule 82 (signed_integer -> I128 .)
    LLLAVE          reduce using rule 82 (signed_integer -> I128 .)
    ASIG            reduce using rule 82 (signed_integer -> I128 .)
    SEMICOLON       reduce using rule 82 (signed_integer -> I128 .)


state 59

    (83) signed_integer -> ISIZE .

    COMMA           reduce using rule 83 (signed_integer -> ISIZE .)
    RPAREN          reduce using rule 83 (signed_integer -> ISIZE .)
    RCORCH          reduce using rule 83 (signed_integer -> ISIZE .)
    LLLAVE          reduce using rule 83 (signed_integer -> ISIZE .)
    ASIG            reduce using rule 83 (signed_integer -> ISIZE .)
    SEMICOLON       reduce using rule 83 (signed_integer -> ISIZE .)


state 60

    (84) unsigned_integer -> U8 .

    COMMA           reduce using rule 84 (unsigned_integer -> U8 .)
    RPAREN          reduce using rule 84 (unsigned_integer -> U8 .)
    RCORCH          reduce using rule 84 (unsigned_integer -> U8 .)
    LLLAVE          reduce using rule 84 (unsigned_integer -> U8 .)
    ASIG            reduce using rule 84 (unsigned_integer -> U8 .)
    SEMICOLON       reduce using rule 84 (unsigned_integer -> U8 .)


state 61

    (85) unsigned_integer -> U16 .

    COMMA           reduce using rule 85 (unsigned_integer -> U16 .)
    RPAREN          reduce using rule 85 (unsigned_integer -> U16 .)
    RCORCH          reduce using rule 85 (unsigned_integer -> U16 .)
    LLLAVE          reduce using rule 85 (unsigned_integer -> U16 .)
    ASIG            reduce using rule 85 (unsigned_integer -> U16 .)
    SEMICOLON       reduce using rule 85 (unsigned_integer -> U16 .)


state 62

    (86) unsigned_integer -> U32 .

    COMMA           reduce using rule 86 (unsigned_integer -> U32 .)
    RPAREN          reduce using rule 86 (unsigned_integer -> U32 .)
    RCORCH          reduce using rule 86 (unsigned_integer -> U32 .)
    LLLAVE          reduce using rule 86 (unsigned_integer -> U32 .)
    ASIG            reduce using rule 86 (unsigned_integer -> U32 .)
    SEMICOLON       reduce using rule 86 (unsigned_integer -> U32 .)


state 63

    (87) unsigned_integer -> U64 .

    COMMA           reduce using rule 87 (unsigned_integer -> U64 .)
    RPAREN          reduce using rule 87 (unsigned_integer -> U64 .)
    RCORCH          reduce using rule 87 (unsigned_integer -> U64 .)
    LLLAVE          reduce using rule 87 (unsigned_integer -> U64 .)
    ASIG            reduce using rule 87 (unsigned_integer -> U64 .)
    SEMICOLON       reduce using rule 87 (unsigned_integer -> U64 .)


state 64

    (88) unsigned_integer -> U128 .

    COMMA           reduce using rule 88 (unsigned_integer -> U128 .)
    RPAREN          reduce using rule 88 (unsigned_integer -> U128 .)
    RCORCH          reduce using rule 88 (unsigned_integer -> U128 .)
    LLLAVE          reduce using rule 88 (unsigned_integer -> U128 .)
    ASIG            reduce using rule 88 (unsigned_integer -> U128 .)
    SEMICOLON       reduce using rule 88 (unsigned_integer -> U128 .)


state 65

    (89) unsigned_integer -> USIZE .

    COMMA           reduce using rule 89 (unsigned_integer -> USIZE .)
    RPAREN          reduce using rule 89 (unsigned_integer -> USIZE .)
    RCORCH          reduce using rule 89 (unsigned_integer -> USIZE .)
    LLLAVE          reduce using rule 89 (unsigned_integer -> USIZE .)
    ASIG            reduce using rule 89 (unsigned_integer -> USIZE .)
    SEMICOLON       reduce using rule 89 (unsigned_integer -> USIZE .)


state 66

    (90) float_type -> F32 .

    COMMA           reduce using rule 90 (float_type -> F32 .)
    RPAREN          reduce using rule 90 (float_type -> F32 .)
    RCORCH          reduce using rule 90 (float_type -> F32 .)
    LLLAVE          reduce using rule 90 (float_type -> F32 .)
    ASIG            reduce using rule 90 (float_type -> F32 .)
    SEMICOLON       reduce using rule 90 (float_type -> F32 .)


state 67

    (91) float_type -> F64 .

    COMMA           reduce using rule 91 (float_type -> F64 .)
    RPAREN          reduce using rule 91 (float_type -> F64 .)
    RCORCH          reduce using rule 91 (float_type -> F64 .)
    LLLAVE          reduce using rule 91 (float_type -> F64 .)
    ASIG            reduce using rule 91 (float_type -> F64 .)
    SEMICOLON       reduce using rule 91 (float_type -> F64 .)


state 68

    (58) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 107
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 69

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS . RIGHTARROW data_type LLLAVE programa retorno RLLAVE

    RIGHTARROW      shift and go to state 108


state 70

    (59) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 109


state 71

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    data_type                      shift and go to state 110
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 72

    (120) fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 120 (fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 120 (fnmain -> FN MAIN LPAREN RPAREN LLLAVE programa RLLAVE .)


state 73

    (8) programa -> sentencias programa .

    RLLAVE          reduce using rule 8 (programa -> sentencias programa .)
    RETURN          reduce using rule 8 (programa -> sentencias programa .)


state 74

    (49) sentencias -> asignacion_variable SEMICOLON .

    LET             reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)
    PRINTLN         reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)
    STD             reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)
    LCORCH          reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)
    IDENTIFIER      reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)
    IF              reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)
    RLLAVE          reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)
    RETURN          reduce using rule 49 (sentencias -> asignacion_variable SEMICOLON .)


state 75

    (50) sentencias -> declaracion_variable SEMICOLON .

    LET             reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)
    PRINTLN         reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)
    STD             reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)
    LCORCH          reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)
    IDENTIFIER      reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)
    IF              reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)
    RLLAVE          reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)
    RETURN          reduce using rule 50 (sentencias -> declaracion_variable SEMICOLON .)


state 76

    (51) sentencias -> impresion SEMICOLON .

    LET             reduce using rule 51 (sentencias -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 51 (sentencias -> impresion SEMICOLON .)
    STD             reduce using rule 51 (sentencias -> impresion SEMICOLON .)
    LCORCH          reduce using rule 51 (sentencias -> impresion SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (sentencias -> impresion SEMICOLON .)
    IF              reduce using rule 51 (sentencias -> impresion SEMICOLON .)
    RLLAVE          reduce using rule 51 (sentencias -> impresion SEMICOLON .)
    RETURN          reduce using rule 51 (sentencias -> impresion SEMICOLON .)


state 77

    (52) sentencias -> ingreso_datos SEMICOLON .

    LET             reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)
    PRINTLN         reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)
    STD             reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)
    LCORCH          reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)
    IDENTIFIER      reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)
    IF              reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)
    RLLAVE          reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)
    RETURN          reduce using rule 52 (sentencias -> ingreso_datos SEMICOLON .)


state 78

    (53) sentencias -> arreglos SEMICOLON .

    LET             reduce using rule 53 (sentencias -> arreglos SEMICOLON .)
    PRINTLN         reduce using rule 53 (sentencias -> arreglos SEMICOLON .)
    STD             reduce using rule 53 (sentencias -> arreglos SEMICOLON .)
    LCORCH          reduce using rule 53 (sentencias -> arreglos SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (sentencias -> arreglos SEMICOLON .)
    IF              reduce using rule 53 (sentencias -> arreglos SEMICOLON .)
    RLLAVE          reduce using rule 53 (sentencias -> arreglos SEMICOLON .)
    RETURN          reduce using rule 53 (sentencias -> arreglos SEMICOLON .)


state 79

    (55) sentencias -> llamada SEMICOLON .

    LET             reduce using rule 55 (sentencias -> llamada SEMICOLON .)
    PRINTLN         reduce using rule 55 (sentencias -> llamada SEMICOLON .)
    STD             reduce using rule 55 (sentencias -> llamada SEMICOLON .)
    LCORCH          reduce using rule 55 (sentencias -> llamada SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (sentencias -> llamada SEMICOLON .)
    IF              reduce using rule 55 (sentencias -> llamada SEMICOLON .)
    RLLAVE          reduce using rule 55 (sentencias -> llamada SEMICOLON .)
    RETURN          reduce using rule 55 (sentencias -> llamada SEMICOLON .)


state 80

    (9) asignacion_variable -> LET IDENTIFIER . ASIG valor
    (11) asignacion_variable -> LET IDENTIFIER . COLON asignacion
    (13) declaracion_variable -> LET IDENTIFIER .
    (15) declaracion_variable -> LET IDENTIFIER . COLON asig_data_type

    ASIG            shift and go to state 111
    COLON           shift and go to state 112
    SEMICOLON       reduce using rule 13 (declaracion_variable -> LET IDENTIFIER .)


state 81

    (10) asignacion_variable -> LET MUT . IDENTIFIER ASIG valor
    (12) asignacion_variable -> LET MUT . IDENTIFIER COLON asignacion
    (14) declaracion_variable -> LET MUT . IDENTIFIER
    (16) declaracion_variable -> LET MUT . IDENTIFIER COLON asig_data_type

    IDENTIFIER      shift and go to state 113


state 82

    (118) llamada -> IDENTIFIER LPAREN . valores RPAREN
    (119) llamada -> IDENTIFIER LPAREN . RPAREN
    (97) valores -> . valor
    (98) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    RPAREN          shift and go to state 115
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valores                        shift and go to state 114
    valor                          shift and go to state 86
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 83

    (56) impresion -> PRINTLN EXCLAMATION . LPAREN valor RPAREN
    (57) impresion -> PRINTLN EXCLAMATION . LPAREN valor COMMA valores RPAREN

    LPAREN          shift and go to state 116


state 84

    (66) ingreso_datos -> STD DOUBLE_COLON . IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    IO              shift and go to state 117


state 85

    (95) arreglos -> LCORCH valores . RCORCH

    RCORCH          shift and go to state 118


state 86

    (97) valores -> valor .
    (98) valores -> valor . COMMA valores

    RCORCH          reduce using rule 97 (valores -> valor .)
    RPAREN          reduce using rule 97 (valores -> valor .)
    COMMA           shift and go to state 119


state 87

    (38) valor -> INTEGER .
    (105) numeric -> INTEGER .

    COMMA           reduce using rule 38 (valor -> INTEGER .)
    RCORCH          reduce using rule 38 (valor -> INTEGER .)
    EQ              reduce using rule 38 (valor -> INTEGER .)
    NEQ             reduce using rule 38 (valor -> INTEGER .)
    GEQ             reduce using rule 38 (valor -> INTEGER .)
    LEQ             reduce using rule 38 (valor -> INTEGER .)
    RIGHTARROW      reduce using rule 38 (valor -> INTEGER .)
    LEFTARROW       reduce using rule 38 (valor -> INTEGER .)
    RPAREN          reduce using rule 38 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 38 (valor -> INTEGER .)
    LLLAVE          reduce using rule 38 (valor -> INTEGER .)
    AND             reduce using rule 38 (valor -> INTEGER .)
    OR              reduce using rule 38 (valor -> INTEGER .)
    PLUS            reduce using rule 105 (numeric -> INTEGER .)
    MINUS           reduce using rule 105 (numeric -> INTEGER .)
    TIMES           reduce using rule 105 (numeric -> INTEGER .)
    DIVIDE          reduce using rule 105 (numeric -> INTEGER .)
    MOD             reduce using rule 105 (numeric -> INTEGER .)
    INTD            reduce using rule 105 (numeric -> INTEGER .)


state 88

    (39) valor -> FLOAT .
    (106) numeric -> FLOAT .

    COMMA           reduce using rule 39 (valor -> FLOAT .)
    RCORCH          reduce using rule 39 (valor -> FLOAT .)
    EQ              reduce using rule 39 (valor -> FLOAT .)
    NEQ             reduce using rule 39 (valor -> FLOAT .)
    GEQ             reduce using rule 39 (valor -> FLOAT .)
    LEQ             reduce using rule 39 (valor -> FLOAT .)
    RIGHTARROW      reduce using rule 39 (valor -> FLOAT .)
    LEFTARROW       reduce using rule 39 (valor -> FLOAT .)
    RPAREN          reduce using rule 39 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 39 (valor -> FLOAT .)
    LLLAVE          reduce using rule 39 (valor -> FLOAT .)
    AND             reduce using rule 39 (valor -> FLOAT .)
    OR              reduce using rule 39 (valor -> FLOAT .)
    PLUS            reduce using rule 106 (numeric -> FLOAT .)
    MINUS           reduce using rule 106 (numeric -> FLOAT .)
    TIMES           reduce using rule 106 (numeric -> FLOAT .)
    DIVIDE          reduce using rule 106 (numeric -> FLOAT .)
    MOD             reduce using rule 106 (numeric -> FLOAT .)
    INTD            reduce using rule 106 (numeric -> FLOAT .)


state 89

    (40) valor -> IDENTIFIER .
    (117) indexacion -> IDENTIFIER . LCORCH INTEGER RCORCH
    (107) numeric -> IDENTIFIER .
    (109) cadena -> IDENTIFIER .

  ! reduce/reduce conflict for PLUS resolved using rule 107 (numeric -> IDENTIFIER .)
    COMMA           reduce using rule 40 (valor -> IDENTIFIER .)
    RCORCH          reduce using rule 40 (valor -> IDENTIFIER .)
    EQ              reduce using rule 40 (valor -> IDENTIFIER .)
    NEQ             reduce using rule 40 (valor -> IDENTIFIER .)
    GEQ             reduce using rule 40 (valor -> IDENTIFIER .)
    LEQ             reduce using rule 40 (valor -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 40 (valor -> IDENTIFIER .)
    LEFTARROW       reduce using rule 40 (valor -> IDENTIFIER .)
    RPAREN          reduce using rule 40 (valor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 40 (valor -> IDENTIFIER .)
    LLLAVE          reduce using rule 40 (valor -> IDENTIFIER .)
    AND             reduce using rule 40 (valor -> IDENTIFIER .)
    OR              reduce using rule 40 (valor -> IDENTIFIER .)
    LCORCH          shift and go to state 120
    PLUS            reduce using rule 107 (numeric -> IDENTIFIER .)
    MINUS           reduce using rule 107 (numeric -> IDENTIFIER .)
    TIMES           reduce using rule 107 (numeric -> IDENTIFIER .)
    DIVIDE          reduce using rule 107 (numeric -> IDENTIFIER .)
    MOD             reduce using rule 107 (numeric -> IDENTIFIER .)
    INTD            reduce using rule 107 (numeric -> IDENTIFIER .)

  ! PLUS            [ reduce using rule 109 (cadena -> IDENTIFIER .) ]


state 90

    (41) valor -> operacion .

    COMMA           reduce using rule 41 (valor -> operacion .)
    RCORCH          reduce using rule 41 (valor -> operacion .)
    EQ              reduce using rule 41 (valor -> operacion .)
    NEQ             reduce using rule 41 (valor -> operacion .)
    GEQ             reduce using rule 41 (valor -> operacion .)
    LEQ             reduce using rule 41 (valor -> operacion .)
    RIGHTARROW      reduce using rule 41 (valor -> operacion .)
    LEFTARROW       reduce using rule 41 (valor -> operacion .)
    RPAREN          reduce using rule 41 (valor -> operacion .)
    SEMICOLON       reduce using rule 41 (valor -> operacion .)
    LLLAVE          reduce using rule 41 (valor -> operacion .)
    AND             reduce using rule 41 (valor -> operacion .)
    OR              reduce using rule 41 (valor -> operacion .)


state 91

    (42) valor -> indexacion .

    COMMA           reduce using rule 42 (valor -> indexacion .)
    RCORCH          reduce using rule 42 (valor -> indexacion .)
    EQ              reduce using rule 42 (valor -> indexacion .)
    NEQ             reduce using rule 42 (valor -> indexacion .)
    GEQ             reduce using rule 42 (valor -> indexacion .)
    LEQ             reduce using rule 42 (valor -> indexacion .)
    RIGHTARROW      reduce using rule 42 (valor -> indexacion .)
    LEFTARROW       reduce using rule 42 (valor -> indexacion .)
    RPAREN          reduce using rule 42 (valor -> indexacion .)
    SEMICOLON       reduce using rule 42 (valor -> indexacion .)
    LLLAVE          reduce using rule 42 (valor -> indexacion .)
    AND             reduce using rule 42 (valor -> indexacion .)
    OR              reduce using rule 42 (valor -> indexacion .)


state 92

    (43) valor -> arreglos .

    COMMA           reduce using rule 43 (valor -> arreglos .)
    RCORCH          reduce using rule 43 (valor -> arreglos .)
    EQ              reduce using rule 43 (valor -> arreglos .)
    NEQ             reduce using rule 43 (valor -> arreglos .)
    GEQ             reduce using rule 43 (valor -> arreglos .)
    LEQ             reduce using rule 43 (valor -> arreglos .)
    RIGHTARROW      reduce using rule 43 (valor -> arreglos .)
    LEFTARROW       reduce using rule 43 (valor -> arreglos .)
    RPAREN          reduce using rule 43 (valor -> arreglos .)
    SEMICOLON       reduce using rule 43 (valor -> arreglos .)
    LLLAVE          reduce using rule 43 (valor -> arreglos .)
    AND             reduce using rule 43 (valor -> arreglos .)
    OR              reduce using rule 43 (valor -> arreglos .)


state 93

    (44) valor -> STRING .
    (108) cadena -> STRING .

    COMMA           reduce using rule 44 (valor -> STRING .)
    RCORCH          reduce using rule 44 (valor -> STRING .)
    EQ              reduce using rule 44 (valor -> STRING .)
    NEQ             reduce using rule 44 (valor -> STRING .)
    GEQ             reduce using rule 44 (valor -> STRING .)
    LEQ             reduce using rule 44 (valor -> STRING .)
    RIGHTARROW      reduce using rule 44 (valor -> STRING .)
    LEFTARROW       reduce using rule 44 (valor -> STRING .)
    RPAREN          reduce using rule 44 (valor -> STRING .)
    SEMICOLON       reduce using rule 44 (valor -> STRING .)
    LLLAVE          reduce using rule 44 (valor -> STRING .)
    AND             reduce using rule 44 (valor -> STRING .)
    OR              reduce using rule 44 (valor -> STRING .)
    PLUS            reduce using rule 108 (cadena -> STRING .)


state 94

    (45) valor -> booleanos .

    COMMA           reduce using rule 45 (valor -> booleanos .)
    RCORCH          reduce using rule 45 (valor -> booleanos .)
    EQ              reduce using rule 45 (valor -> booleanos .)
    NEQ             reduce using rule 45 (valor -> booleanos .)
    GEQ             reduce using rule 45 (valor -> booleanos .)
    LEQ             reduce using rule 45 (valor -> booleanos .)
    RIGHTARROW      reduce using rule 45 (valor -> booleanos .)
    LEFTARROW       reduce using rule 45 (valor -> booleanos .)
    RPAREN          reduce using rule 45 (valor -> booleanos .)
    SEMICOLON       reduce using rule 45 (valor -> booleanos .)
    LLLAVE          reduce using rule 45 (valor -> booleanos .)
    AND             reduce using rule 45 (valor -> booleanos .)
    OR              reduce using rule 45 (valor -> booleanos .)


state 95

    (110) operacion -> numeric . PLUS numeric
    (111) operacion -> numeric . MINUS numeric
    (112) operacion -> numeric . TIMES numeric
    (113) operacion -> numeric . DIVIDE numeric
    (114) operacion -> numeric . MOD numeric
    (115) operacion -> numeric . INTD numeric

    PLUS            shift and go to state 121
    MINUS           shift and go to state 122
    TIMES           shift and go to state 123
    DIVIDE          shift and go to state 124
    MOD             shift and go to state 125
    INTD            shift and go to state 126


state 96

    (116) operacion -> cadena . PLUS cadena

    PLUS            shift and go to state 127


state 97

    (46) booleanos -> TRUE .

    COMMA           reduce using rule 46 (booleanos -> TRUE .)
    RCORCH          reduce using rule 46 (booleanos -> TRUE .)
    EQ              reduce using rule 46 (booleanos -> TRUE .)
    NEQ             reduce using rule 46 (booleanos -> TRUE .)
    GEQ             reduce using rule 46 (booleanos -> TRUE .)
    LEQ             reduce using rule 46 (booleanos -> TRUE .)
    RIGHTARROW      reduce using rule 46 (booleanos -> TRUE .)
    LEFTARROW       reduce using rule 46 (booleanos -> TRUE .)
    RPAREN          reduce using rule 46 (booleanos -> TRUE .)
    SEMICOLON       reduce using rule 46 (booleanos -> TRUE .)
    LLLAVE          reduce using rule 46 (booleanos -> TRUE .)
    AND             reduce using rule 46 (booleanos -> TRUE .)
    OR              reduce using rule 46 (booleanos -> TRUE .)


state 98

    (47) booleanos -> FALSE .

    COMMA           reduce using rule 47 (booleanos -> FALSE .)
    RCORCH          reduce using rule 47 (booleanos -> FALSE .)
    EQ              reduce using rule 47 (booleanos -> FALSE .)
    NEQ             reduce using rule 47 (booleanos -> FALSE .)
    GEQ             reduce using rule 47 (booleanos -> FALSE .)
    LEQ             reduce using rule 47 (booleanos -> FALSE .)
    RIGHTARROW      reduce using rule 47 (booleanos -> FALSE .)
    LEFTARROW       reduce using rule 47 (booleanos -> FALSE .)
    RPAREN          reduce using rule 47 (booleanos -> FALSE .)
    SEMICOLON       reduce using rule 47 (booleanos -> FALSE .)
    LLLAVE          reduce using rule 47 (booleanos -> FALSE .)
    AND             reduce using rule 47 (booleanos -> FALSE .)
    OR              reduce using rule 47 (booleanos -> FALSE .)


state 99

    (103) condicional -> IF comparacion . LLLAVE programa RLLAVE
    (101) proposicion -> comparacion . conector proposicion
    (102) proposicion -> comparacion .
    (99) conector -> . AND
    (100) conector -> . OR

  ! shift/reduce conflict for LLLAVE resolved as shift
    LLLAVE          shift and go to state 128
    AND             shift and go to state 130
    OR              shift and go to state 131

  ! LLLAVE          [ reduce using rule 102 (proposicion -> comparacion .) ]

    conector                       shift and go to state 129

state 100

    (104) condicional -> IF proposicion . LLLAVE programa RLLAVE

    LLLAVE          shift and go to state 132


state 101

    (32) comparacion -> valor . EQ valor
    (33) comparacion -> valor . NEQ valor
    (34) comparacion -> valor . GEQ valor
    (35) comparacion -> valor . LEQ valor
    (36) comparacion -> valor . RIGHTARROW valor
    (37) comparacion -> valor . LEFTARROW valor

    EQ              shift and go to state 133
    NEQ             shift and go to state 134
    GEQ             shift and go to state 135
    LEQ             shift and go to state 136
    RIGHTARROW      shift and go to state 137
    LEFTARROW       shift and go to state 138


state 102

    (64) parameters -> IDENTIFIER COLON asig_data_type COMMA . parameters
    (63) parameters -> . IDENTIFIER COLON asig_data_type
    (64) parameters -> . IDENTIFIER COLON asig_data_type COMMA parameters
    (65) parameters -> . vacio
    (48) vacio -> .

    IDENTIFIER      shift and go to state 17
    RPAREN          reduce using rule 48 (vacio -> .)

    parameters                     shift and go to state 139
    vacio                          shift and go to state 20

state 103

    (73) data_type -> REFERENCE STR .

    COMMA           reduce using rule 73 (data_type -> REFERENCE STR .)
    RPAREN          reduce using rule 73 (data_type -> REFERENCE STR .)
    RCORCH          reduce using rule 73 (data_type -> REFERENCE STR .)
    LLLAVE          reduce using rule 73 (data_type -> REFERENCE STR .)


state 104

    (70) list_type -> LCORCH some_data_type . RCORCH

    RCORCH          shift and go to state 140


state 105

    (92) some_data_type -> data_type .
    (93) some_data_type -> data_type . COMMA some_data_type

    RCORCH          reduce using rule 92 (some_data_type -> data_type .)
    RPAREN          reduce using rule 92 (some_data_type -> data_type .)
    COMMA           shift and go to state 141


state 106

    (71) tuple_type -> LPAREN some_data_type . RPAREN

    RPAREN          shift and go to state 142


state 107

    (58) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 143


state 108

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW . data_type LLLAVE programa retorno RLLAVE
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    data_type                      shift and go to state 144
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 109

    (59) funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 59 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 59 (funcion -> FN IDENTIFIER LPAREN RPAREN LLLAVE programa RLLAVE .)


state 110

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 145


state 111

    (9) asignacion_variable -> LET IDENTIFIER ASIG . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 146
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 112

    (11) asignacion_variable -> LET IDENTIFIER COLON . asignacion
    (15) declaracion_variable -> LET IDENTIFIER COLON . asig_data_type
    (17) asignacion -> . string_asignacion
    (18) asignacion -> . numero_asignacion
    (19) asignacion -> . boolean_asignacion
    (20) asignacion -> . lista_asignacion
    (21) asignacion -> . tupla_asignacion
    (67) asig_data_type -> . data_type
    (68) asig_data_type -> . list_type
    (69) asig_data_type -> . tuple_type
    (22) string_asignacion -> . REFERENCE STR ASIG STRING
    (23) numero_asignacion -> . signed_integer ASIG INTEGER
    (24) numero_asignacion -> . signed_integer ASIG MINUS INTEGER
    (25) numero_asignacion -> . unsigned_integer ASIG INTEGER
    (26) numero_asignacion -> . float_type ASIG FLOAT
    (27) numero_asignacion -> . float_type ASIG MINUS FLOAT
    (28) boolean_asignacion -> . BOOL ASIG TRUE
    (29) boolean_asignacion -> . BOOL ASIG FALSE
    (30) lista_asignacion -> . list_type ASIG arreglos
    (31) tupla_asignacion -> . tuple_type ASIG tuplas
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (70) list_type -> . LCORCH some_data_type RCORCH
    (71) tuple_type -> . LPAREN some_data_type RPAREN
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    REFERENCE       shift and go to state 156
    BOOL            shift and go to state 160
    CHAR            shift and go to state 46
    LCORCH          shift and go to state 52
    LPAREN          shift and go to state 53
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    asignacion                     shift and go to state 147
    asig_data_type                 shift and go to state 148
    string_asignacion              shift and go to state 149
    numero_asignacion              shift and go to state 150
    boolean_asignacion             shift and go to state 151
    lista_asignacion               shift and go to state 152
    tupla_asignacion               shift and go to state 153
    data_type                      shift and go to state 43
    list_type                      shift and go to state 154
    tuple_type                     shift and go to state 155
    signed_integer                 shift and go to state 157
    unsigned_integer               shift and go to state 158
    float_type                     shift and go to state 159

state 113

    (10) asignacion_variable -> LET MUT IDENTIFIER . ASIG valor
    (12) asignacion_variable -> LET MUT IDENTIFIER . COLON asignacion
    (14) declaracion_variable -> LET MUT IDENTIFIER .
    (16) declaracion_variable -> LET MUT IDENTIFIER . COLON asig_data_type

    ASIG            shift and go to state 161
    COLON           shift and go to state 162
    SEMICOLON       reduce using rule 14 (declaracion_variable -> LET MUT IDENTIFIER .)


state 114

    (118) llamada -> IDENTIFIER LPAREN valores . RPAREN

    RPAREN          shift and go to state 163


state 115

    (119) llamada -> IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 119 (llamada -> IDENTIFIER LPAREN RPAREN .)


state 116

    (56) impresion -> PRINTLN EXCLAMATION LPAREN . valor RPAREN
    (57) impresion -> PRINTLN EXCLAMATION LPAREN . valor COMMA valores RPAREN
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 164
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 117

    (66) ingreso_datos -> STD DOUBLE_COLON IO . DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOUBLE_COLON    shift and go to state 165


state 118

    (95) arreglos -> LCORCH valores RCORCH .

    SEMICOLON       reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    COMMA           reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    RCORCH          reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    EQ              reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    NEQ             reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    GEQ             reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    LEQ             reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    RIGHTARROW      reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    LEFTARROW       reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    RPAREN          reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    LLLAVE          reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    AND             reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)
    OR              reduce using rule 95 (arreglos -> LCORCH valores RCORCH .)


state 119

    (98) valores -> valor COMMA . valores
    (97) valores -> . valor
    (98) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 86
    valores                        shift and go to state 166
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 120

    (117) indexacion -> IDENTIFIER LCORCH . INTEGER RCORCH

    INTEGER         shift and go to state 167


state 121

    (110) operacion -> numeric PLUS . numeric
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 169
    FLOAT           shift and go to state 170
    IDENTIFIER      shift and go to state 171

    numeric                        shift and go to state 168

state 122

    (111) operacion -> numeric MINUS . numeric
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 169
    FLOAT           shift and go to state 170
    IDENTIFIER      shift and go to state 171

    numeric                        shift and go to state 172

state 123

    (112) operacion -> numeric TIMES . numeric
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 169
    FLOAT           shift and go to state 170
    IDENTIFIER      shift and go to state 171

    numeric                        shift and go to state 173

state 124

    (113) operacion -> numeric DIVIDE . numeric
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 169
    FLOAT           shift and go to state 170
    IDENTIFIER      shift and go to state 171

    numeric                        shift and go to state 174

state 125

    (114) operacion -> numeric MOD . numeric
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 169
    FLOAT           shift and go to state 170
    IDENTIFIER      shift and go to state 171

    numeric                        shift and go to state 175

state 126

    (115) operacion -> numeric INTD . numeric
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER

    INTEGER         shift and go to state 169
    FLOAT           shift and go to state 170
    IDENTIFIER      shift and go to state 171

    numeric                        shift and go to state 176

state 127

    (116) operacion -> cadena PLUS . cadena
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    STRING          shift and go to state 178
    IDENTIFIER      shift and go to state 179

    cadena                         shift and go to state 177

state 128

    (103) condicional -> IF comparacion LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 180
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 129

    (101) proposicion -> comparacion conector . proposicion
    (101) proposicion -> . comparacion conector proposicion
    (102) proposicion -> . comparacion
    (32) comparacion -> . valor EQ valor
    (33) comparacion -> . valor NEQ valor
    (34) comparacion -> . valor GEQ valor
    (35) comparacion -> . valor LEQ valor
    (36) comparacion -> . valor RIGHTARROW valor
    (37) comparacion -> . valor LEFTARROW valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    comparacion                    shift and go to state 181
    proposicion                    shift and go to state 182
    valor                          shift and go to state 101
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 130

    (99) conector -> AND .

    INTEGER         reduce using rule 99 (conector -> AND .)
    FLOAT           reduce using rule 99 (conector -> AND .)
    IDENTIFIER      reduce using rule 99 (conector -> AND .)
    STRING          reduce using rule 99 (conector -> AND .)
    LCORCH          reduce using rule 99 (conector -> AND .)
    TRUE            reduce using rule 99 (conector -> AND .)
    FALSE           reduce using rule 99 (conector -> AND .)


state 131

    (100) conector -> OR .

    INTEGER         reduce using rule 100 (conector -> OR .)
    FLOAT           reduce using rule 100 (conector -> OR .)
    IDENTIFIER      reduce using rule 100 (conector -> OR .)
    STRING          reduce using rule 100 (conector -> OR .)
    LCORCH          reduce using rule 100 (conector -> OR .)
    TRUE            reduce using rule 100 (conector -> OR .)
    FALSE           reduce using rule 100 (conector -> OR .)


state 132

    (104) condicional -> IF proposicion LLLAVE . programa RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 183
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 133

    (32) comparacion -> valor EQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 184
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 134

    (33) comparacion -> valor NEQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 185
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 135

    (34) comparacion -> valor GEQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 186
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 136

    (35) comparacion -> valor LEQ . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 187
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 137

    (36) comparacion -> valor RIGHTARROW . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 188
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 138

    (37) comparacion -> valor LEFTARROW . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 189
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 139

    (64) parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .

    RPAREN          reduce using rule 64 (parameters -> IDENTIFIER COLON asig_data_type COMMA parameters .)


state 140

    (70) list_type -> LCORCH some_data_type RCORCH .

    COMMA           reduce using rule 70 (list_type -> LCORCH some_data_type RCORCH .)
    RPAREN          reduce using rule 70 (list_type -> LCORCH some_data_type RCORCH .)
    ASIG            reduce using rule 70 (list_type -> LCORCH some_data_type RCORCH .)
    SEMICOLON       reduce using rule 70 (list_type -> LCORCH some_data_type RCORCH .)


state 141

    (93) some_data_type -> data_type COMMA . some_data_type
    (92) some_data_type -> . data_type
    (93) some_data_type -> . data_type COMMA some_data_type
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    CHAR            shift and go to state 46
    REFERENCE       shift and go to state 47
    BOOL            shift and go to state 51
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    data_type                      shift and go to state 105
    some_data_type                 shift and go to state 190
    signed_integer                 shift and go to state 48
    unsigned_integer               shift and go to state 49
    float_type                     shift and go to state 50

state 142

    (71) tuple_type -> LPAREN some_data_type RPAREN .

    COMMA           reduce using rule 71 (tuple_type -> LPAREN some_data_type RPAREN .)
    RPAREN          reduce using rule 71 (tuple_type -> LPAREN some_data_type RPAREN .)
    ASIG            reduce using rule 71 (tuple_type -> LPAREN some_data_type RPAREN .)
    SEMICOLON       reduce using rule 71 (tuple_type -> LPAREN some_data_type RPAREN .)


state 143

    (58) funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .

    FN              reduce using rule 58 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)
    $end            reduce using rule 58 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN LLLAVE programa RLLAVE .)


state 144

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type . LLLAVE programa retorno RLLAVE

    LLLAVE          shift and go to state 191


state 145

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 192
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 146

    (9) asignacion_variable -> LET IDENTIFIER ASIG valor .

    SEMICOLON       reduce using rule 9 (asignacion_variable -> LET IDENTIFIER ASIG valor .)


state 147

    (11) asignacion_variable -> LET IDENTIFIER COLON asignacion .

    SEMICOLON       reduce using rule 11 (asignacion_variable -> LET IDENTIFIER COLON asignacion .)


state 148

    (15) declaracion_variable -> LET IDENTIFIER COLON asig_data_type .

    SEMICOLON       reduce using rule 15 (declaracion_variable -> LET IDENTIFIER COLON asig_data_type .)


state 149

    (17) asignacion -> string_asignacion .

    SEMICOLON       reduce using rule 17 (asignacion -> string_asignacion .)


state 150

    (18) asignacion -> numero_asignacion .

    SEMICOLON       reduce using rule 18 (asignacion -> numero_asignacion .)


state 151

    (19) asignacion -> boolean_asignacion .

    SEMICOLON       reduce using rule 19 (asignacion -> boolean_asignacion .)


state 152

    (20) asignacion -> lista_asignacion .

    SEMICOLON       reduce using rule 20 (asignacion -> lista_asignacion .)


state 153

    (21) asignacion -> tupla_asignacion .

    SEMICOLON       reduce using rule 21 (asignacion -> tupla_asignacion .)


state 154

    (68) asig_data_type -> list_type .
    (30) lista_asignacion -> list_type . ASIG arreglos

    SEMICOLON       reduce using rule 68 (asig_data_type -> list_type .)
    ASIG            shift and go to state 193


state 155

    (69) asig_data_type -> tuple_type .
    (31) tupla_asignacion -> tuple_type . ASIG tuplas

    SEMICOLON       reduce using rule 69 (asig_data_type -> tuple_type .)
    ASIG            shift and go to state 194


state 156

    (22) string_asignacion -> REFERENCE . STR ASIG STRING
    (73) data_type -> REFERENCE . STR

    STR             shift and go to state 195


state 157

    (23) numero_asignacion -> signed_integer . ASIG INTEGER
    (24) numero_asignacion -> signed_integer . ASIG MINUS INTEGER
    (74) data_type -> signed_integer .

    ASIG            shift and go to state 196
    SEMICOLON       reduce using rule 74 (data_type -> signed_integer .)


state 158

    (25) numero_asignacion -> unsigned_integer . ASIG INTEGER
    (75) data_type -> unsigned_integer .

    ASIG            shift and go to state 197
    SEMICOLON       reduce using rule 75 (data_type -> unsigned_integer .)


state 159

    (26) numero_asignacion -> float_type . ASIG FLOAT
    (27) numero_asignacion -> float_type . ASIG MINUS FLOAT
    (76) data_type -> float_type .

    ASIG            shift and go to state 198
    SEMICOLON       reduce using rule 76 (data_type -> float_type .)


state 160

    (28) boolean_asignacion -> BOOL . ASIG TRUE
    (29) boolean_asignacion -> BOOL . ASIG FALSE
    (77) data_type -> BOOL .

    ASIG            shift and go to state 199
    SEMICOLON       reduce using rule 77 (data_type -> BOOL .)


state 161

    (10) asignacion_variable -> LET MUT IDENTIFIER ASIG . valor
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 200
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 162

    (12) asignacion_variable -> LET MUT IDENTIFIER COLON . asignacion
    (16) declaracion_variable -> LET MUT IDENTIFIER COLON . asig_data_type
    (17) asignacion -> . string_asignacion
    (18) asignacion -> . numero_asignacion
    (19) asignacion -> . boolean_asignacion
    (20) asignacion -> . lista_asignacion
    (21) asignacion -> . tupla_asignacion
    (67) asig_data_type -> . data_type
    (68) asig_data_type -> . list_type
    (69) asig_data_type -> . tuple_type
    (22) string_asignacion -> . REFERENCE STR ASIG STRING
    (23) numero_asignacion -> . signed_integer ASIG INTEGER
    (24) numero_asignacion -> . signed_integer ASIG MINUS INTEGER
    (25) numero_asignacion -> . unsigned_integer ASIG INTEGER
    (26) numero_asignacion -> . float_type ASIG FLOAT
    (27) numero_asignacion -> . float_type ASIG MINUS FLOAT
    (28) boolean_asignacion -> . BOOL ASIG TRUE
    (29) boolean_asignacion -> . BOOL ASIG FALSE
    (30) lista_asignacion -> . list_type ASIG arreglos
    (31) tupla_asignacion -> . tuple_type ASIG tuplas
    (72) data_type -> . CHAR
    (73) data_type -> . REFERENCE STR
    (74) data_type -> . signed_integer
    (75) data_type -> . unsigned_integer
    (76) data_type -> . float_type
    (77) data_type -> . BOOL
    (70) list_type -> . LCORCH some_data_type RCORCH
    (71) tuple_type -> . LPAREN some_data_type RPAREN
    (78) signed_integer -> . I8
    (79) signed_integer -> . I16
    (80) signed_integer -> . I32
    (81) signed_integer -> . I64
    (82) signed_integer -> . I128
    (83) signed_integer -> . ISIZE
    (84) unsigned_integer -> . U8
    (85) unsigned_integer -> . U16
    (86) unsigned_integer -> . U32
    (87) unsigned_integer -> . U64
    (88) unsigned_integer -> . U128
    (89) unsigned_integer -> . USIZE
    (90) float_type -> . F32
    (91) float_type -> . F64

    REFERENCE       shift and go to state 156
    BOOL            shift and go to state 160
    CHAR            shift and go to state 46
    LCORCH          shift and go to state 52
    LPAREN          shift and go to state 53
    I8              shift and go to state 54
    I16             shift and go to state 55
    I32             shift and go to state 56
    I64             shift and go to state 57
    I128            shift and go to state 58
    ISIZE           shift and go to state 59
    U8              shift and go to state 60
    U16             shift and go to state 61
    U32             shift and go to state 62
    U64             shift and go to state 63
    U128            shift and go to state 64
    USIZE           shift and go to state 65
    F32             shift and go to state 66
    F64             shift and go to state 67

    asignacion                     shift and go to state 201
    asig_data_type                 shift and go to state 202
    string_asignacion              shift and go to state 149
    numero_asignacion              shift and go to state 150
    boolean_asignacion             shift and go to state 151
    lista_asignacion               shift and go to state 152
    tupla_asignacion               shift and go to state 153
    data_type                      shift and go to state 43
    list_type                      shift and go to state 154
    tuple_type                     shift and go to state 155
    signed_integer                 shift and go to state 157
    unsigned_integer               shift and go to state 158
    float_type                     shift and go to state 159

state 163

    (118) llamada -> IDENTIFIER LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 118 (llamada -> IDENTIFIER LPAREN valores RPAREN .)


state 164

    (56) impresion -> PRINTLN EXCLAMATION LPAREN valor . RPAREN
    (57) impresion -> PRINTLN EXCLAMATION LPAREN valor . COMMA valores RPAREN

    RPAREN          shift and go to state 203
    COMMA           shift and go to state 204


state 165

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON . DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 205


state 166

    (98) valores -> valor COMMA valores .

    RCORCH          reduce using rule 98 (valores -> valor COMMA valores .)
    RPAREN          reduce using rule 98 (valores -> valor COMMA valores .)


state 167

    (117) indexacion -> IDENTIFIER LCORCH INTEGER . RCORCH

    RCORCH          shift and go to state 206


state 168

    (110) operacion -> numeric PLUS numeric .

    COMMA           reduce using rule 110 (operacion -> numeric PLUS numeric .)
    RCORCH          reduce using rule 110 (operacion -> numeric PLUS numeric .)
    EQ              reduce using rule 110 (operacion -> numeric PLUS numeric .)
    NEQ             reduce using rule 110 (operacion -> numeric PLUS numeric .)
    GEQ             reduce using rule 110 (operacion -> numeric PLUS numeric .)
    LEQ             reduce using rule 110 (operacion -> numeric PLUS numeric .)
    RIGHTARROW      reduce using rule 110 (operacion -> numeric PLUS numeric .)
    LEFTARROW       reduce using rule 110 (operacion -> numeric PLUS numeric .)
    RPAREN          reduce using rule 110 (operacion -> numeric PLUS numeric .)
    SEMICOLON       reduce using rule 110 (operacion -> numeric PLUS numeric .)
    LLLAVE          reduce using rule 110 (operacion -> numeric PLUS numeric .)
    AND             reduce using rule 110 (operacion -> numeric PLUS numeric .)
    OR              reduce using rule 110 (operacion -> numeric PLUS numeric .)


state 169

    (105) numeric -> INTEGER .

    COMMA           reduce using rule 105 (numeric -> INTEGER .)
    RCORCH          reduce using rule 105 (numeric -> INTEGER .)
    EQ              reduce using rule 105 (numeric -> INTEGER .)
    NEQ             reduce using rule 105 (numeric -> INTEGER .)
    GEQ             reduce using rule 105 (numeric -> INTEGER .)
    LEQ             reduce using rule 105 (numeric -> INTEGER .)
    RIGHTARROW      reduce using rule 105 (numeric -> INTEGER .)
    LEFTARROW       reduce using rule 105 (numeric -> INTEGER .)
    RPAREN          reduce using rule 105 (numeric -> INTEGER .)
    SEMICOLON       reduce using rule 105 (numeric -> INTEGER .)
    LLLAVE          reduce using rule 105 (numeric -> INTEGER .)
    AND             reduce using rule 105 (numeric -> INTEGER .)
    OR              reduce using rule 105 (numeric -> INTEGER .)


state 170

    (106) numeric -> FLOAT .

    COMMA           reduce using rule 106 (numeric -> FLOAT .)
    RCORCH          reduce using rule 106 (numeric -> FLOAT .)
    EQ              reduce using rule 106 (numeric -> FLOAT .)
    NEQ             reduce using rule 106 (numeric -> FLOAT .)
    GEQ             reduce using rule 106 (numeric -> FLOAT .)
    LEQ             reduce using rule 106 (numeric -> FLOAT .)
    RIGHTARROW      reduce using rule 106 (numeric -> FLOAT .)
    LEFTARROW       reduce using rule 106 (numeric -> FLOAT .)
    RPAREN          reduce using rule 106 (numeric -> FLOAT .)
    SEMICOLON       reduce using rule 106 (numeric -> FLOAT .)
    LLLAVE          reduce using rule 106 (numeric -> FLOAT .)
    AND             reduce using rule 106 (numeric -> FLOAT .)
    OR              reduce using rule 106 (numeric -> FLOAT .)


state 171

    (107) numeric -> IDENTIFIER .

    COMMA           reduce using rule 107 (numeric -> IDENTIFIER .)
    RCORCH          reduce using rule 107 (numeric -> IDENTIFIER .)
    EQ              reduce using rule 107 (numeric -> IDENTIFIER .)
    NEQ             reduce using rule 107 (numeric -> IDENTIFIER .)
    GEQ             reduce using rule 107 (numeric -> IDENTIFIER .)
    LEQ             reduce using rule 107 (numeric -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 107 (numeric -> IDENTIFIER .)
    LEFTARROW       reduce using rule 107 (numeric -> IDENTIFIER .)
    RPAREN          reduce using rule 107 (numeric -> IDENTIFIER .)
    SEMICOLON       reduce using rule 107 (numeric -> IDENTIFIER .)
    LLLAVE          reduce using rule 107 (numeric -> IDENTIFIER .)
    AND             reduce using rule 107 (numeric -> IDENTIFIER .)
    OR              reduce using rule 107 (numeric -> IDENTIFIER .)


state 172

    (111) operacion -> numeric MINUS numeric .

    COMMA           reduce using rule 111 (operacion -> numeric MINUS numeric .)
    RCORCH          reduce using rule 111 (operacion -> numeric MINUS numeric .)
    EQ              reduce using rule 111 (operacion -> numeric MINUS numeric .)
    NEQ             reduce using rule 111 (operacion -> numeric MINUS numeric .)
    GEQ             reduce using rule 111 (operacion -> numeric MINUS numeric .)
    LEQ             reduce using rule 111 (operacion -> numeric MINUS numeric .)
    RIGHTARROW      reduce using rule 111 (operacion -> numeric MINUS numeric .)
    LEFTARROW       reduce using rule 111 (operacion -> numeric MINUS numeric .)
    RPAREN          reduce using rule 111 (operacion -> numeric MINUS numeric .)
    SEMICOLON       reduce using rule 111 (operacion -> numeric MINUS numeric .)
    LLLAVE          reduce using rule 111 (operacion -> numeric MINUS numeric .)
    AND             reduce using rule 111 (operacion -> numeric MINUS numeric .)
    OR              reduce using rule 111 (operacion -> numeric MINUS numeric .)


state 173

    (112) operacion -> numeric TIMES numeric .

    COMMA           reduce using rule 112 (operacion -> numeric TIMES numeric .)
    RCORCH          reduce using rule 112 (operacion -> numeric TIMES numeric .)
    EQ              reduce using rule 112 (operacion -> numeric TIMES numeric .)
    NEQ             reduce using rule 112 (operacion -> numeric TIMES numeric .)
    GEQ             reduce using rule 112 (operacion -> numeric TIMES numeric .)
    LEQ             reduce using rule 112 (operacion -> numeric TIMES numeric .)
    RIGHTARROW      reduce using rule 112 (operacion -> numeric TIMES numeric .)
    LEFTARROW       reduce using rule 112 (operacion -> numeric TIMES numeric .)
    RPAREN          reduce using rule 112 (operacion -> numeric TIMES numeric .)
    SEMICOLON       reduce using rule 112 (operacion -> numeric TIMES numeric .)
    LLLAVE          reduce using rule 112 (operacion -> numeric TIMES numeric .)
    AND             reduce using rule 112 (operacion -> numeric TIMES numeric .)
    OR              reduce using rule 112 (operacion -> numeric TIMES numeric .)


state 174

    (113) operacion -> numeric DIVIDE numeric .

    COMMA           reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    RCORCH          reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    EQ              reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    NEQ             reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    GEQ             reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    LEQ             reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    RIGHTARROW      reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    LEFTARROW       reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    RPAREN          reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    SEMICOLON       reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    LLLAVE          reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    AND             reduce using rule 113 (operacion -> numeric DIVIDE numeric .)
    OR              reduce using rule 113 (operacion -> numeric DIVIDE numeric .)


state 175

    (114) operacion -> numeric MOD numeric .

    COMMA           reduce using rule 114 (operacion -> numeric MOD numeric .)
    RCORCH          reduce using rule 114 (operacion -> numeric MOD numeric .)
    EQ              reduce using rule 114 (operacion -> numeric MOD numeric .)
    NEQ             reduce using rule 114 (operacion -> numeric MOD numeric .)
    GEQ             reduce using rule 114 (operacion -> numeric MOD numeric .)
    LEQ             reduce using rule 114 (operacion -> numeric MOD numeric .)
    RIGHTARROW      reduce using rule 114 (operacion -> numeric MOD numeric .)
    LEFTARROW       reduce using rule 114 (operacion -> numeric MOD numeric .)
    RPAREN          reduce using rule 114 (operacion -> numeric MOD numeric .)
    SEMICOLON       reduce using rule 114 (operacion -> numeric MOD numeric .)
    LLLAVE          reduce using rule 114 (operacion -> numeric MOD numeric .)
    AND             reduce using rule 114 (operacion -> numeric MOD numeric .)
    OR              reduce using rule 114 (operacion -> numeric MOD numeric .)


state 176

    (115) operacion -> numeric INTD numeric .

    COMMA           reduce using rule 115 (operacion -> numeric INTD numeric .)
    RCORCH          reduce using rule 115 (operacion -> numeric INTD numeric .)
    EQ              reduce using rule 115 (operacion -> numeric INTD numeric .)
    NEQ             reduce using rule 115 (operacion -> numeric INTD numeric .)
    GEQ             reduce using rule 115 (operacion -> numeric INTD numeric .)
    LEQ             reduce using rule 115 (operacion -> numeric INTD numeric .)
    RIGHTARROW      reduce using rule 115 (operacion -> numeric INTD numeric .)
    LEFTARROW       reduce using rule 115 (operacion -> numeric INTD numeric .)
    RPAREN          reduce using rule 115 (operacion -> numeric INTD numeric .)
    SEMICOLON       reduce using rule 115 (operacion -> numeric INTD numeric .)
    LLLAVE          reduce using rule 115 (operacion -> numeric INTD numeric .)
    AND             reduce using rule 115 (operacion -> numeric INTD numeric .)
    OR              reduce using rule 115 (operacion -> numeric INTD numeric .)


state 177

    (116) operacion -> cadena PLUS cadena .

    COMMA           reduce using rule 116 (operacion -> cadena PLUS cadena .)
    RCORCH          reduce using rule 116 (operacion -> cadena PLUS cadena .)
    EQ              reduce using rule 116 (operacion -> cadena PLUS cadena .)
    NEQ             reduce using rule 116 (operacion -> cadena PLUS cadena .)
    GEQ             reduce using rule 116 (operacion -> cadena PLUS cadena .)
    LEQ             reduce using rule 116 (operacion -> cadena PLUS cadena .)
    RIGHTARROW      reduce using rule 116 (operacion -> cadena PLUS cadena .)
    LEFTARROW       reduce using rule 116 (operacion -> cadena PLUS cadena .)
    RPAREN          reduce using rule 116 (operacion -> cadena PLUS cadena .)
    SEMICOLON       reduce using rule 116 (operacion -> cadena PLUS cadena .)
    LLLAVE          reduce using rule 116 (operacion -> cadena PLUS cadena .)
    AND             reduce using rule 116 (operacion -> cadena PLUS cadena .)
    OR              reduce using rule 116 (operacion -> cadena PLUS cadena .)


state 178

    (108) cadena -> STRING .

    COMMA           reduce using rule 108 (cadena -> STRING .)
    RCORCH          reduce using rule 108 (cadena -> STRING .)
    EQ              reduce using rule 108 (cadena -> STRING .)
    NEQ             reduce using rule 108 (cadena -> STRING .)
    GEQ             reduce using rule 108 (cadena -> STRING .)
    LEQ             reduce using rule 108 (cadena -> STRING .)
    RIGHTARROW      reduce using rule 108 (cadena -> STRING .)
    LEFTARROW       reduce using rule 108 (cadena -> STRING .)
    RPAREN          reduce using rule 108 (cadena -> STRING .)
    SEMICOLON       reduce using rule 108 (cadena -> STRING .)
    LLLAVE          reduce using rule 108 (cadena -> STRING .)
    AND             reduce using rule 108 (cadena -> STRING .)
    OR              reduce using rule 108 (cadena -> STRING .)


state 179

    (109) cadena -> IDENTIFIER .

    COMMA           reduce using rule 109 (cadena -> IDENTIFIER .)
    RCORCH          reduce using rule 109 (cadena -> IDENTIFIER .)
    EQ              reduce using rule 109 (cadena -> IDENTIFIER .)
    NEQ             reduce using rule 109 (cadena -> IDENTIFIER .)
    GEQ             reduce using rule 109 (cadena -> IDENTIFIER .)
    LEQ             reduce using rule 109 (cadena -> IDENTIFIER .)
    RIGHTARROW      reduce using rule 109 (cadena -> IDENTIFIER .)
    LEFTARROW       reduce using rule 109 (cadena -> IDENTIFIER .)
    RPAREN          reduce using rule 109 (cadena -> IDENTIFIER .)
    SEMICOLON       reduce using rule 109 (cadena -> IDENTIFIER .)
    LLLAVE          reduce using rule 109 (cadena -> IDENTIFIER .)
    AND             reduce using rule 109 (cadena -> IDENTIFIER .)
    OR              reduce using rule 109 (cadena -> IDENTIFIER .)


state 180

    (103) condicional -> IF comparacion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 207


state 181

    (101) proposicion -> comparacion . conector proposicion
    (102) proposicion -> comparacion .
    (99) conector -> . AND
    (100) conector -> . OR

    LLLAVE          reduce using rule 102 (proposicion -> comparacion .)
    AND             shift and go to state 130
    OR              shift and go to state 131

    conector                       shift and go to state 129

state 182

    (101) proposicion -> comparacion conector proposicion .

    LLLAVE          reduce using rule 101 (proposicion -> comparacion conector proposicion .)


state 183

    (104) condicional -> IF proposicion LLLAVE programa . RLLAVE

    RLLAVE          shift and go to state 208


state 184

    (32) comparacion -> valor EQ valor .

    LLLAVE          reduce using rule 32 (comparacion -> valor EQ valor .)
    AND             reduce using rule 32 (comparacion -> valor EQ valor .)
    OR              reduce using rule 32 (comparacion -> valor EQ valor .)


state 185

    (33) comparacion -> valor NEQ valor .

    LLLAVE          reduce using rule 33 (comparacion -> valor NEQ valor .)
    AND             reduce using rule 33 (comparacion -> valor NEQ valor .)
    OR              reduce using rule 33 (comparacion -> valor NEQ valor .)


state 186

    (34) comparacion -> valor GEQ valor .

    LLLAVE          reduce using rule 34 (comparacion -> valor GEQ valor .)
    AND             reduce using rule 34 (comparacion -> valor GEQ valor .)
    OR              reduce using rule 34 (comparacion -> valor GEQ valor .)


state 187

    (35) comparacion -> valor LEQ valor .

    LLLAVE          reduce using rule 35 (comparacion -> valor LEQ valor .)
    AND             reduce using rule 35 (comparacion -> valor LEQ valor .)
    OR              reduce using rule 35 (comparacion -> valor LEQ valor .)


state 188

    (36) comparacion -> valor RIGHTARROW valor .

    LLLAVE          reduce using rule 36 (comparacion -> valor RIGHTARROW valor .)
    AND             reduce using rule 36 (comparacion -> valor RIGHTARROW valor .)
    OR              reduce using rule 36 (comparacion -> valor RIGHTARROW valor .)


state 189

    (37) comparacion -> valor LEFTARROW valor .

    LLLAVE          reduce using rule 37 (comparacion -> valor LEFTARROW valor .)
    AND             reduce using rule 37 (comparacion -> valor LEFTARROW valor .)
    OR              reduce using rule 37 (comparacion -> valor LEFTARROW valor .)


state 190

    (93) some_data_type -> data_type COMMA some_data_type .

    RCORCH          reduce using rule 93 (some_data_type -> data_type COMMA some_data_type .)
    RPAREN          reduce using rule 93 (some_data_type -> data_type COMMA some_data_type .)


state 191

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE . programa retorno RLLAVE
    (7) programa -> . sentencias
    (8) programa -> . sentencias programa
    (49) sentencias -> . asignacion_variable SEMICOLON
    (50) sentencias -> . declaracion_variable SEMICOLON
    (51) sentencias -> . impresion SEMICOLON
    (52) sentencias -> . ingreso_datos SEMICOLON
    (53) sentencias -> . arreglos SEMICOLON
    (54) sentencias -> . control_structure
    (55) sentencias -> . llamada SEMICOLON
    (9) asignacion_variable -> . LET IDENTIFIER ASIG valor
    (10) asignacion_variable -> . LET MUT IDENTIFIER ASIG valor
    (11) asignacion_variable -> . LET IDENTIFIER COLON asignacion
    (12) asignacion_variable -> . LET MUT IDENTIFIER COLON asignacion
    (13) declaracion_variable -> . LET IDENTIFIER
    (14) declaracion_variable -> . LET MUT IDENTIFIER
    (15) declaracion_variable -> . LET IDENTIFIER COLON asig_data_type
    (16) declaracion_variable -> . LET MUT IDENTIFIER COLON asig_data_type
    (56) impresion -> . PRINTLN EXCLAMATION LPAREN valor RPAREN
    (57) impresion -> . PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN
    (66) ingreso_datos -> . STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN
    (95) arreglos -> . LCORCH valores RCORCH
    (94) control_structure -> . condicional
    (118) llamada -> . IDENTIFIER LPAREN valores RPAREN
    (119) llamada -> . IDENTIFIER LPAREN RPAREN
    (103) condicional -> . IF comparacion LLLAVE programa RLLAVE
    (104) condicional -> . IF proposicion LLLAVE programa RLLAVE

    LET             shift and go to state 35
    PRINTLN         shift and go to state 37
    STD             shift and go to state 38
    LCORCH          shift and go to state 39
    IDENTIFIER      shift and go to state 36
    IF              shift and go to state 41

    programa                       shift and go to state 209
    sentencias                     shift and go to state 27
    asignacion_variable            shift and go to state 28
    declaracion_variable           shift and go to state 29
    impresion                      shift and go to state 30
    ingreso_datos                  shift and go to state 31
    arreglos                       shift and go to state 32
    control_structure              shift and go to state 33
    llamada                        shift and go to state 34
    condicional                    shift and go to state 40

state 192

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (62) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 211

    retorno                        shift and go to state 210

state 193

    (30) lista_asignacion -> list_type ASIG . arreglos
    (95) arreglos -> . LCORCH valores RCORCH

    LCORCH          shift and go to state 39

    arreglos                       shift and go to state 212

state 194

    (31) tupla_asignacion -> tuple_type ASIG . tuplas
    (96) tuplas -> . LPAREN valores RPAREN

    LPAREN          shift and go to state 214

    tuplas                         shift and go to state 213

state 195

    (22) string_asignacion -> REFERENCE STR . ASIG STRING
    (73) data_type -> REFERENCE STR .

    ASIG            shift and go to state 215
    SEMICOLON       reduce using rule 73 (data_type -> REFERENCE STR .)


state 196

    (23) numero_asignacion -> signed_integer ASIG . INTEGER
    (24) numero_asignacion -> signed_integer ASIG . MINUS INTEGER

    INTEGER         shift and go to state 216
    MINUS           shift and go to state 217


state 197

    (25) numero_asignacion -> unsigned_integer ASIG . INTEGER

    INTEGER         shift and go to state 218


state 198

    (26) numero_asignacion -> float_type ASIG . FLOAT
    (27) numero_asignacion -> float_type ASIG . MINUS FLOAT

    FLOAT           shift and go to state 219
    MINUS           shift and go to state 220


state 199

    (28) boolean_asignacion -> BOOL ASIG . TRUE
    (29) boolean_asignacion -> BOOL ASIG . FALSE

    TRUE            shift and go to state 221
    FALSE           shift and go to state 222


state 200

    (10) asignacion_variable -> LET MUT IDENTIFIER ASIG valor .

    SEMICOLON       reduce using rule 10 (asignacion_variable -> LET MUT IDENTIFIER ASIG valor .)


state 201

    (12) asignacion_variable -> LET MUT IDENTIFIER COLON asignacion .

    SEMICOLON       reduce using rule 12 (asignacion_variable -> LET MUT IDENTIFIER COLON asignacion .)


state 202

    (16) declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type .

    SEMICOLON       reduce using rule 16 (declaracion_variable -> LET MUT IDENTIFIER COLON asig_data_type .)


state 203

    (56) impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 56 (impresion -> PRINTLN EXCLAMATION LPAREN valor RPAREN .)


state 204

    (57) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA . valores RPAREN
    (97) valores -> . valor
    (98) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 86
    valores                        shift and go to state 223
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 205

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT . STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    STDIN           shift and go to state 224


state 206

    (117) indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .

    COMMA           reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RCORCH          reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    EQ              reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    NEQ             reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    GEQ             reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEQ             reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RIGHTARROW      reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LEFTARROW       reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    RPAREN          reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    SEMICOLON       reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    LLLAVE          reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    AND             reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)
    OR              reduce using rule 117 (indexacion -> IDENTIFIER LCORCH INTEGER RCORCH .)


state 207

    (103) condicional -> IF comparacion LLLAVE programa RLLAVE .

    LET             reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    STD             reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    IF              reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 103 (condicional -> IF comparacion LLLAVE programa RLLAVE .)


state 208

    (104) condicional -> IF proposicion LLLAVE programa RLLAVE .

    LET             reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    PRINTLN         reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    STD             reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    LCORCH          reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IDENTIFIER      reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    IF              reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RLLAVE          reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)
    RETURN          reduce using rule 104 (condicional -> IF proposicion LLLAVE programa RLLAVE .)


state 209

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa . retorno RLLAVE
    (62) retorno -> . RETURN valor SEMICOLON

    RETURN          shift and go to state 211

    retorno                        shift and go to state 225

state 210

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 226


state 211

    (62) retorno -> RETURN . valor SEMICOLON
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valor                          shift and go to state 227
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 212

    (30) lista_asignacion -> list_type ASIG arreglos .

    SEMICOLON       reduce using rule 30 (lista_asignacion -> list_type ASIG arreglos .)


state 213

    (31) tupla_asignacion -> tuple_type ASIG tuplas .

    SEMICOLON       reduce using rule 31 (tupla_asignacion -> tuple_type ASIG tuplas .)


state 214

    (96) tuplas -> LPAREN . valores RPAREN
    (97) valores -> . valor
    (98) valores -> . valor COMMA valores
    (38) valor -> . INTEGER
    (39) valor -> . FLOAT
    (40) valor -> . IDENTIFIER
    (41) valor -> . operacion
    (42) valor -> . indexacion
    (43) valor -> . arreglos
    (44) valor -> . STRING
    (45) valor -> . booleanos
    (110) operacion -> . numeric PLUS numeric
    (111) operacion -> . numeric MINUS numeric
    (112) operacion -> . numeric TIMES numeric
    (113) operacion -> . numeric DIVIDE numeric
    (114) operacion -> . numeric MOD numeric
    (115) operacion -> . numeric INTD numeric
    (116) operacion -> . cadena PLUS cadena
    (117) indexacion -> . IDENTIFIER LCORCH INTEGER RCORCH
    (95) arreglos -> . LCORCH valores RCORCH
    (46) booleanos -> . TRUE
    (47) booleanos -> . FALSE
    (105) numeric -> . INTEGER
    (106) numeric -> . FLOAT
    (107) numeric -> . IDENTIFIER
    (108) cadena -> . STRING
    (109) cadena -> . IDENTIFIER

    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    IDENTIFIER      shift and go to state 89
    STRING          shift and go to state 93
    LCORCH          shift and go to state 39
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    valores                        shift and go to state 228
    valor                          shift and go to state 86
    operacion                      shift and go to state 90
    indexacion                     shift and go to state 91
    arreglos                       shift and go to state 92
    booleanos                      shift and go to state 94
    numeric                        shift and go to state 95
    cadena                         shift and go to state 96

state 215

    (22) string_asignacion -> REFERENCE STR ASIG . STRING

    STRING          shift and go to state 229


state 216

    (23) numero_asignacion -> signed_integer ASIG INTEGER .

    SEMICOLON       reduce using rule 23 (numero_asignacion -> signed_integer ASIG INTEGER .)


state 217

    (24) numero_asignacion -> signed_integer ASIG MINUS . INTEGER

    INTEGER         shift and go to state 230


state 218

    (25) numero_asignacion -> unsigned_integer ASIG INTEGER .

    SEMICOLON       reduce using rule 25 (numero_asignacion -> unsigned_integer ASIG INTEGER .)


state 219

    (26) numero_asignacion -> float_type ASIG FLOAT .

    SEMICOLON       reduce using rule 26 (numero_asignacion -> float_type ASIG FLOAT .)


state 220

    (27) numero_asignacion -> float_type ASIG MINUS . FLOAT

    FLOAT           shift and go to state 231


state 221

    (28) boolean_asignacion -> BOOL ASIG TRUE .

    SEMICOLON       reduce using rule 28 (boolean_asignacion -> BOOL ASIG TRUE .)


state 222

    (29) boolean_asignacion -> BOOL ASIG FALSE .

    SEMICOLON       reduce using rule 29 (boolean_asignacion -> BOOL ASIG FALSE .)


state 223

    (57) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores . RPAREN

    RPAREN          shift and go to state 232


state 224

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN . LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 233


state 225

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno . RLLAVE

    RLLAVE          shift and go to state 234


state 226

    (61) funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    FN              reduce using rule 61 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 61 (funcion -> FN IDENTIFIER LPAREN RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 227

    (62) retorno -> RETURN valor . SEMICOLON

    SEMICOLON       shift and go to state 235


state 228

    (96) tuplas -> LPAREN valores . RPAREN

    RPAREN          shift and go to state 236


state 229

    (22) string_asignacion -> REFERENCE STR ASIG STRING .

    SEMICOLON       reduce using rule 22 (string_asignacion -> REFERENCE STR ASIG STRING .)


state 230

    (24) numero_asignacion -> signed_integer ASIG MINUS INTEGER .

    SEMICOLON       reduce using rule 24 (numero_asignacion -> signed_integer ASIG MINUS INTEGER .)


state 231

    (27) numero_asignacion -> float_type ASIG MINUS FLOAT .

    SEMICOLON       reduce using rule 27 (numero_asignacion -> float_type ASIG MINUS FLOAT .)


state 232

    (57) impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .

    SEMICOLON       reduce using rule 57 (impresion -> PRINTLN EXCLAMATION LPAREN valor COMMA valores RPAREN .)


state 233

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN . RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    RPAREN          shift and go to state 237


state 234

    (60) funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .

    FN              reduce using rule 60 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)
    $end            reduce using rule 60 (funcion -> FN IDENTIFIER LPAREN parameters RPAREN MINUS RIGHTARROW data_type LLLAVE programa retorno RLLAVE .)


state 235

    (62) retorno -> RETURN valor SEMICOLON .

    RLLAVE          reduce using rule 62 (retorno -> RETURN valor SEMICOLON .)


state 236

    (96) tuplas -> LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 96 (tuplas -> LPAREN valores RPAREN .)


state 237

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN . DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    DOT             shift and go to state 238


state 238

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT . READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN

    READLINE        shift and go to state 239


state 239

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE . LPAREN REFERENCE MUT IDENTIFIER RPAREN

    LPAREN          shift and go to state 240


state 240

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN . REFERENCE MUT IDENTIFIER RPAREN

    REFERENCE       shift and go to state 241


state 241

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE . MUT IDENTIFIER RPAREN

    MUT             shift and go to state 242


state 242

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 243


state 243

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER . RPAREN

    RPAREN          shift and go to state 244


state 244

    (66) ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .

    SEMICOLON       reduce using rule 66 (ingreso_datos -> STD DOUBLE_COLON IO DOUBLE_COLON DOT STDIN LPAREN RPAREN DOT READLINE LPAREN REFERENCE MUT IDENTIFIER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 15 resolved as shift
WARNING: shift/reduce conflict for LLLAVE in state 99 resolved as shift
WARNING: reduce/reduce conflict in state 89 resolved using rule (numeric -> IDENTIFIER)
WARNING: rejected rule (cadena -> IDENTIFIER) in state 89
